<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>重新定义Hello World | 蛙蛙池塘</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="目录  原始的 Hello World 程序 配置开发环境 单元测试 代码实现 代码调试 安全测试 fuzz 性能测试 性能剖析 性能优化  ¶原始的 Hello World 原始的 Hello World 程序是 Brian Kernighan 和 Dennis Ritchie(K&amp;amp;R) 在 1978 年为《The C Programming Language》一书写的例子，后来成为了所">
<meta property="og:type" content="article">
<meta property="og:title" content="重新定义Hello World">
<meta property="og:url" content="http://blog.ihuhao.com/2022/08/20/重新定义Hello-World/index.html">
<meta property="og:site_name" content="蛙蛙池塘">
<meta property="og:description" content="目录  原始的 Hello World 程序 配置开发环境 单元测试 代码实现 代码调试 安全测试 fuzz 性能测试 性能剖析 性能优化  ¶原始的 Hello World 原始的 Hello World 程序是 Brian Kernighan 和 Dennis Ritchie(K&amp;amp;R) 在 1978 年为《The C Programming Language》一书写的例子，后来成为了所">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-08-20T09:32:54.536Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="重新定义Hello World">
<meta name="twitter:description" content="目录  原始的 Hello World 程序 配置开发环境 单元测试 代码实现 代码调试 安全测试 fuzz 性能测试 性能剖析 性能优化  ¶原始的 Hello World 原始的 Hello World 程序是 Brian Kernighan 和 Dennis Ritchie(K&amp;amp;R) 在 1978 年为《The C Programming Language》一书写的例子，后来成为了所">
  
    <link rel="alternative" href="/atom.xml" title="蛙蛙池塘" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/avatar.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">onlytiancai</a></h1>
		</hgroup>

		
		<p class="header-subtitle">欢迎来到蛙蛙池塘</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/onlytiancai" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/onlytiancai" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="mailto:onlytiancai@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/centos/" style="font-size: 10px;">centos</a> <a href="/tags/cmder/" style="font-size: 10px;">cmder</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/putty/" style="font-size: 10px;">putty</a> <a href="/tags/vagrant/" style="font-size: 10px;">vagrant</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/主机迁移/" style="font-size: 10px;">主机迁移</a> <a href="/tags/监控/" style="font-size: 10px;">监控</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.dnspod.cn/">DNSPod</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.qcloud.com/">腾讯云</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">碧云天，黄花地，西风紧。北雁南飞。晓来谁染霜林醉？总是离人泪。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">onlytiancai</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">onlytiancai</h1>
			</hgroup>
			
			<p class="header-subtitle">欢迎来到蛙蛙池塘</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/onlytiancai" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/onlytiancai" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="mailto:onlytiancai@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-重新定义Hello-World" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/20/重新定义Hello-World/" class="article-date">
  	<time datetime="2022-08-20T03:26:14.000Z" itemprop="datePublished">2022-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      重新定义Hello World
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目录</p>
<ul>
<li>原始的 Hello World 程序</li>
<li>配置开发环境</li>
<li>单元测试</li>
<li>代码实现</li>
<li>代码调试</li>
<li>安全测试 fuzz</li>
<li>性能测试</li>
<li>性能剖析</li>
<li>性能优化</li>
</ul>
<h3 id="原始的-Hello-World"><a class="header-anchor" href="#原始的-Hello-World">¶</a>原始的 Hello World</h3>
<p>原始的 Hello World 程序是 Brian Kernighan 和 Dennis Ritchie(K&amp;R) 在 1978 年为《The C Programming Language》一书写的例子，后来成为了所有程序员的入门必学的例子。</p>
<pre><code>#include &lt;stdio.h&gt;

main()
{
    printf(&quot;hello, world\n&quot;);
}
</code></pre>
<p>可以看到，这段代码和现在的 C 代码有很大的差别，main 函数没有参数也没有返回值，因为那会 C 语言的规范还没有确定，硬件也比较受限。而且原始的 hello world 程序全是小写，hello 后面有个逗号，但结尾没有句号，这应该是随手示例的。</p>
<p>要编译这段古老的代码，我们要使用 C90 标准：</p>
<pre><code>$ gcc -std=gnu90 k-r-hello-world.c
$ ./a.out
hello, world
</code></pre>
<p>参考链接：</p>
<ul>
<li><a href="https://riptutorial.com/c/example/3675/original--hello--world---in-k-r-c" target="_blank" rel="noopener">Original “Hello, World!” in K&amp;R C</a></li>
</ul>
<h3 id="配置开发环境"><a class="header-anchor" href="#配置开发环境">¶</a>配置开发环境</h3>
<p>工欲善其事必先利其器，假设我们使用 VIM 开发 C 语言，首先要在 <code>~/.vimrc</code> 里设置一些简单的配置:</p>
<pre><code>set nocp nu et ts=4 sw=4 sta hls si noeb vb t_vb=
autocmd FileType c nnoremap &lt;buffer&gt; &lt;F5&gt; :!gcc -g -Wall  % &amp;&amp; ./a.out&lt;CR&gt;
</code></pre>
<p>第一行是通用的设置，要使用 VIM 写代码我一般都会先设置它，就一行也很好好记</p>
<ul>
<li><code>nocp</code>: 让 VIM 不在兼容模式下运行</li>
<li><code>nu</code>: 显示行号</li>
<li><code>et</code>: expandtab 的缩写，表示输入 tab 时插入空格</li>
<li><code>ts=4</code>: tabstop 的缩写，输入 tab 插入 4 个空格</li>
<li><code>sw=4</code>: shiftwidth 缩写，用shift+&gt;&gt; 时调整缩进时移动 4 个空格</li>
<li><code>sta</code>: smarttab 的缩写，基于已有行的缩进来确定，在新行的开始位置</li>
<li><code>hls</code>: hlsearch 的缩写，高亮显示搜索的关键字</li>
<li><code>si</code>: smartindent 的缩写，每一行都和前一行有相同的缩进量</li>
<li><code>noeb</code> vb t_vb=: 关闭按错键时的响铃声和屏幕闪烁，否则太烦了</li>
</ul>
<p>第二行是设置当文件是 C 语言文件时，在正常模式下按 F5 键会编译和运行程序，相当于一个快速运行快捷键。</p>
<ul>
<li><code>-g</code> 是开启调试模式，会生成调试符号，出错时的错误信息能看到行号。</li>
<li><code>-Wall</code> 是开启所有警告，以最严格的模式来写代码，养成好的习惯。</li>
</ul>
<p>写一个新的 <code>hello-world.c</code> 再按 F5 试试：</p>
<pre><code>#include &lt;stdio.h&gt;

int main()
{
    printf(&quot;hello world.\n&quot;);
    return 0;
}
</code></pre>
<p>好了，现在我们就可以快乐的写代码了，如果你记不住 VIM 的配置，那可以简化一下：</p>
<pre><code>set nu et ts=4
</code></pre>
<p>然后新开一个窗口进行编译和测试</p>
<pre><code>gcc hello-world.c &amp;&amp; ./a.out
</code></pre>
<p>还有一个小技巧是写 C 代码的时候，有时候需要查看函数的帮助，可以将光标移动到函数上，按 <code>shit+k</code> 查看帮助，按 q 退出，这是 VIM 内置的。</p>
<p>一个好的开发工具往往会事半功倍，自己试一下在自己熟悉的编程工具里如何完成如下任务：</p>
<ul>
<li>跳转到上一次编辑的位置</li>
<li>跳转到一个函数的定义</li>
<li>查找函数的所有引用</li>
<li>跳到匹配括号的开始和结尾</li>
<li>快速注释和取消注释一行或多行</li>
</ul>
<h3 id="单元测试"><a class="header-anchor" href="#单元测试">¶</a>单元测试</h3>
<p>下面我们写一个有意义的程序，把一个路径和一个文件名连接在一起，比如把 <code>/tmp</code> 和 <code>girl.jpg</code> 连接在一起就是 <code>/tmp/girl.jpg</code>。</p>
<p>大家一定听过 TDD 测试驱动，就是写代码之前先写测试，但写测试前得先有测试框架，我们可以使用 CMocka，原因是简单够用，下面是安装过程：</p>
<pre><code>git clone --single-branch --depth 1 https://git.cryptomilk.org/projects/cmocka.git
cd cmocka
mkdir build &amp;&amp; cd build
cmake ..
make -j8
sudo make install
</code></pre>
<p>编写一个 <code>cmocka-test.c</code> 文件，测试下官方例子：</p>
<pre><code>#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdint.h&gt;
#include &lt;cmocka.h&gt;

/* A test case that does nothing and succeeds. */
static void null_test_success(void **state) {
    (void) state; /* unused */
}

int main(void) {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test(null_test_success),
    };

    return cmocka_run_group_tests(tests, NULL, NULL);
}
</code></pre>
<p>这时候按 F5 是无法编译了，大概会看到这样的错误：</p>
<pre><code>/tmp/cc1roVOc.o: In function `main':
cmocka-test.c:(.text+0x6f): undefined reference to `_cmocka_run_group_tests'
collect2: error: ld returned 1 exit status
</code></pre>
<p>这因为我们编译的时候没有链接 <code>cmocka</code> 的库，所以要修改下 <code>~/.vimrc</code> 的配置</p>
<pre><code>autocmd FileType c nnoremap &lt;buffer&gt; &lt;F5&gt; :!gcc -g -Wall %  -lcmocka &amp;&amp; ./a.out&lt;CR&gt;
</code></pre>
<p>这时候按 F5 应该能够看到单元测试的输出，可以看到运行了一个测试，并且通过了。</p>
<pre><code>[==========] tests: Running 1 test(s).
[ RUN      ] null_test_success
[       OK ] null_test_success
[==========] tests: 1 test(s) run.
[  PASSED  ] 1 test(s).
</code></pre>
<p>如果运行程序的时候报如下的错误：</p>
<pre><code>./a.out: error while loading shared libraries: libcmocka.so.0: cannot open shared object file: No such file or directory
</code></pre>
<p>这是因为运行时找不到动态链接库，我们要修改下环境变量来解决，在 shell 里修改 <code>LD_LIBRARY_PATH</code> 并重新用 VIM 打开代码运行：</p>
<pre><code>export LD_LIBRARY_PATH=/usr/local/lib/:$LD_LIBRARY_PATH
</code></pre>
<p>要永久修改共享库查找路径的话可以在 <code>/etc/ld.so.conf</code> 里指定。</p>
<p>好了，单元测试库是可以用了，我们就可以写代码了，写代码之前我们还要先定义接口，就是函数的签名，参数和返回值。<br>
本着接口和实现分离的原则，我们一般会把函数声明放到头文件里，新建一个 <code>join-path.h</code> 文件：</p>
<pre><code>int join_path(char *buf, int buflen, const char *base, const char *file);
</code></pre>
<p>我们做如下约定</p>
<ul>
<li>函数名是 <code>join_path</code></li>
<li><code>buf</code> 是拼接结果的缓冲区</li>
<li><code>buflen</code> 是缓冲区长度，防止拼接后缓冲区溢出</li>
<li><code>base</code> 是目录的路径，如 <code>/tmp</code></li>
<li><code>file</code> 是文件名，如 <code>girl.jpg</code></li>
<li>返回值为 int，0 表示成功，非 0 表示出错，一般 unix 下是这样约定的。</li>
</ul>
<p>新建代码实现文件 <code>join-path.c</code>，先写个空的实现函数，没有实际逻辑：</p>
<pre><code>#include &lt;stdio.h&gt;

int join_path(char *buf, int buflen, const char *base, const char *file) {
    return 0;
}
</code></pre>
<p>新建 <code>join-path-test.c</code> 文件来写测试代码</p>
<pre><code>#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdint.h&gt;
#include &lt;cmocka.h&gt;
#include &quot;join-path.h&quot;
#include &quot;join-path.c&quot;

static void join_test01(void **state) {
    char buf[100];
    int ret = join_path(buf, 100, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
    assert_int_equal(0, ret);
    assert_string_equal(&quot;/tmp/girl.jpg&quot;, buf);
}

int main(void) {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test(join_test01),
    };

    return cmocka_run_group_tests(tests, NULL, NULL);
}
</code></pre>
<p>大部分代码和 CMocka 的实例代码是一样的，不同的地方是：</p>
<ul>
<li>include 了被测代码的头文件和实现文件，因为我们是测试自己的代码，可以直接引入源码文件，这样 F5 就可以看到测试结果, 不需要修改链接选项。</li>
<li>定义了一个 join_test01 的函数，相当于第一个测试用例：
<ul>
<li>定义一个长度 为 100 个 buffer；</li>
<li>调用 join_path 函数；</li>
<li>断言函数返回 0；</li>
<li>断言缓冲区为预期的结果 <code>/tmp/girl.jpg</code>。</li>
</ul>
</li>
<li>在 main 函数里执行上面定义的测试。</li>
</ul>
<p>好了，接口声明，代码实现和第一个单元测试都有了，我们 F5 来运行测试，预期会失败，但我们后面再让他成功。</p>
<pre><code>[==========] tests: Running 1 test(s).
[ RUN      ] join_test01
111
[  ERROR   ] --- &quot;/tmp/girl.jpg&quot; != &quot;&quot;
[   LINE   ] --- join-path-test.c:13: error: Failure!
[  FAILED  ] join_test01
[==========] tests: 1 test(s) run.
[  PASSED  ] 0 test(s).
[  FAILED  ] tests: 1 test(s), listed below:
[  FAILED  ] join_test01

 1 FAILED TEST(S)
</code></pre>
<p>在 VIM 同时打开多个文件的话，可以按 <code>:bn</code> 和 <code>:bp</code> 进行切换，比如我们就打开了 3 个文件：<code>join-path.h</code>，<code>join-path.c</code> 和 <code>join-path-test.c</code>。</p>
<p>我们要对单元测试进行更多的熟悉，尝试做如下任务：</p>
<ul>
<li>了解更多的断言，如断言数组中包含指定元素；</li>
<li>在每个单元测试前面进行准备工作，后面做资源回收工作；</li>
<li>对被测函数依赖的函数进行 mock；</li>
<li>断言某个函数以指定的参数被调用；</li>
<li>临时屏蔽某个测试用例；</li>
<li>评估被测代码的测试覆盖率；</li>
</ul>
<h3 id="代码实现"><a class="header-anchor" href="#代码实现">¶</a>代码实现</h3>
<p>终于可以正式的开始写代码实现了，第一个可以想到的就是用 <code>snprintf</code> 函数实现：</p>
<pre><code>int join_path(char *buf, int buflen, const char *base, const char *file) {
    snprintf(buf, buflen, &quot;%s/%s&quot;, base, file);
    return 0;
}
</code></pre>
<p>F5 运行测试</p>
<pre><code>[==========] tests: Running 1 test(s).
[ RUN      ] join_test01
[       OK ] join_test01
[==========] tests: 1 test(s) run.
[  PASSED  ] 1 test(s).
</code></pre>
<p>妥了，测试通过了，喝杯咖啡奖励一下自己。接着做更多的测试，写第 2 个用例，并在 main 函数里增加一行以便测试它：</p>
<pre><code>static void join_test02(void **state) {
    char buf[3];
    int ret = join_path(buf, 3, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
    assert_int_equal(0, ret);
    assert_string_equal(&quot;/tmp/girl.jpg&quot;, buf);
}

int main(void) {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test(join_test01),
        cmocka_unit_test(join_test02),
    };

    return cmocka_run_group_tests(tests, NULL, NULL);
}
</code></pre>
<p>F5 测试，发现这次用例失败了：</p>
<pre><code>[==========] tests: Running 2 test(s).
[ RUN      ] join_test01
[       OK ] join_test01
[ RUN      ] join_test02
[  ERROR   ] --- &quot;/tmp/girl.jpg&quot; != &quot;/t&quot;
[   LINE   ] --- join-path-test.c:20: error: Failure!
[  FAILED  ] join_test02
[==========] tests: 2 test(s) run.
[  PASSED  ] 1 test(s).
[  FAILED  ] tests: 1 test(s), listed below:
[  FAILED  ] join_test02

 1 FAILED TEST(S)
</code></pre>
<p>因为这次的缓冲区长度我们故意给了 3 个，根本放不下拼接后的结果，所以我们预期这时候返回值不应该为 0 ，我们修改下测试用例:</p>
<pre><code>static void join_test02(void **state) {
    char buf[3];
    int ret = join_path(buf, 3, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
    assert_int_not_equal(0, ret);
}
</code></pre>
<p>这时候运行测试肯定还是失败，我们的主要工作流程就是：</p>
<ul>
<li>编写新的单元测试，默认执行会失败</li>
<li>修改代码，让失败的单元测试成功</li>
</ul>
<p>上面的用例失败，说明我们没有对参数做严格的检查，我们来完完善它：</p>
<pre><code>#include &lt;string.h&gt;

int join_path(char *buf, int buflen, const char *base, const char *file) {
    if (strlen(base)+strlen(file)+1+1&gt;buflen) return -1;
    snprintf(buf, buflen, &quot;%s/%s&quot;, base, file);
    return 0;
}
</code></pre>
<p>我们在 base 加上 file 再加上路径连接符 <code>/</code> 再加上 C 语言字符串终止符 <code>0</code> 的长度大于缓冲区长度时返回 -1。F5 测试：</p>
<pre><code>[==========] tests: Running 2 test(s).
[ RUN      ] join_test01
[       OK ] join_test01
[ RUN      ] join_test02
[       OK ] join_test02
[==========] tests: 2 test(s) run.
[  PASSED  ] 2 test(s).
</code></pre>
<p>妥了， 2 个测试用例成功了，但我们不能靠假设编程，每个参数都会有各种可能的值传进来，还有别的边界条件要测吗？想一想：</p>
<ul>
<li>如果参数 buf, base, file 有一个是 NULL 程序能否正常运行，应如何修复。</li>
<li>如果参数 buflen 是负数，程序能否正常运行，应如何修复。</li>
<li>如果参数 base 或 file 不是一个以 <code>\0</code> 结尾的字符串，会发生什么，应如何修复。</li>
<li>如何缓冲区的大小并没有 buflen 那么长，会发生什么，我们能修复吗？</li>
</ul>
<h3 id="代码调试"><a class="header-anchor" href="#代码调试">¶</a>代码调试</h3>
<p>写 C 程序最常遇到的错误是什么？那肯定是内存错误，因为 C 语言里内存都要手动管理，各种数组也没有越界检查，一不小心就会出现内存错误。</p>
<p>我们新建 <code>join-path-debug.c</code> 来学习如何调试代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;join-path.c&quot;
int main()
{
    char buf[3];
    join_path(buf, 100, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
    return 0;
}
</code></pre>
<p>手工编译并运行，直接报错了，类型是调用栈错误，也是一种典型的内存错误，其它常见的还有段错误等。</p>
<pre><code>$ gcc join-path-debug.c
$ ./a.out
*** stack smashing detected ***: &lt;unknown&gt; terminated
Aborted (core dumped)
</code></pre>
<p>如果我们的代码量很大，执行程序异常崩溃，我们如何定位原因呢？这就得用到 gdb 调试工具了。首先编译时要加 -g 参数</p>
<pre><code>gcc -g join-path-debug.c
</code></pre>
<p>然后用 gdb 来运行它：</p>
<pre><code>$ gdb ./a.out
GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1
Reading symbols from ./a.out...done.
</code></pre>
<p>输入 r 会运行程序，这里会看到遇到了内存错误，程序被终止了。</p>
<pre><code>(gdb) r
Starting program: a.out
*** stack smashing detected ***: &lt;unknown&gt; terminated

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
51      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
</code></pre>
<p>输入 bt 可以查看线程调用栈, 程序是被 libc 的栈检查机制终止的，最顶层的栈帧是 join-path-debug.c 的第 8 行 main 函数里引起的错误</p>
<pre><code>(gdb) bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
#1  0x00007ffff7a227f1 in __GI_abort () at abort.c:79
#2  0x00007ffff7a6b837 in __libc_message (entry=do_abort, fmt=fmt@entry=0x7ffff7b98869 &quot;*** %s ***: %s terminated\n&quot;) at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007ffff7b16b31 in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false, msg=msg@entry=0x7ffff7b98847 &quot;stack smashing detected&quot;) at fortify_fail.c:33
#4  0x00007ffff7b16af2 in __stack_chk_fail () at stack_chk_fail.c:29
#5  0x00005555555547cc in main () at join-path-debug.c:8
</code></pre>
<p>用 <code>f 5</code> 切换栈帧，并用 <code>l</code> 查看附近的代码</p>
<pre><code>(gdb) f 5
#5  0x00005555555547cc in main () at join-path-debug.c:8
8       }
(gdb) l
3       int main()
4       {
5           char buf[3];
6           join_path(buf, 100, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
7           return 0;
8       }
</code></pre>
<p>我们发现第 8 行代码并没有实际代码执行，怎么会出错呢，这其实是正常的。C 程序遇到的好多错误就是这样，出错的地点和引起错误的地点有可能离的很远，因为引起内存错误的代码可能执行了很久，才会被其它的代码使用这块内存的时候发现。</p>
<p>现在我们看到的例子是个特例，因为在第 8 行往上看一下就能找到问题：代码定义的缓冲区长度只有 3， 但给 join_path 传入的 buflen 参数是 100，所以 join_path 的参数检查并没有失败，这时候运行就会报错了。</p>
<p>那我们还有没有更可靠的方法来定位这种错误呢？有，那就是用 Address Sanitizer（Asan），这个工具已经集成到 gcc 里了，我们直接加几个参数就可以使用：</p>
<pre><code>$ gcc -g -Wall -fsanitize=address -fno-omit-frame-pointer join-path-debug.c
$ ./a.out
=================================================================
==13565==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff97c3b743 at pc 0x7fb8cbce4f09 bp 0x7fff97c3b5d0 sp 0x7fff97c3ad60
WRITE of size 14 at 0x7fff97c3b743 thread T0
    #0 0x7fb8cbce4f08 in __interceptor_vsnprintf (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xa0f08)
    #1 0x7fb8cbce5286 in snprintf (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xa1286)
    #2 0x55bb3a82cb80 in join_path join-path.c:6
    #3 0x55bb3a82cc2c in main join-path-debug.c:6
    #4 0x7fb8cb874c86 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21c86)
    #5 0x55bb3a82ca29 in _start (a.out+0xa29)

Address 0x7fff97c3b743 is located in stack of thread T0 at offset 35 in frame
    #0 0x55bb3a82cb9c in main join-path-debug.c:4

  This frame has 1 object(s):
    [32, 35) 'buf' &lt;== Memory access at offset 35 overflows this variable
</code></pre>
<p>这次妥了，直接定位到 join-path.c 的第 6 行触发了栈溢出，而且还显示这块内存是在 join-path-debug.c 的第4 行在栈上分配的，有了这些信息候再结合代码和调用栈就很容易定位错误了。</p>
<p>如果还是没有定位到错误，因为一些运行时的信息不确定，那可以继续用 gdb 来调试，去掉 asan 编译选项重新编译程序并用 gdb 启动</p>
<pre><code>$ gcc -g -Wall join-path-debug.c
$ gdb ./a.out
</code></pre>
<p>根据 asan 的信息，在 join-path.c 的第 6 行增加断点：</p>
<pre><code>(gdb) b join-path.c:6
Breakpoint 1 at 0x745: file join-path.c, line 6.
</code></pre>
<p>运行程序，可以看到在断点处停住了，可以很清楚的看到各个参数的值：</p>
<pre><code>(gdb) r
Starting program: a.out

Breakpoint 1, join_path (buf=0x7fffffffe385 &quot;\177&quot;, buflen=100, base=0x555555554863 &quot;/tmp&quot;,
    file=0x55555555485a &quot;girl.jpg&quot;) at join-path.c:6
6           snprintf(buf, buflen, &quot;%s/%s&quot;, base, file);
</code></pre>
<p>也可以用 p 命令查看具体某个变量的值</p>
<pre><code>(gdb) p base
$1 = 0x555555554863 &quot;/tmp&quot;
(gdb) p buflen
$2 = 100
(gdb) p file
$3 = 0x55555555485a &quot;girl.jpg&quot;
(gdb) p buf
$4 = 0x7fffffffe385 &quot;\177&quot;
</code></pre>
<p>这里看到 buflen 为 100，我们尝试跳到上一层堆栈找找有没有 buf 分配的代码：</p>
<pre><code>(gdb) bt
#0  join_path (buf=0x7fffffffe385 &quot;\177&quot;, buflen=100, base=0x555555554863 &quot;/tmp&quot;, file=0x55555555485a &quot;girl.jpg&quot;)
    at join-path.c:6
#1  0x00005555555547b3 in main () at join-path-debug.c:6
(gdb) f 1
#1  0x00005555555547b3 in main () at join-path-debug.c:6
6           join_path(buf, 100, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
(gdb) l
1       #include &lt;stdio.h&gt;
2       #include &quot;join-path.c&quot;
3       int main()
4       {
5           char buf[3];
6           join_path(buf, 100, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
7           return 0;
8       }
</code></pre>
<p>这里定位到 join-path-debug.c 的第 5 行定义 buf 只有 3 个的长度，找到了问题的原因。</p>
<p>假如说是一个正在运行的进程突然崩溃了，我们如何来定位原因呢？这时候就要调试 core dump文件了，首先在服务器上要做一些设置允许程序崩溃是产生 dump 文件。</p>
<pre><code>sudo mkdir -p /data/coredump/
sudo chmod o+w /data/coredump
sudo bash -c 'echo /data/coredump/core.%e.%p&gt; /proc/sys/kernel/core_pattern'
ulimit -c unlimited
</code></pre>
<p>上面代码是让 core dump 文件保存在 <code>/data/coredump</code> 下，并且 dump 文件名称包含程序名称和进程 ID，然后设置 dump 文件大小为无限制。</p>
<p>直接运行代码，就会产生 core dump 了。</p>
<pre><code>$ ./a.out
*** stack smashing detected ***: &lt;unknown&gt; terminated
Aborted (core dumped)
$ ls /data/coredump/
core.a.out.14375
</code></pre>
<p>拿到 dump 文件后需要有原始的文件才能进行调试，先启动 gdb:</p>
<pre><code>$ gdb ./a.out
GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1
Reading symbols from ./a.out...done.
</code></pre>
<p>然后用 core-file 指令加载 core dump:</p>
<pre><code>(gdb) core-file /data/coredump/core.a.out.14375
[New LWP 14375]
Core was generated by `./a.out'.
Program terminated with signal SIGABRT, Aborted.
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
51      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
</code></pre>
<p>查看调用栈</p>
<pre><code>(gdb) bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
#1  0x00007fadd6b0f7f1 in __GI_abort () at abort.c:79
#2  0x00007fadd6b58837 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7fadd6c85869 &quot;*** %s ***: %s terminated\n&quot;) at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007fadd6c03b31 in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false, msg=msg@entry=0x7fadd6c85847 &quot;stack smashing detected&quot;) at fortify_fail.c:33
#4  0x00007fadd6c03af2 in __stack_chk_fail () at stack_chk_fail.c:29
#5  0x000055df3b1a47cc in main () at join-path-debug.c:8
</code></pre>
<p>live debug 能单步调试，设置断点等，但调试 core dump 基本上就是看一下调用栈，这是最重要的信息，一般也能够提供足够的线索来定位问题。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/09/01/202209/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          202209
        
      </div>
    </a>
  
  
    <a href="/2022/08/03/202208/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">202208</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>








</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2024 onlytiancai
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="//cdnjs.cloudflare.com/ajax/libs/require.js/2.1.6/require.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>