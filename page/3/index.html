<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>蛙蛙池塘</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="蛙蛙池塘">
<meta property="og:url" content="http://blog.ihuhao.com/page/3/index.html">
<meta property="og:site_name" content="蛙蛙池塘">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蛙蛙池塘">
  
    <link rel="alternative" href="/atom.xml" title="蛙蛙池塘" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/avatar.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">onlytiancai</a></h1>
		</hgroup>

		
		<p class="header-subtitle">欢迎来到蛙蛙池塘</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/onlytiancai" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/onlytiancai" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="mailto:onlytiancai@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/centos/" style="font-size: 10px;">centos</a> <a href="/tags/cmder/" style="font-size: 10px;">cmder</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/putty/" style="font-size: 10px;">putty</a> <a href="/tags/vagrant/" style="font-size: 10px;">vagrant</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/主机迁移/" style="font-size: 10px;">主机迁移</a> <a href="/tags/监控/" style="font-size: 10px;">监控</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.dnspod.cn/">DNSPod</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.qcloud.com/">腾讯云</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">碧云天，黄花地，西风紧。北雁南飞。晓来谁染霜林醉？总是离人泪。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">onlytiancai</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">onlytiancai</h1>
			</hgroup>
			
			<p class="header-subtitle">欢迎来到蛙蛙池塘</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/onlytiancai" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/onlytiancai" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="mailto:onlytiancai@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-202212" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/12/02/202212/" class="article-date">
  	<time datetime="2022-12-02T02:00:45.000Z" itemprop="datePublished">2022-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/02/202212/">202212</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <img src="https://blog-1251103437.cos.ap-beijing.myqcloud.com/202212021801082.jpg" width="500"> 
## windows
<p>powershell 提示没权限，先用管理员模式启动</p>
<pre><code>set-ExecutionPolicy RemoteSigned
</code></pre>
<h2 id="linux-5"><a class="header-anchor" href="#linux-5">¶</a>linux</h2>
<p>无法用 key ssh 到远程主机</p>
<pre><code>journalctl -fu ssh
    userauth_pubkey: key type ssh-rsa not in PubkeyAcceptedAlgorithms [preauth]

vi /etc/ssh/sshd_config.
    PubkeyAcceptedAlgorithms=+ssh-rsa

sudo systemctl restart sshd
</code></pre>
<p>LVM</p>
<p>pv lv vg 介绍</p>
<ul>
<li>PV(physical volume) 即物理卷，就是物理磁盘,可以通过 fdisk -l 查看操作系统有几块硬盘</li>
<li>VG(volume group) 即卷组,就是一组物理磁盘的组合，里面可以有一块硬盘也可以有多块硬盘</li>
<li>LV(logical volume)及逻辑卷，就是在 VG (指定的物理磁盘组)里面划分出来的</li>
<li>可以说成是 PV 就是硬盘，而 VG 就是管理硬盘的操作系统，而 LV 就是操作系统分出来的各个分区.</li>
<li>PV-&gt;VG-&gt;LV-&gt; 文件系统使用(挂载到某个目录)</li>
<li>硬盘或分区做成 pv，然后将 pv 或多个 pv 建立 vg，vg 上建立 lv</li>
</ul>
<p>git 配置</p>
<pre><code>git config --global http.proxy http://127.0.0.1:10800
git config --global https.proxy https://127.0.0.1:10800

git config --global --unset http.proxy
git config --global --unset https.proxy

git config --global url.&quot;https://&quot;.insteadOf git://

git config --list --show-origin
</code></pre>
<p>fio 磁盘性能测试工具<br>
<a href="https://www.cnblogs.com/lyhabc/p/16708771.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyhabc/p/16708771.html</a></p>
<p>dd 命令来测试性能，有如下问题：</p>
<ul>
<li>dd 命令的 IO 模型单一，只能测试顺序 IO，不能测试随机 IO。</li>
<li>dd 命令可设置的参数较少，并且测试结果不一定能反映出磁盘的真实性能。</li>
<li>dd 命令的设计初衷就不是用例测试性能的，在 dd 的手册中可以看到。</li>
<li>无法设置队列深度，因此不推荐用 dd 命令来测试最大读 IOPS。</li>
</ul>
<p>fio 测试模板</p>
<pre><code>#read 顺序读 吞吐量
fio -ioengine=libaio -direct=1 -bs=4k -thread -rw=read -size=10G -nrfiles=1 -filename=fio_readputth_test.txt -name='fio read test' -iodepth=2 -runtime=120 -numjobs=4 -time_based=1 -allow_mounted_write=1 -group_reporting

#write 顺序写 吞吐量
fio -ioengine=libaio -direct=1 -bs=4k -thread -rw=write -size=10G -nrfiles=1 -filename=fio_writeputth_test.txt -name='fio write test' -iodepth=2 -runtime=120 -numjobs=4 -time_based=1 -allow_mounted_write=1 -group_reporting


#read 顺序读
fio -ioengine=libaio -direct=1 -bs=4k -thread -rw=read -size=2G -nrfiles=1 -filename=fio_read_test.txt -name='fio read test' -iodepth=4 -runtime=60 -numjobs=8 -time_based=1 -allow_mounted_write=1 -group_reporting

#write 顺序写
fio -ioengine=libaio -direct=1 -bs=4k -thread -rw=write -size=2G -nrfiles=1 -filename=fio_write_test.txt -name='fio write test' -iodepth=4 -runtime=60 -numjobs=8 -time_based=1 -allow_mounted_write=1 -group_reporting

#readwrite 顺序混合读写
fio -ioengine=libaio -direct=1 -bs=4k -thread -rw=readwrite -size=2G -nrfiles=1 -filename=fio_readwrite_test.txt -name='fio readwrite test' -iodepth=4 -runtime=60 -numjobs=8 -time_based=1 -allow_mounted_write=1 -group_reporting

#randread 随机读
fio -ioengine=libaio -direct=1 -bs=4k -thread -rw=randread -size=2G -nrfiles=1 -filename=fio_randread_test.txt -name='fio randread test' -iodepth=4 -runtime=60 -numjobs=8 -time_based=1 -allow_mounted_write=1 -group_reporting

#randwrite 随机写
fio -ioengine=libaio -direct=1 -bs=4k -thread -rw=randwrite -size=2G -nrfiles=1 -filename=fio_randwrite_test.txt -name='fio randwrite test' -iodepth=4 -runtime=60 -numjobs=8 -time_based=1 -allow_mounted_write=1 -group_reporting

#randrw 随机混合读写
fio -ioengine=libaio -direct=1 -bs=4k -thread -rw=randrw -size=2G -nrfiles=1 -filename=fio_randrw_test.txt -name='fio randrw test' -iodepth=4 -runtime=60 -numjobs=8 -time_based=1 -allow_mounted_write=1 -group_reporting
</code></pre>
<p>，对于小块io（以64k为界）只需要关注iops，平均时延（lat中的avg），大块io关注吞吐和平均时延（lat中的avg）即可</p>
<h2 id="java-2"><a class="header-anchor" href="#java-2">¶</a>java</h2>
<p>大白话讲解Spring的@bean注解<br>
<a href="https://zhuanlan.zhihu.com/p/99870991" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/99870991</a></p>
<p>从广义上Spring注解可以分为两类：</p>
<ul>
<li>一类注解是用于注册 Bean，比如 @Component , @Repository , @ Controller , @Service , @Configration 这些注解就是用于注册 Bean，放进 IOC 容器中。</li>
<li>一类注解是用于使用 Bean，比如 @Autowired , @Resource 注解，这些注解就是把屋子里的东西自己拿来用，如果你要拿，前提一定是屋子（IOC）里有的，不然就会报错。</li>
</ul>
<p>Bean 注解</p>
<ul>
<li>Spring 的 @Bean 注解用于告诉方法，产生一个 Bean 对象，然后这个 Bean 对象交给 Spring 管理。
<ul>
<li>产生这个 Bean 对象的方法 Spring 只会调用一次，随后这个 Spring 将会将这个 Bean 对象放在自己的 IOC 容器中。</li>
</ul>
</li>
<li>@Component , @Repository , @Controller , @Service 这些注解只局限于自己编写的类，
<ul>
<li>而 @Bean 注解能把第三方库中的类实例加入 IOC 容器中并交给 spring 管理。</li>
</ul>
</li>
<li>@Bean 注解的另一个好处就是能够动态获取一个 Bean 对象，能够根据环境不同得到不同的 Bean 对象。</li>
</ul>
<p>Java随机生成RSA密钥对<br>
<a href="https://blog.csdn.net/msq16021/article/details/123743361" target="_blank" rel="noopener">https://blog.csdn.net/msq16021/article/details/123743361</a></p>
<p>SpringBoot Security 自定义登录页面<br>
<a href="https://blog.csdn.net/weixin_42555971/article/details/127440094" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42555971/article/details/127440094</a></p>
<p>基于数据库自定义UserDetailsService实现JWT认证<br>
<a href="https://blog.csdn.net/lazy_LYF/article/details/127284982" target="_blank" rel="noopener">https://blog.csdn.net/lazy_LYF/article/details/127284982</a></p>
<p>单点登录SSO，JWT进行跨域身份验证，前端登录实现Coding在线（十一）<br>
<a href="https://blog.csdn.net/wang121213145/article/details/123553741" target="_blank" rel="noopener">https://blog.csdn.net/wang121213145/article/details/123553741</a></p>
<p>SpringSecurity以及Oauth2（笔记）<br>
<a href="https://blog.csdn.net/weixin_46949627/article/details/126698801" target="_blank" rel="noopener">https://blog.csdn.net/weixin_46949627/article/details/126698801</a></p>
<p>Spring MVC中redirect重定向3种方式（带参数）<br>
<a href="https://blog.csdn.net/weixin_39973810/article/details/84847922" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39973810/article/details/84847922</a></p>
<h2 id="javascript-2"><a class="header-anchor" href="#javascript-2">¶</a>javascript</h2>
<p>npm install 报错</p>
<ul>
<li>git 挂代理：git config --global http.proxy <a href="http://127.0.0.1:10800" target="_blank" rel="noopener">http://127.0.0.1:10800</a></li>
<li>git 默认使用 http：git config --global url.“https://”.insteadOf git://</li>
<li>node-scss匹配的最高版本才nodjs 14，不能要最新版本的 nodejs</li>
<li>跟linux还是windows没啥关系，linux也不行</li>
</ul>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<p><a href="https://v2ex.com/t/901954" target="_blank" rel="noopener">https://v2ex.com/t/901954</a> 你们的 NAS 部署了什么有趣的服务?</p>
<ul>
<li>网盘：seafile，坚果云, dufs,filebrowser,baidunetdisk,timemachine，icloudpd，filebrowser</li>
<li>文件同步：syncthing/nextcloud，etesync，icloudpd，samba</li>
<li>照片：mt-photos，PhotoPrism，photoview</li>
<li>内网穿透：cloudflared,frpc,tailscale</li>
<li>内网组网：tailscale</li>
<li>梯子：openclash,stashapp,subconverter，v2ray</li>
<li>统一登录：authelia</li>
<li>下载：aria2,aria2pro,qbittorrent</li>
<li>搜索引擎：whoogle/searxng</li>
<li>容器管理：portainer/watchtower</li>
<li>密码管理：vaultwarden</li>
<li>反代网关：traefik</li>
<li>git 仓库：gitea，Gogs</li>
<li>网盘文件目录：alist</li>
<li>DNS：adguard-home，Adguard home DNS</li>
<li>笔记博客：mastodon，outline,b3log/siyuan</li>
<li>网站监控：uptime-kuma</li>
<li>RSS: rsshub,freshrss,ttrss</li>
<li>智能家居：Home Assistant，doods2</li>
<li>音视频：Jellyfin</li>
<li>聊天：Snikket</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-笔记软件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/11/18/笔记软件/" class="article-date">
  	<time datetime="2022-11-18T02:54:53.000Z" itemprop="datePublished">2022-11-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/18/笔记软件/">笔记软件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="需求"><a class="header-anchor" href="#需求">¶</a>需求</h2>
<p>做一个单机不联网的笔记软件，能够</p>
<ul>
<li>编辑 markdown 文件</li>
<li>编辑 excel, csv 文件</li>
<li>编辑 word 文件</li>
<li>画脑图</li>
<li>画原型图</li>
<li>画流程图</li>
<li>画架构图</li>
<li>画 uml 图</li>
<li>画 ER 图</li>
<li>涂鸦</li>
</ul>
<h2 id="开源组件"><a class="header-anchor" href="#开源组件">¶</a>开源组件</h2>
<ul>
<li><a href="https://sheetjs.com/" target="_blank" rel="noopener">https://sheetjs.com/</a></li>
<li><a href="https://github.com/jgraph/drawio" target="_blank" rel="noopener">https://github.com/jgraph/drawio</a></li>
<li><a href="https://resources.jointjs.com/demos/javascript-ast" target="_blank" rel="noopener">https://resources.jointjs.com/demos/javascript-ast</a></li>
<li><a href="https://modeling-languages.com/javascript-drawing-libraries-diagrams/" target="_blank" rel="noopener">https://modeling-languages.com/javascript-drawing-libraries-diagrams/</a></li>
<li><a href="https://modeling-languages.com/text-uml-tools-complete-list/" target="_blank" rel="noopener">https://modeling-languages.com/text-uml-tools-complete-list/</a></li>
<li><a href="https://github.com/ssshooter/mind-elixir-core/blob/master/readme.cn.md" target="_blank" rel="noopener">https://github.com/ssshooter/mind-elixir-core/blob/master/readme.cn.md</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-202211" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/11/01/202211/" class="article-date">
  	<time datetime="2022-11-01T06:45:48.000Z" itemprop="datePublished">2022-11-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/01/202211/">202211</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <img src="https://blog-1251103437.cos.ap-beijing.myqcloud.com/202211011546026.png" width="800"> 
<h2 id="linux-3"><a class="header-anchor" href="#linux-3">¶</a>linux</h2>
<p>手把手教你使用VSCode进行linux内核代码阅读和开发<br>
<a href="https://zhuanlan.zhihu.com/p/558286384" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/558286384</a></p>
<p>指定ssh key 克隆代码</p>
<pre><code>git clone git@provider.com:userName/projectName.git --config core.sshCommand=&quot;ssh -i ~/location/to/private_ssh_key&quot;
</code></pre>
<h3 id="vscode-阅读内核源码配置"><a class="header-anchor" href="#vscode-阅读内核源码配置">¶</a>vscode 阅读内核源码配置</h3>
<p>对比</p>
<ul>
<li>source insight ，因为内核下有多个平台的头文件、源码，<br>
往往能找到很多个同名函数或变量的定义，还得一个一个去确认，非常麻烦。</li>
<li>vscode 加上 C++ Intellisense 插件或者 global 插件，类似source insight，<br>
需要手动排除未编译文件减小索引范围，代码定位不准。</li>
<li>文本浏览工具和 grep 进行代码搜索浏览，这种方法最简单，效率也最低。</li>
<li>使用 vim + ctags，比较高大上，但我觉得vim里打开很多文件不太方便，不太适合阅读大工程的代码。</li>
<li>vscode + remote ssh + clangd，clangd 插件用于代码语义分析、代码补全、跳转等。<br>
该方案克服了上面列举的几种方案的几乎各种缺点，能做到代码精准跳转、精准自动补全，</li>
</ul>
<p>总体流程:</p>
<ul>
<li>安装 vscode</li>
<li>安装 Remote SSH</li>
<li>连接到远程 linux</li>
<li>远程安装 clangd server</li>
<li>本地安装 clange 插件</li>
<li>配置 clangd 插件</li>
<li>linux 相关操作</li>
<li>打开远程 linux 内核目录，等待 clangd 索引完毕</li>
<li>ctrl+t 查找符号，f12 查找定义，shift+alt+f12 查找引用，alt+箭头 编辑点跳转</li>
</ul>
<p>clangd 插件配置</p>
<pre><code>--compile-commands-dir=${workspaceFolder}
--background-index
--completion-style=detailed
--header-insertion=never
-log=info
</code></pre>
<p>linux 相关操作:</p>
<pre><code># 如果 vscode 远程无法安装 clang server，则手工安装
wget https://gitee.com/zhengqijun/clangd/releases/download/15.0.3/clangd-linux-15.0.3.zip

# 安装 bear，生成 compile_commands.json
sudo apt install bear
bear make bzImage ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-

# 如果上面生成的 json 文件无效，再尝试下面的脚本
./scripts/gen_compile_commands.py
</code></pre>
<p>了解linux内核必读的五本书<br>
<a href="https://zhuanlan.zhihu.com/p/359049747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/359049747</a></p>
<ul>
<li>《Linux内核设计与实现》 简称 LKD，内容比较浅显易懂，个人认为是内核新人首先必读的书籍。</li>
<li>《深入理解Linux内核》简称 ULK，相比于LKD的内容不够深入、覆盖面不广，ULK要深入全面得多。</li>
<li>《Linux设备驱动程序》简称 LDD，驱动开发者都要人手一本了。</li>
<li>《深入理解Linux虚拟内存管理》简称 LVMM，介绍Linux虚拟内存管理机制。</li>
<li>《深入理解LINUX网络内幕》，讲解网络子系统实现的书。</li>
</ul>
<p>pip3 报错</p>
<pre><code>AttributeError: module 'lib' has no attribute 'X509_V_FLAG_CB_ISSUER_CHECK'
</code></pre>
<p>解决</p>
<pre><code>apt remove python3-openssl -y 
apt autoremove
</code></pre>
<p>linux 命令示例速查<br>
<a href="https://github.com/cheat/cheat" target="_blank" rel="noopener">https://github.com/cheat/cheat</a><br>
<a href="https://mp.weixin.qq.com/s/CEOU9LDSKU05uJSvgLSMZg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CEOU9LDSKU05uJSvgLSMZg</a></p>
<p>查看两个时间点之间的日志</p>
<pre><code>sed -n '/2022-11-01T16:52:40/,/2022-11-01T16:52:42/p' /var/log/nginx/access.log | more
</code></pre>
<p>Linux sed命令完全攻略（超级详细）<br>
<a href="http://c.biancheng.net/view/4028.html" target="_blank" rel="noopener">http://c.biancheng.net/view/4028.html</a></p>
<p>mmap的几种使用场景<br>
<a href="https://www.cnblogs.com/Arnold-Zhang/p/15686868.html" target="_blank" rel="noopener">https://www.cnblogs.com/Arnold-Zhang/p/15686868.html</a><br>
<a href="https://izualzhy.cn/mmap" target="_blank" rel="noopener">https://izualzhy.cn/mmap</a></p>
<h3 id="mysql-4"><a class="header-anchor" href="#mysql-4">¶</a>mysql</h3>
<p>JSON_TABLE - The Best of Both Worlds<br>
<a href="https://dev.mysql.com/blog-archive/json_table-the-best-of-both-worlds/" target="_blank" rel="noopener">https://dev.mysql.com/blog-archive/json_table-the-best-of-both-worlds/</a></p>
<p>查看长语句进度<br>
<a href="https://www.lanmper.cn/mysql/t8551" target="_blank" rel="noopener">https://www.lanmper.cn/mysql/t8551</a></p>
<pre><code>select SQL_TEXT,ROWS_EXAMINED,ROWS_AFFECTED,ROWS_SENT, TIMER_WAIT/(1000*1000*1000) wait_ms, LOCK_TIME/(1000*1000*1000)
</code></pre>
<p>lock_ms from performance_schema.events_statements_current where SQL_TEXT is not null and  TIMER_WAIT/(1000<em>1000</em>1000) &gt; 100 order by TIMER_WAIT desc\G</p>
<ul>
<li>TIMER_WAIT 事件经过的时间（持续时间），单位是皮秒（万亿分之一秒）</li>
<li>LOCK_TIME 等待表锁所花费的时间，该值以微秒为单位计算，但归一化为皮秒，以便与其他性能模式计时器进行比较。</li>
<li>ROWS_AFFECTED 语句影响的行数。</li>
<li>ROWS_SENT 语句返回的行数。</li>
<li>ROWS_EXAMINED 服务器层检查的行数（不计算存储引擎内部的任何处理）。</li>
</ul>
<p>How to create index on json column in MySQL?<br>
<a href="https://stackoverflow.com/questions/38389075/how-to-create-index-on-json-column-in-mysql" target="_blank" rel="noopener">https://stackoverflow.com/questions/38389075/how-to-create-index-on-json-column-in-mysql</a></p>
<pre><code>CREATE TABLE inventory(
items JSON,
INDEX i1 ( (JSON_VALUE(items, '$.name' RETURNING CHAR(50))) ),
INDEX i2 ( (JSON_VALUE(items, '$.price' RETURNING DECIMAL(5,2))) ),
INDEX i3 ( (JSON_VALUE(items, '$.quantity' RETURNING UNSIGNED)) )
);

SELECT items-&gt;&quot;$.price&quot; FROM inventory
WHERE JSON_VALUE(items, '$.name' RETURNING VARCHAR(50)) = &quot;hat&quot;;

SELECT * FROM inventory
WHERE JSON_VALUE(items, '$.price' RETURNING DECIMAL(5,2)) &lt;= 100.01;

SELECT items-&gt;&quot;$.name&quot; AS item, items-&gt;&quot;$.price&quot; AS amount
FROM inventory
WHERE JSON_VALUE(items, '$.quantity' RETURNING UNSIGNED) &gt; 500;
</code></pre>
<h2 id="postgre"><a class="header-anchor" href="#postgre">¶</a>postgre</h2>
<p>内核 IO 参数<br>
sysctl -a |grep vm.dirty_background_ratio</p>
<p>推荐配置</p>
<pre><code>40 core, 80 thread @ 2.2Ghz
256GB RAM
16TB NVMe storage (RAID10 usable ~8TB), 28GB/s sequential read, 26GB/s sequential write, 4.9M random read IO/s, 4.4M random write IO/s
</code></pre>
<p>可视化执行计划</p>
<pre><code>https://tatiyants.com/pev/#/plans
</code></pre>
<p>kill sql</p>
<pre><code># only select
SELECT pg_cancel_backend(PID);

# can be update, delete
SELECT pg_terminate_backend(PID);
</code></pre>
<p>show processlist</p>
<pre><code>SELECT pid, datname AS db, query_start AS start, now() - query_start AS lap, query 
FROM pg_stat_activity 
WHERE state &lt;&gt; 'idle' and query not like '%pg_stat_activity%'  
and (now() - query_start) &gt; interval '1 seconds';
</code></pre>
<h2 id="理财"><a class="header-anchor" href="#理财">¶</a>理财</h2>
<p>日内做多策略</p>
<ul>
<li>看 5 分钟级别 K 线</li>
<li>低开，不做</li>
<li>开盘第一条 K 线长上影线，中性，等待，观察第二根 K 线</li>
<li>开盘光头大阳线，做多信号 +1</li>
<li>前一日下午盘在均线上方运行，尾盘稳定，做多信号 +1</li>
<li>前一日高波动震荡，做多信号 -1</li>
<li>开仓后做动态止损，随着价格上升，提高止损位</li>
<li>开仓后第一次斜率变缓不止盈，等待第二次拉升或跌到止损位</li>
<li>开仓后出现震荡，持续 10 根 K 线不创新高后止盈出场</li>
<li>二次拉升后斜率变缓后止盈出场</li>
<li>连续 3 根光脚阴线后止损出场</li>
</ul>
<p>python 蜡烛图<br>
<a href="https://www.statology.org/matplotlib-python-candlestick-chart/" target="_blank" rel="noopener">https://www.statology.org/matplotlib-python-candlestick-chart/</a><br>
<a href="https://www.geeksforgeeks.org/how-to-create-a-candlestick-chart-in-matplotlib/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/how-to-create-a-candlestick-chart-in-matplotlib/</a><br>
<a href="https://www.highcharts.com.cn/docs/candlestick" target="_blank" rel="noopener">https://www.highcharts.com.cn/docs/candlestick</a></p>
<h2 id="大数据"><a class="header-anchor" href="#大数据">¶</a>大数据</h2>
<p>Flink 从 0 到 1 学习<br>
<a href="https://github.com/zhisheng17/flink-learning" target="_blank" rel="noopener">https://github.com/zhisheng17/flink-learning</a><br>
<a href="http://www.54tianzhisheng.cn/2018/10/13/flink-introduction/#" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/10/13/flink-introduction/#</a></p>
<p>数据分层详解ODS、DWD、DWM、DWS、ADS<br>
<a href="https://blog.csdn.net/qq_38730338/article/details/122713887" target="_blank" rel="noopener">https://blog.csdn.net/qq_38730338/article/details/122713887</a></p>
<p>数据仓库</p>
<ul>
<li>Data warehouse（可简写为DW或者DWH）数据仓库，是在数据库已经大量存在的情况下的一整套包括了etl、调度、建模在内的完整的理论体系。</li>
<li>数据仓库的方案建设的目的，是为前端查询和分析作为基础。</li>
<li>数据仓库并不是数据的最终目的地，而是为数据最终的目的地做好准备，这些准备包含：清洗、转义、分类、重组、合并、拆分、统计等</li>
</ul>
<p>分层：</p>
<ul>
<li>ODS: Operation Data Store 数据准备区，也称为贴源层
<ul>
<li>经过抽取、洗净、传输，也就是ETL过程之后进入本层。</li>
<li>为了考虑后续可能需要追溯数据问题，因此对于这一层就不建议做过多的数据清洗工作，原封不动地接入原始数据即可。</li>
<li>来源：
<ul>
<li>业务库：
<ul>
<li>离线：sqoop 定时抽取数据；</li>
<li>实时: 使用 canal 监听 mysql 的 binlog 日志</li>
</ul>
</li>
<li>埋点日志：
<ul>
<li>离线：日志一般是以文件的形式保存，可以选择使用 flume 来定时同步；</li>
<li>实时：spark streaming，Flink、Kafka</li>
</ul>
</li>
<li>消息队列：ActiveMQ、Kafka</li>
</ul>
</li>
</ul>
</li>
<li>DWD：数据细节层 data warehouse details
<ul>
<li>业务层和数据仓库的隔离层，保持和ODS层一样的数据颗粒度</li>
<li>主要是对 ODS 数据层做一些数据的清洗和规范化的操作，比如去除空数据、脏数据、离群值等。</li>
<li>为了提高 ODS 的易用性，该层通常会才采用一些维度退化方法，将维度退化至事实表中，减少事实表和维表的关联。</li>
</ul>
</li>
<li>DWM：数据中间层 Data Warehouse Middle
<ul>
<li>对通用的核心维度进行聚合操作，算出相应的统计指标，提升公共指标的复用性。</li>
</ul>
</li>
<li>DWS：数据服务层 Data Warehouse Service
<ul>
<li>整合汇总成分析某一个主题域，用于提供后续的业务查询，OLAP 分析，数据服务等。</li>
<li>该层的数据表会相对较少，一张表会涵盖比较多的业务内容，由于其字段较多，因此一般也会称该层的表为宽表。</li>
</ul>
</li>
<li>ADS：数据应用层 Application Data Service
<ul>
<li>一般会存放在 ES、Redis、PostgreSQL 供数据产品和数据分析使用的数据。</li>
<li>也可存放在 hive 或者 Druid 中，供数据分析和数据挖掘使用，常用的数据报表应该存在这里。</li>
</ul>
</li>
<li>Fact Table: 事实表
<ul>
<li>指存储有事实记录的表，比如系统日志、销售记录等。</li>
<li>事实表的记录在不断地增长，比如电商的商品订单表</li>
</ul>
</li>
<li>Dimension Table：维表层
<ul>
<li>与事实表相对应的一种表，它保存了维度的属性值，可以跟事实表做关联。</li>
<li>相当于将事实表上经常重复出现的属性抽取、规范出来用一张表进行管理。</li>
<li>高基数维度数据：一般是用户资料表、商品资料表类似的资料表，数量较大。</li>
<li>低基数维度数据：一般是配置表，比如枚举字段对应的中文含义，或者日期维表等，数量较小。</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/weixin_37536020/article/details/106815387" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37536020/article/details/106815387</a><br>
Spark DAG(Directed Acyclic Graph) 有向无环图</p>
<p>概念理解：</p>
<ul>
<li>一个 Transform 操作(即懒加载方法）转换成一个 RDD。</li>
<li>RDD 之间存在依赖关系，最后通过一个 Action 操作函数对数据进行计算。</li>
<li>我们把 RDD 间组成的计算链，称为 DAG。</li>
<li>通过 RDD 间的依赖关系，可以跟踪依赖链找到该分区的父分区，重新计算该分区数据，
<ul>
<li>采用这种逆推父分区，恢复数据的方式，实现了 RDD 的容错机制。</li>
</ul>
</li>
<li>Action 操作对应一个 Job 任务，根据依赖关系，将 DAG 划分为不同的阶段。</li>
<li>Task 对应一个分区，一个 Task 就是一个分区，RDD1 有 2 个分区，即 2 个 Task。</li>
</ul>
<p>RDD 之间的依赖关系：</p>
<ul>
<li>窄依赖：
<ul>
<li>父分区和子分区存在一对一的关系，比如：map 、filter、union函数。</li>
<li>不会引入Shuffle的概念，不会发生磁盘 IO 读写。</li>
<li>DAG 中连续连续多个窄依赖，会放到一起执行。</li>
</ul>
</li>
<li>宽依赖：
<ul>
<li>父分区和子分区存在多对多的关系，比如groupBy、sortByKey 等带分组功能函数。</li>
<li>引入了 Shuffle 的概念，会发生磁盘 IO 读写。</li>
<li>宽依赖数据丢失时，可以从 Shuffle 临时文件恢复数据</li>
</ul>
</li>
</ul>
<p>执行 Job 阶段划分过程：</p>
<ul>
<li>Spark 在执行 Transformation 类型操作时，都不会立即执行，而是懒计算。</li>
<li>执行若干步 Transformation 类型操作后，一旦遇到 Action 操作，才会真正触发计算。</li>
<li>从当前 Action 往前回溯，如果遇到的是窄依赖则应用流水线优化，继续往前找，直到遇到一个宽依赖。</li>
<li>依赖要进行 Shuffle，不执行流水线优化，所以将这一阶段执行过程组装为一个 Stage。</li>
<li>再从当前宽依赖开始向前找，重复刚才的步骤，从而将整个 DAG 划分为若干 Stage。</li>
</ul>
<p>一文学完Spark常用算子（Spark算子大全）<br>
<a href="https://blog.csdn.net/u011109589/article/details/125675177" target="_blank" rel="noopener">https://blog.csdn.net/u011109589/article/details/125675177</a></p>
<p>Spark 算子分为以下三类:</p>
<ul>
<li>Value
<ul>
<li>输入分区与输出分区一对一型: map flatMap mapPartitions glom</li>
<li>输入分区与输出分区多对一型: union cartesian</li>
<li>输入分区与输出分区多对多型: grouBy</li>
<li>输出分区为输入分区子集型: filter distinct subtract sample takeSample</li>
<li>Cache: cache persist</li>
</ul>
</li>
<li>Key-Value
<ul>
<li>输入分区与输出分区一对一: mapValues</li>
<li>对单个 RDD 或两个 RDD 聚集: combineByKey reduceByKey partitionBy</li>
<li>两个RDD聚集: Cogroup</li>
<li>连接: join leftOutJoin rightOutJoin</li>
</ul>
</li>
<li>Action
<ul>
<li>无输出: foreach</li>
<li>HDFS: saveAsTextFile saveAsObjectFile</li>
<li>Scala: collect reduceByKeyLocally lookup count top reduce fold aggregate</li>
</ul>
</li>
<li>转换算子
<ul>
<li>Value类型: 1. map 2. mapPartitions 3. mapPartitionsWithIndex 4. flatMap 5. glom 6. groupBy 7. filter 8. sample 9. distinct 10. coalesce 11. sortBy</li>
<li>双Value类型： 1. intersection 2. union 3. subtract 4. zip</li>
<li>K-V类型： 1. partitionBy 2. reduceByKey 3. groupByKey 4. aggregateByKey 5. foldByKey 6. combineByKey 7. join 8. sortByKey 9. mapValues 10. cogroup</li>
</ul>
</li>
<li>行动算子 1. reduce 2. collect 3. count 4. first 5. take 6. takeOrdered 7. aggregate 8. fold 9. countByValue 10. countByKey 11. foreach 12. save</li>
</ul>
<p>spark 下载<br>
<a href="https://spark.apache.org/downloads.html" target="_blank" rel="noopener">https://spark.apache.org/downloads.html</a><br>
<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/spark/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/spark/</a></p>
<pre><code>wget https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-3.3.1/spark-3.3.1-bin-hadoop3-scala2.13.tgz
tar xf spark-3.3.1-bin-hadoop3-scala2.13.tgz
cd spark-3.3.1-bin-hadoop3-scala2.13
./bin/spark-shell --version
</code></pre>
<p>Spark：从“大数据的Hello World”开始<br>
<a href="https://zhuanlan.zhihu.com/p/407652473" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/407652473</a></p>
<pre><code>scala&gt; import org.apache.spark.rdd.RDD
import org.apache.spark.rdd.RDD

scala&gt; val rootPath: String = &quot;.&quot;
val rootPath: String = .

scala&gt; val file: String = s&quot;${rootPath}/README.md&quot;
val file: String = ./README.md

scala&gt; val lineRDD: RDD[String] = spark.sparkContext.textFile(file)
val lineRDD: org.apache.spark.rdd.RDD[String] = ./README.md MapPartitionsRDD[3] at textFile at &lt;console&gt;:1

scala&gt; val wordRDD: RDD[String] = lineRDD.flatMap(line =&gt; line.split(&quot; &quot;))
val wordRDD: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[4] at flatMap at &lt;console&gt;:1

scala&gt; val cleanWordRDD: RDD[String] = wordRDD.filter(word =&gt; !word.equals(&quot;&quot;))
val cleanWordRDD: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[5] at filter at &lt;console&gt;:1

scala&gt; val kvRDD: RDD[(String, Int)] = cleanWordRDD.map(word =&gt; (word, 1))
val kvRDD: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[6] at map at &lt;console&gt;:1

scala&gt; val wordCounts: RDD[(String, Int)] = kvRDD.reduceByKey((x, y) =&gt; x + y)
val wordCounts: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[7] at reduceByKey at &lt;console&gt;:1

scala&gt; wordCounts.map{case (k, v) =&gt; (v, k)}.sortByKey(false).take(5)
val res0: Array[(Int, String)] = Array((23,the), (16,to), (15,Spark), (13,for), (9,##))
</code></pre>
<p>简化</p>
<pre><code>text_file = sc.textFile(&quot;hdfs://...&quot;)
counts = text_file.flatMap(lambda line: line.split(&quot; &quot;)) \
             .map(lambda word: (word, 1)) \
             .reduceByKey(lambda a, b: a + b)
counts.saveAsTextFile(&quot;hdfs://...&quot;)
</code></pre>
<p>Spark和Flink的对比，谁才是大数据计算引擎王者?<br>
<a href="https://blog.csdn.net/educast/article/details/119929704" target="_blank" rel="noopener">https://blog.csdn.net/educast/article/details/119929704</a></p>
<p>Spark详解(02) - Spark概述<br>
<a href="https://www.cnblogs.com/meanshift/p/16063784.html" target="_blank" rel="noopener">https://www.cnblogs.com/meanshift/p/16063784.html</a></p>
<p>Spark 集群的独立部署环境</p>
<ul>
<li>不需要依赖其他的资源调度框架，自身就实现了资源调度的功能</li>
<li>环境中还有其他两个核心组件：Master 和 Worker</li>
<li>Master 是一个进程，主要负责资源的调度和分配，并进行集群的监控等职责，类似于 Yarn 环境中的 RM</li>
<li>Worker 也是进程，一个 Worker 运行在集群中的一台服务器上，由 Master 分配资源对数据进行并行的处理和计算，类似于 Yarn 环境中 NM。</li>
</ul>
<p>ApplicationMaster</p>
<ul>
<li>Hadoop 用户向 YARN 集群提交应用程序时,提交程序中应该包含 ApplicationMaster，
<ul>
<li>用于向资源调度器申请执行任务的资源容器 Container</li>
<li>运行用户自己的程序任务 job</li>
<li>监控整个任务的执行</li>
<li>跟踪整个任务的状态</li>
<li>处理任务失败等异常情况。</li>
</ul>
</li>
<li>说的简单点就是，ResourceManager（资源）和 Driver（计算）之间的解耦合靠的就是 ApplicationMaster。</li>
</ul>
<p>Yarn 环境</p>
<ul>
<li>Client 和 Cluster，主要区别在于：Driver 程序的运行节点位置。</li>
<li>Yarn Client 模式
<ul>
<li>Client 模式将用于监控和调度的 Driver 模块在客户端执行，而不是在 Yarn 中，所以一般用于测试。</li>
<li>Driver 在任务提交的本地机器上运行</li>
<li>Driver 启动后会和 ResourceManager 通讯申请启动 ApplicationMaster</li>
<li>ResourceManager 分配 container，在合适的 NodeManager 上启动 ApplicationMaster，负责向 ResourceManager 申请 Executor 内存</li>
<li>ResourceManager 接到 ApplicationMaster 的资源申请后会分配 container，然后 ApplicationMaster 在资源分配指定的 NodeManager 上启动 Executor 进程</li>
<li>Executor 进程启动后会向 Driver 反向注册，Executor 全部注册完成后 Driver 开始执行 main 函数</li>
<li>之后执行到 Action 算子时，触发一个 Job，并根据宽依赖开始划分 stage，每个 stage 生成对应的 TaskSet，之后将 task 分发到各个 Executor 上执行。</li>
</ul>
</li>
<li>Yarn Cluster 模式
<ul>
<li>Cluster 模式将用于监控和调度的 Driver 模块启动在 Yarn 集群资源中执行。一般应用于实际生产环境。</li>
<li>在 YARN Cluster 模式下，任务提交后会和 ResourceManager 通讯申请启动 ApplicationMaster，</li>
<li>随后 ResourceManager 分配 container，在合适的 NodeManager 上启动 ApplicationMaster，此时的 ApplicationMaster 就是 Driver。</li>
<li>后续和 Yarn Client 一样</li>
</ul>
</li>
</ul>
<p>spark-关于spark分区的理解<br>
<a href="https://blog.csdn.net/qq_34224565/article/details/108556055" target="_blank" rel="noopener">https://blog.csdn.net/qq_34224565/article/details/108556055</a></p>
<ul>
<li>确切的说，spark 没有分区，是 RDD 有分区。分区是 spark 在内存中进行并行计算时的一块独立的空间，是 RDD 并行计算的最小单元。</li>
<li>RDD 的数据集在逻辑上被划分为多个分片，每一个分片称为分区，而每个分区的数值计算都是在一个任务中进行的。</li>
<li>任务的个数，也是由 RDD (准确来说是 job 最后一个 RDD)的分区数决定。</li>
<li>数据源为 hdfs 时，rdd 的分区数由 hdfs 的 block 数决定，类似于 mr 的分片数跟 block 数相同，是考量了磁盘 IO 的性能后作出的选择。</li>
<li>正常情况下，数据源为 hdfs 时，读取时是不需要设置分区数的，设置了反而会影响效率。</li>
<li>分区数越多越好吗？
<ul>
<li>分区数太多意味着任务数太多，每次调度任务也是很耗时的，所以分区数太多会导致总体耗时增多。</li>
<li>如果一个分区的数据量过小，则 task 的调度会影响效率，如果分区数相对于 cores 过小，则会造成资源浪费。</li>
</ul>
</li>
<li>分区数太少会有什么影响？
<ul>
<li>分区数太少的话，会导致一些节点没有分配到任务；</li>
<li>分区数太少的话，会导致一些节点没有分配到任务；</li>
<li>分区数不合理，会导致数据倾斜问题；</li>
</ul>
</li>
<li>官方建议 partitionNum 为 executor-cores * num-executor 的 2~3 倍。</li>
</ul>
<p>分区方式<br>
<a href="https://blog.csdn.net/dmy1115143060/article/details/82620715" target="_blank" rel="noopener">https://blog.csdn.net/dmy1115143060/article/details/82620715</a></p>
<ul>
<li>Spark包含两种数据分区方式：HashPartitioner（哈希分区）和RangePartitioner（范围分区）。</li>
<li>一般而言，对于初始读入的数据是不具有任何的数据分区方式的。</li>
<li>数据分区方式只作用于&lt;Key，Value&gt;形式的数据。</li>
<li>当一个 Job 包含 Shuffle 操作类型的算子时，如groupByKey，reduceByKey etc，此时就会使用数据分区方式来对数据进行分区</li>
<li>在 Spark Shuffle 阶段中，共分为 Shuffle Write 阶段和 Shuffle Read 阶段
<ul>
<li>Shuffle Write 阶段中，Shuffle Map Task 对数据进行处理产生中间数据，然后再根据数据分区方式对中间数据进行分区。</li>
<li>Shffle Read 阶段中的 Shuffle Read Task 会拉取 Shuffle Write 阶段中产生的并已经分好区的中间数据。</li>
</ul>
</li>
</ul>
<p>Scala基础教程<br>
<a href="https://blog.csdn.net/zzy979481894/article/details/123890912" target="_blank" rel="noopener">https://blog.csdn.net/zzy979481894/article/details/123890912</a></p>
<h2 id="其它"><a class="header-anchor" href="#其它">¶</a>其它</h2>
<ul>
<li>俗话说：兔子不吃窝边草 可俗话又说：近水楼台先得月</li>
<li>俗话说：宰相肚里能撑船 可俗话又说：有仇不报非君子</li>
<li>俗话说：人不犯我，我不犯人。 可俗话又说：先下手为强，后下手遭殃。</li>
<li>俗话说：男子汉大丈夫，宁死不屈。可俗话又说：男子汉大丈夫，能屈能伸。</li>
<li>俗话说：打狗还得看主人  可俗话又说：杀鸡给猴看。</li>
<li>俗话说：车到山前必有路  可俗话又说：不撞南墙不回头</li>
<li>俗话说：礼轻情谊重        可俗话又说：礼多人不怪</li>
<li>俗话说：人多力量大        可俗话又说：人多嘴杂</li>
<li>俗话说：一个好汉三个帮  可俗话又说：靠人不如靠己</li>
<li>俗话说：人往高处走        可俗话又说：爬的高，摔得重。</li>
</ul>
<h2 id="电路"><a class="header-anchor" href="#电路">¶</a>电路</h2>
<p>德州仪器电路仿真 TINA-TI（TM）模拟器简介<br>
<a href="http://training.eeworld.com.cn/TI/video/18813" target="_blank" rel="noopener">http://training.eeworld.com.cn/TI/video/18813</a></p>
<p>整流电路<br>
<a href="https://blog.csdn.net/cherrychen666/article/details/112986395" target="_blank" rel="noopener">https://blog.csdn.net/cherrychen666/article/details/112986395</a></p>
<p>Tina-TI——小巧好用又高效的原理图仿真软件<br>
<a href="https://zhuanlan.zhihu.com/p/437404464" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/437404464</a></p>
<ul>
<li>TI 提供了很多仿真样例，包括音频、比较器、控制环路、电流环路、振荡器、功率放大器、传感器等等。</li>
<li>仿真分析包括直流分析、交流分析、傅里叶分析、噪声分析等。</li>
<li>直流分析可以用来测量某一些节点电压和直流传输特性等，如下可以测量某些节点的电压值。</li>
<li>交流分析包括节点电压、振幅、相位、时延、奈奎斯特等。</li>
<li>交流中分析bode图的幅频和相位曲线。</li>
<li>测量工具包括常见的信号分析仪、示波器、XY记录器、函数发生器、万用表。</li>
</ul>
<h2 id="aws"><a class="header-anchor" href="#aws">¶</a>aws</h2>
<p>ddb test</p>
<pre><code>import boto3
from boto3.dynamodb.conditions import Key
ddb = boto3.resource('dynamodb')

test = ddb.Table('test')

print('insert data')
test.put_item(Item={'domain': 'hello.com', 'email': 'hao@hello.com'})
test.put_item(Item={'domain': 'hello.com', 'email': 'jimmy@hello.com'})
test.put_item(Item={'domain': 'gmail.com', 'email': 'onlytiancai@gmail.com'})

print('scan data')
response = test.scan()
for i in response['Items']:
    print(i)

print('query data')
response = test.query(
    KeyConditionExpression=(Key('domain').eq('hello.com') &amp; Key('email').eq('hao@hello.com'))
)
for i in response['Items']:
    print(i)

print('delete data')
test.delete_item(Key={'domain': 'hello.com', 'email': 'hao@hello.com'})
test.delete_item(Key={'domain': 'hello.com', 'email': 'jimmy@hello.com'})
test.delete_item(Key={'domain': 'gmail.com', 'email': 'onlytiancai@gmail.com'})
</code></pre>
<p>DynamoDB基本概念<br>
<a href="https://zhuanlan.zhihu.com/p/72397412" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72397412</a></p>
<p>DynamoDB-二级索引<br>
<a href="https://zhuanlan.zhihu.com/p/72610885" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72610885</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-202210" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/10/07/202210/" class="article-date">
  	<time datetime="2022-10-07T08:33:43.000Z" itemprop="datePublished">2022-10-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/07/202210/">202210</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://blog-1251103437.cos.ap-beijing.myqcloud.com/202211011604748.png" alt></p>
<h2 id="后台开发"><a class="header-anchor" href="#后台开发">¶</a>后台开发</h2>
<p>微服务应用 API 设计规范<br>
<a href="https://blog.jaggerwang.net/microservice-application-api-design-specification/" target="_blank" rel="noopener">https://blog.jaggerwang.net/microservice-application-api-design-specification/</a></p>
<p>API 版本</p>
<ul>
<li>对于内部使用的 API，自己可以控制客户端升级节奏，应避免使用 API 版本，因为维护多版本 API 的成本很高。</li>
<li>对于对外开放的 API，由于无法控制使用方客户端升级节奏，那么可以通过多版本 API 来实现平滑升级，在废弃老版 API 之前给使用方留足够的升级时间。</li>
<li>API 版本号可在不同的层级上添加，以前面的创建用户 API /api/user/user/create 为例，按作用范围由大到小有以下几种方式：</li>
</ul>
<p>code</p>
<pre><code>/api/v1/user/user/create 在应用网关层级添加（推荐）；
/api/user/v1/user/create 在微服务层级添加；
/api/user/user/v1/create 在模块层级添加；
/api/user/user/create/v1 在 API 层级添加；
</code></pre>
<h2 id="硬件"><a class="header-anchor" href="#硬件">¶</a>硬件</h2>
<p>按下键盘后为什么屏幕上就会有输出<br>
<a href="https://www.51cto.com/article/698488.html" target="_blank" rel="noopener">https://www.51cto.com/article/698488.html</a></p>
<p>内存中有这样一部分区域，是和显存映射的。啥意思，就是你往上图的这些内存区域中写数据，相当于写在了显存中。而往显存中写数据，就相当于在屏幕上输出文本了。</p>
<pre><code>mov [0xB8000],'h' 
mov [0xB8002],'e' 
mov [0xB8004],'l' 
mov [0xB8006],'l' 
mov [0xB8008],'o' 
</code></pre>
<p>I2C接口与SPI和UART接口的区别<br>
<a href="https://blog.csdn.net/chenhuanqiangnihao/article/details/123359352" target="_blank" rel="noopener">https://blog.csdn.net/chenhuanqiangnihao/article/details/123359352</a></p>
<p>总线接口 UART I2C SPI USB的异同点</p>
<ul>
<li>UART(RS232) 通用异步串行口，速率不快，可全双工，结构上一般由波特率产生器、UART 发送器、UART 接收器组成，硬件上两线，一收一发。</li>
<li>SPI 高速同步串行口，高速，可全双工，收发独立，同步接口，可实现多个 SPI 设备互联，硬件 4 条线。</li>
<li>I2C 双向、两线、串行、多主控接口标准。速率不快，半双工，同步接口，具有总线仲裁机制，非常适合器件间近距离经常性数据通信，可实现设备组网。</li>
<li>USB 通用串行总线，高速，半双工，由主机、hub、设备组成。设备可以与下级 hub 相连构成星型结构。</li>
</ul>
<p>OLED显示屏是利用有机电自发光二极管制成的显示屏，其中每一个像素点就是一个led。</p>
<p>ESP8266、ESP32和STM32的区别<br>
<a href="https://baijiahao.baidu.com/s?id=1730615149655141528" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1730615149655141528</a></p>
<ul>
<li>ESP8266，价格 10 元左右。</li>
<li>ESP32，是 ESP8266 的升级版本，速度更快还带有蓝牙 4.2 和蓝牙低功耗，价格在20元左右
<ul>
<li>优点：
<ul>
<li>ESP32 可用引脚比 ESP8266 更多</li>
<li>双核处理器能够多线程实时处理；</li>
<li>高速主频 240MHZ，对比 STM32F1 的 72MHZ 和 STM32F4 的168MHZ，速度快很多，价格 STM 系低出非常多；</li>
<li>自带蓝牙和 Wifi，不用再花费成本去购置额外模块，成本更加低；</li>
<li>编程上可以使用 arduino 环境，编程难度比 STM32 低很多，开源项目很多，开发速度很快。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>引脚数量过少是现阶段 ESP32 的硬伤之一</li>
</ul>
</li>
</ul>
</li>
<li>STM32 是一种基于ARM架构的32位微控制器。
<ul>
<li>优点：
<ul>
<li>通讯接口十分丰富，如 USART，I2C，SPI，CAN，以太网通讯等；</li>
<li>可用 GPIO 数量非常多，可以控制大量设备；</li>
<li>定时器数量很多，中断系统也十分完善，能实现非常复杂的逻辑；</li>
<li>多路 ADC 和 DAC 功能，可用于读取大量传感器等；</li>
<li>可运行 Free RTOS，RT thread，UCOS 等实时操作系统，可用于控制复杂系统；</li>
<li>可连接 SD 卡，LCD 屏，有摄像头接口，可读取 USB 功能等。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>STM32 的价格一直在上涨。如果不需要以太网、摄像头和 DACD 等功能时可以考虑 F1 系列。</li>
<li>上手有一定难度，需要一定的时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="前端"><a class="header-anchor" href="#前端">¶</a>前端</h2>
<p>最简洁Vue+Electron项目搭建教程<br>
<a href="https://zhuanlan.zhihu.com/p/335225253" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/335225253</a></p>
<p>vue3.x+ts项目创建，配置流程<br>
<a href="https://blog.csdn.net/csl125/article/details/126000350" target="_blank" rel="noopener">https://blog.csdn.net/csl125/article/details/126000350</a></p>
<p>electron install</p>
<pre><code>npm config set ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/
export ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/
npx electron-forge import
npm install --save-dev electron --registry=https://registry.npm.taobao.org
npm install --save-dev @electron-forge/cli --registry=https://registry.npm.taobao.org
npx electron-forge import
npm run make
</code></pre>
<p>electron-vite | 新一代electron开发构建工具<br>
<a href="https://juejin.cn/post/7084126780390375461" target="_blank" rel="noopener">https://juejin.cn/post/7084126780390375461</a></p>
<pre><code>├──src
|  ├──main
|  |  ├──index.js
|  |  └──...
|  ├──preload
|  |  ├──index.js
|  |  └──...
|  └──renderer
|     ├──src
|     ├──index.html
|     └──...
├──electron.vite.config.js
└──package.json
</code></pre>
<p>搭配 TypeScript 使用 Vue<br>
<a href="https://cn.vuejs.org/guide/typescript/overview.html" target="_blank" rel="noopener">https://cn.vuejs.org/guide/typescript/overview.html</a></p>
<p>深入理解 TypeScript<br>
<a href="https://jkchao.github.io/typescript-book-chinese/#why" target="_blank" rel="noopener">https://jkchao.github.io/typescript-book-chinese/#why</a></p>
<p><a href="https://github.com/sindresorhus/electron-store" target="_blank" rel="noopener">https://github.com/sindresorhus/electron-store</a><br>
<a href="https://github.com/louischatriot/nedb" target="_blank" rel="noopener">https://github.com/louischatriot/nedb</a></p>
<h2 id="网络"><a class="header-anchor" href="#网络">¶</a>网络</h2>
<p>iperf3-vsock: how to measure VSOCK performance<br>
<a href="https://stefano-garzarella.github.io/posts/2019-08-22-vsock-iperf3/" target="_blank" rel="noopener">https://stefano-garzarella.github.io/posts/2019-08-22-vsock-iperf3/</a></p>
<p>Iperf3网络性能测试工具详解教程<br>
<a href="https://www.cnblogs.com/xuanbjut/p/14144255.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuanbjut/p/14144255.html</a></p>
<ul>
<li>Iperf是美国伊利诺斯大学（University of Illinois）开发的一种开源的网络性能测试工具。可以用来测试网络节点间（也包括回环）TCP或UDP连接的性能，包括带宽、抖动以及丢包率，其中抖动和丢包率适应于UDP测试，而带宽测试适应于TCP和UDP。</li>
<li>Iperf是一款基于TCP/IP和UDP/IP的网络性能测试工具，可以用来测量网络带宽和网络质量，提供网络延迟抖动、数据包丢失率、最大传输单元等统计信息。网络管理员可以根据这些信息了解并判断网络性能问题，从而定位网络瓶颈，解决网络故障。</li>
</ul>
<p>code</p>
<pre><code># server
iperf3 -s -i 1 -p 5200
# client
iperf -c 127.0.0.1 -i 1 -t 60 -p 5200
</code></pre>
<p>带宽测试通常采用UDP模式，因为能测出极限带宽、时延抖动、丢包率。在进行测试时，首先以链路理论带宽作为数据发送速率进行测试，例如，从客户端到服务器之间的链路的理论带宽为100Mbps，先用-b 100M进行测试，然后根据测试结果（包括实际带宽，时延抖动和丢包率），再以实际带宽作为数据发送速率进行测试，会发现时延抖动和丢包率比第一次好很多，重复测试几次，就能得出稳定的实际带宽。</p>
<pre><code># server
iperf3 -s -i 1 -p 5210
# client
iperf3 -u -c 127.0.0.1 -b 100m -t 10 -p 5210 -b 40G
</code></pre>
<p>TCP 和 UDP 可以使用同一个端口吗？<br>
<a href="https://www.51cto.com/article/714728.html" target="_blank" rel="noopener">https://www.51cto.com/article/714728.html</a></p>
<h2 id="linux-2"><a class="header-anchor" href="#linux-2">¶</a>linux</h2>
<p>CPU内存乱序访问与内存屏障<br>
<a href="https://blog.csdn.net/denglin12315/article/details/124488188" target="_blank" rel="noopener">https://blog.csdn.net/denglin12315/article/details/124488188</a></p>
<p>CPU内存乱序访问发生的原因</p>
<ul>
<li>编译优化，指令重排导致乱序
<ul>
<li>编译器在编译代码时不感知多线程并发执行情况。</li>
</ul>
</li>
<li>CPU运行，指令执行乱序
<ul>
<li>在单核CPU 上，不考虑编译器优化导致乱序的前提下，多线程执行不存在内存乱序访问的问题。</li>
</ul>
</li>
</ul>
<p>什么时候用内存屏障</p>
<ul>
<li>单线程代码的程序不需要关心内存乱序的问题。</li>
<li>在多线程编程中，由于使用互斥量，信号量已经隐式包含各种内存屏障，内存乱序的问题同样不需要考虑了。</li>
<li>只有当使用无锁(lock-free)技术时，才需要考虑在合适的地方加入合适的memery barrier</li>
</ul>
<p>Linux内存屏障使用注意事项：</p>
<ul>
<li>所有的 CPU Memory barrier（除了数据依赖barrier&lt;smp_read_barrier_depends()&gt;之外）都隐含了编译器barrier。</li>
<li>这里的 SMP 开头的 Memory barrier 会根据配置在单处理器上直接使用编译器 barrier，而在 SMP 上才使用 CPU Memory barrier</li>
<li>CPU Memory barrier 中某些类型的 Memory barrier 需要成对使用</li>
</ul>
<p>volatile 关键字与内存屏障</p>
<p>编译器在编译用 volatile 关键字修饰的变量的时候，对于该变量的访问操作，生成的指令会直接去该变量对应的内存中取值，而不会用寄存器暂存该变量的中间结果。</p>
<pre><code>#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)
#define mb() alternative(&quot;lock; addl $0,0(%%esp)&quot;, &quot;mfence&quot;, X86_FEATURE_XMM2)    #读写屏障
#define rmb() alternative(&quot;lock; addl $0,0(%%esp)&quot;, &quot;lfence&quot;, X86_FEATURE_XMM2)   #读屏障
#define wmb() alternative(&quot;lock; addl $0,0(%%esp)&quot;, &quot;sfence&quot;, X86_FEATURE_XMM)    #写屏障
</code></pre>
<p>解决内核竟态的方法<br>
<a href="https://blog.csdn.net/weixin_58458700/article/details/120497321" target="_blank" rel="noopener">https://blog.csdn.net/weixin_58458700/article/details/120497321</a></p>
<ul>
<li>中断屏蔽
<ul>
<li>单核的cpu有效</li>
<li>临界区很小,里面不可以有延时或者耗时的操作(copy_to_user)</li>
<li>如果中断屏蔽的时间很长,会导致用户的数据丢失或内核的崩溃.</li>
</ul>
</li>
<li>自旋锁
<ul>
<li>自旋锁是针对于多核处理器设计的</li>
<li>自旋锁在上锁的时候会关闭抢占.</li>
</ul>
</li>
<li>信号量
<ul>
<li>得不到锁的进程处于一个休眠的状态</li>
<li>信号量不会关闭抢占</li>
<li>保护的临界区可以很大</li>
</ul>
</li>
<li>互斥体
<ul>
<li>保护的临界区可以很大，里面可以有延时，耗时，甚至休眠的操作</li>
<li>在保护临界区较少的临界资源时，互斥体的效率高于信号量。</li>
</ul>
</li>
<li>原子变量/操作
<ul>
<li>原子操作本身就是一个变量，这个变量的修改内核做了防竞态的过程。</li>
<li>这个变量值修改的过程是通过内联汇编完成，对这个变量的操作看成一个不可被分割的整体。</li>
</ul>
</li>
</ul>
<p>Linux内核快速处理路径尽量多用slab而慎用kmalloc<br>
<a href="https://blog.csdn.net/dog250/article/details/105544111" target="_blank" rel="noopener">https://blog.csdn.net/dog250/article/details/105544111</a></p>
<ul>
<li>kmem_cache 是针对特定数据结构的独享内存池子，它以 <em>最小化碎片</em> 的原则为特定的场合提供 <em>可高效访问</em> 的内存，比如 sock，sk_buff 这些。</li>
<li>当你调用 kmalloc(size, flags) 申请内存时，系统会根据你的size向上寻找一个最接近的kmem_cache，然后在其中为你分配所需的内存。</li>
<li>并不是说 32 字节的结构体分配就一定会获得连续的内存，而 64 字节的就不会， 这完全取决于你的系统当前的整体 kmalloc 使用情况。</li>
<li>kmalloc 并不适合快速路径的内存分配，它只适合稳定的，离散的管理结构体的内存分配。</li>
<li>大家之所以普遍喜欢用 kmalloc，因为它简单，快捷，少了 kmem_cache 的 create 和 destroy 的维护操作。</li>
<li>kmalloc 有个副作用，就是它只有固定的大小，比如你分配一个 24 字节大小的结构体，事实上系统会给你 32 字节。</li>
<li>在诸如网络协议栈处理这种相对快速的路径中，比如skbuff，sock，nfconntrack 等结构体均是在自行维护的独享 kmem_cache 中被管理的，这保证了内存分配的尽可能的连续性，尽可能的最少碎片。
<ul>
<li>kmem_cache 的 obj 可以随意释放。</li>
<li>kmem_cache 的 obj 按照释放的逆序进行分配。</li>
<li>kmem_cache 的 free 相当于 push 操作，而 alloc 相当于 pop 操作。</li>
</ul>
</li>
<li>在连续的内存上进行遍历，其性能远超在离散的内存上进行遍历！</li>
<li>我们使用自行维护的kmem_cache slab时，当从中分配的对象插入链表时，要尽量按照其内存地址的升序插入链表确定的位置，这样在遍历链表时可以达到最大化预取的效果。
<ul>
<li>尽可能节省内存，保持内存的紧凑。</li>
<li>提高 CPU dcache 的命中率，最大化 preload 效果。</li>
</ul>
</li>
<li>根据 slab 对象的内存使用 hlistaddbefore[rcu]，hlistaddbebind[rcu]将对象插入 hlist 的特定位置，而不是简单使用 hlistaddhead。</li>
</ul>
<p>ssh 隧道</p>
<pre><code>ssh -CfNg -L 48175:127.0.0.1:48175 ubuntu@8.8.8.8
</code></pre>
<p>按进程关键字杀进程</p>
<pre><code>ps -C &quot;ssh -CfNg -L 48175:127.0.0.1:48175&quot; -o pid= | xargs kill
</code></pre>
<p><a href="https://blog.csdn.net/zqixiao_09/article/details/79265789" target="_blank" rel="noopener">https://blog.csdn.net/zqixiao_09/article/details/79265789</a><br>
linux上的自旋锁有三种实现：</p>
<ol>
<li>在单cpu，不可抢占内核中，自旋锁为空操作。</li>
<li>在单cpu，可抢占内核中，自旋锁实现为“禁止内核抢占”，并不实现“自旋”。</li>
<li>在多cpu，可抢占内核中，自旋锁实现为“禁止内核抢占” + “自旋”。</li>
</ol>
<p>非抢占式内核: 如果一个进程在内核态运行，其只有在以下两种情况会被切换：</p>
<ul>
<li>其运行完成（返回用户空间）</li>
<li>主动让出 cpu（即主动调用 schedule 或内核中的任务阻塞——这同样也会导致调用 schedule）</li>
</ul>
<p>抢占式内核: 如果一个进程在内核态运行，其只有在以下四种情况会被切换：</p>
<ul>
<li>其运行完成（返回用户空间）</li>
<li>主动让出 cpu（即主动调用 schedule 或内核中的任务阻塞——这同样也会导致调用 schedule）</li>
<li>当从中断处理程序正在执行，且返回内核空间之前（此时可抢占标志premptcount须为0） 。</li>
<li>当内核代码再一次具有可抢占性的时候，如解锁及使能软中断等。</li>
</ul>
<p>其它</p>
<ul>
<li>禁止内核抢占只是关闭“可抢占标志”，而不是禁止进程切换。
<ul>
<li>显式使用 schedule 或进程阻塞（此也会导致调用schedule）时，还是会发生进程调度的。</li>
</ul>
</li>
<li>对于多核抢占与多核非抢占的情况，在使用自旋锁时，其情况基本是一致的。
<ul>
<li>因为在多核抢占的情况下，使用自旋锁会禁止内核抢占，这样多核抢占就相当于多核非抢占的情况。</li>
</ul>
</li>
</ul>
<p>被自旋锁保护的临界区代码执行时，它不能因为任何原因放弃处理器：</p>
<ul>
<li>被自旋锁保护的临界区代码执行时，不能进入休眠。</li>
<li>被自旋锁保护的临界区代码执行时，不能被被其他中断中断。</li>
<li>被自旋锁保护的临界区代码执行时，内核不能被抢占。</li>
</ul>
<p>所以现代处理器在处理自旋锁时都会设定自旋上限时间以防死锁. 另自旋锁在单核非抢占式CPU上是无效的.被设为空操作,不做任何事.</p>
<p>C++性能优化（十二）——自旋锁<br>
<a href="https://blog.csdn.net/A642960662/article/details/123029988" target="_blank" rel="noopener">https://blog.csdn.net/A642960662/article/details/123029988</a></p>
<p>互斥锁</p>
<ul>
<li>属于 sleep-waiting 类型锁。Linux Kernel 2.6.x 稳定版开始，Linux 的互斥锁都是 futex (Fast Usermode Mutex)锁。</li>
<li>Futex 是一个在 Linux 上实现锁定和构建高级抽象锁如信号量和 POSIX 互斥的基本工具。</li>
<li>Futex 是由用户空间的一个对齐的整型变量和附在其上的内核空间等待队列构成。</li>
<li>多进程或多线程绝大多数情况下对位于用户空间的futex的整型变量进行操作(汇编语言调用 CPU 提供的原子操作指令来增加或减少)</li>
<li>而其它情况下则需要通过代价较大的系统调用来对位于内核空间的等待队列进行操作(如唤醒等待的进程/线程或将当前进程/线程放入等待队列)。</li>
<li>除了多个线程同时竞争锁的少数情况外，基于futex的lock操作是不需要进行代价昂贵的系统调用操作的。</li>
<li>互斥锁实际上是 count=1 情况下的 semaphore。</li>
</ul>
<p>互斥锁缺点：</p>
<ul>
<li>等待互斥锁会消耗时间，等待延迟会损害系统的可伸缩性。</li>
<li>优先级倒置。低优先级的线程可以获得互斥锁，因此会阻碍需要同一互斥锁的高优先级线程。</li>
<li>锁护送（lock convoying）。如果持有互斥锁的线程分配的时间片结束，线程被取消调度，则等待同一互斥锁的其它线程需要等待更长时间。</li>
</ul>
<p>自旋锁（spin lock）</p>
<ul>
<li>属于 busy-waiting 类型锁。</li>
<li>在多处理器环境中，自旋锁最多只能被一个可执行线程持有。</li>
<li>如果一个可执行线程试图获得一个被其它线程持有的自旋锁，那么线程就会一直进行忙等待，自旋（空转），等待自旋锁重新可用。</li>
<li>如果自旋锁未被争用，请求锁的执行线程便立刻得到自旋锁，继续执行。</li>
<li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是 active 的；</li>
<li>不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li>
<li>通常适用在时间极短的情况，因此操作系统的内核经常使用自旋锁。</li>
<li>但如果长时间上锁，自旋锁会非常耗费性能。</li>
<li>线程持有锁时间越长，则持有锁的线程被 OS调度程序中断的风险越大。</li>
<li>如果发生中断情况，那么其它线程将保持旋转状态(反复尝试获取锁)。</li>
</ul>
<p>互斥锁和自旋锁对比：</p>
<ul>
<li>spinlock 不会使线程状态发生切换，mutex 在获取不到锁的时候会选择sleep。</li>
<li>spinlock 优点：没有耗时的系统调用，一直处于用户态，执行速度快。</li>
<li>spinlock缺点：一直占用 CPU，而且在执行过程中还会锁 bus 总线，锁总线时其它处理器不能使用总线。</li>
<li>mutex 获取锁分为两阶段
<ul>
<li>第一阶段在用户态采用 spinlock 锁总线的方式获取一次锁，如果成功立即返回；</li>
<li>否则进入第二阶段，调用系统的 futex 锁去 sleep，当锁可用后被唤醒，继续竞争锁。</li>
</ul>
</li>
<li>mutex 优点：不会忙等，得不到锁会 sleep。</li>
<li>mutex 缺点：sleep 时会陷入到内核态，需要昂贵的系统调用。</li>
</ul>
<p>几种自旋锁实现：</p>
<ul>
<li>raw_spinlock：
<ul>
<li>在单处理机环境中可以使用特定的原子级汇编指令 swap 和 test_and_set 实现进程互斥。</li>
<li>多处理器环境目前多以锁总线形式保证 test_and_set 指令执行的原子性。</li>
<li>由于传统自旋锁无序竞争的本质特点导致锁竞争争不公平。
<ul>
<li>释放自旋锁时的重置操作将无效化所有其它正在忙等待的处理器的缓存。</li>
<li>在处理器拓扑结构中临近自旋锁拥有者的处理器可能会更快地刷新缓存，因而增大获得自旋锁的机率。</li>
</ul>
</li>
<li>由于每个申请自旋锁的处理器均在全局变量 slock 上忙等待，系统总线将因为处理器间的缓存同步而导致繁重的流量。</li>
</ul>
</li>
<li>ticket spinlock：
<ul>
<li>排队自旋锁，线程将严格地按照申请顺序依次获取排队自旋锁，从而完全解决了不公平问题。</li>
<li>slock 字段被分成两部分 Owner 和 Next
<ul>
<li>分别保存锁持有者和未来锁申请者的票据序号(Ticket Number)</li>
<li>只有 Owner 和 Next 相等时，才表明锁处于未使用状态。</li>
</ul>
</li>
<li>在大规模多处理器系统和 NUMA 系统中
<ul>
<li>由于执行线程均在同一个共享变量 slock 上自旋，申请和释放锁的时候必须对slock进行修改，将导致所有参与排队自旋锁操作的处理器的缓存变得无效。</li>
<li>如果竞争比较激烈，频繁的缓存同步会导致繁重的系统总线和内存的流量，降低整体性能。</li>
</ul>
</li>
</ul>
</li>
<li>mcs spinlock:
<ul>
<li>每个锁的申请者（处理器）只在一个本地变量上自旋。</li>
<li>自旋锁的空间复杂度（即锁数据结构和锁操作所需的空间开销）为常数，占用空间大。</li>
<li>在没有处理器缓存一致性协议保证的系统中也能很好地工作。</li>
</ul>
</li>
<li>qspinlock:
<ul>
<li>基于 mcs spinlock 设计思想但解决了接口不一致或空间太大的问题</li>
</ul>
</li>
</ul>
<p>在CPU较少的情况下， qspinlock的性能和ticket spinlock的性能差不多， 在CPU较多的情况下，qspinlock的性能远好于ticket spinlock。</p>
<p>Linux 性能优化<br>
<a href="https://blog.csdn.net/a642960662/category_11641226.html" target="_blank" rel="noopener">https://blog.csdn.net/a642960662/category_11641226.html</a></p>
<ul>
<li>stress 压力测试工具</li>
<li>sysbench 压力测试工具</li>
<li>sysstat 性能监控工具</li>
<li>BCC 性能监控工具</li>
<li>性能监控工具</li>
<li>网络配置工具</li>
<li>网络流量监控工具</li>
<li>网络测试工具</li>
<li>Kernel Bypass</li>
<li>CPU 性能分析工具</li>
<li>CPU 性能优化原理</li>
<li>CPU 性能调优</li>
<li>CPU Cache</li>
<li>CPU 绑定</li>
<li>中断绑定</li>
</ul>
<p>从自旋锁、睡眠锁、读写锁到 Linux RCU 机制讲解<br>
<a href="https://blog.csdn.net/u010180372/article/details/119470638" target="_blank" rel="noopener">https://blog.csdn.net/u010180372/article/details/119470638</a></p>
<p>单核</p>
<ul>
<li>我们只需要通过关中断 就可以实现 sequential access</li>
<li>local_irq_disable() 和 preempt_disable() 就能实现</li>
</ul>
<p>多核</p>
<ul>
<li>对于一个数据结构, 一旦他已经被一个 core 给 lock 了，当前运行在另一个 core 上的 thread 就需要等待锁释放, 所以需要一个循环等待的过程, 叫做自旋.</li>
<li>具体实现的关键部分是通过 CPU 提供的一种 swap (test_and_set)指令，执行一个原子操作的读出值和放入新值。
<ul>
<li>把 1 放进去, 拿出来 1, 说明被锁了</li>
<li>把 1 放进去，拿出来 0，说明当前 thread/core 拿到这个锁</li>
</ul>
</li>
</ul>
<p>rics-v 代码</p>
<pre><code>void acquire(struct spinlock *lk)
{
    push_off(); // disable interrupts to avoid deadlock.
    if(holding(lk)) panic(&quot;acquire&quot;);

    // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
    //   a5 = 1
    //   s1 = &amp;lk-&gt;locked
    //   amoswap.w.aq a5, a5, (s1)
    while(__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)
        ;

    // Tell the C compiler and the processor to not move loads or stores
    // past this point, to ensure that the critical section's memory
    // references happen strictly after the lock is acquired.
    // On RISC-V, this emits a fence instruction.
    __sync_synchronize();

    // Record info about lock acquisition for holding() and debugging.
    lk-&gt;cpu = mycpu();
}
</code></pre>
<p>内存屏障做的事情</p>
<ul>
<li>在编译器上很好理解就算防止编译过程的指令重排导致的持有锁状态更新和锁实际状态的不一致,</li>
<li>而其在 CPU 上其实就是做一个简单的清空流水线,</li>
</ul>
<p>spinlock 的 overhead</p>
<ul>
<li>内存屏障导致的清空流水线浪费一个流水线长度,</li>
<li>循环等待的不断 CAS 的过程</li>
<li>amoswap 涉及多核 CPU 的 cache coherence MESI 的东西.</li>
</ul>
<p>性能保证</p>
<ul>
<li>关抢占, 关中断后能够使需要锁的操作快速运行完，防止拿到锁后 context switch 出去导致别的线程/核心需要等该核心轮转</li>
<li>Linux spinlock 的实现：spinlock 持有 lock 之后关了 preempt 不关 interrupt。</li>
<li>有一个 irqsave 版本会关，要点是：process 和 中断都想获取一个资源的时候，就要 avoid deadlock。</li>
</ul>
<p>仔细看了下这个排队自旋锁ticket spinlock，解决锁竞争不公平的的实现太巧妙了，就用 Owner 和 Next 俩个半拉（用的一个union）的字段就完美解决了。</p>
<p>还了解了下用户态的自旋锁和内核态的自旋锁不是一回事，因为用户态的自旋锁不能关中断，也不能关抢占，所以不能防止进程被切走，所以临界区性能是无法得到高性能保障的，所以应用层的自旋锁要有一些特殊的优化，比如用 PAUSE 指令让 CPU 执行一些 NOP 类似的效果，避免 reorder 和频繁地清空流水线，再比如说在单核 CPU上提前 yield 防止忙等待，降低CPU的功耗和发热。</p>
<p>频繁的 CAS 操作会产生大量 hazard 的 load 和 store，让流水线指令重排机制认为出现 memory order violation，有可能为了安全而清空流水线，pause 能避免大量循环后再 context switch。</p>
<p>虚拟机 ESXi、PVE、unRaid对比<br>
<a href="https://zhuanlan.zhihu.com/p/166352130" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/166352130</a></p>
<ul>
<li>ESXi，是 VMWare vSphere Hypervisor 套件之下重要组件。前身是 ESX，依赖 Linux 源码，后来抛弃 Linux 源码做成了 ESXi。
<ul>
<li>整个产品商用气息浓重，界面清晰易用，但硬件兼容性较差（主要面向服务器），没什么扩展性（毕竟不是 linux）。</li>
</ul>
</li>
<li>PVE，全称 Proxmox Virtual Environment，是基于 Debian 的 Linux 系统，虚拟机内核为 KVM。
<ul>
<li>硬件兼容性优秀。界面功能不强，很多操作要靠命令行，但扩展能力几乎是无限的。</li>
</ul>
</li>
<li>unRaid，其实是个NAS系统，是基于Slackware的Linux系统，虚拟机内核也是KVM。
<ul>
<li>磁盘阵列管理非常有特色，灵活性很高。同时还有很不错的插件、Docker和虚拟机支持。</li>
</ul>
</li>
</ul>
<h2 id="mysql-3"><a class="header-anchor" href="#mysql-3">¶</a>mysql</h2>
<p>中位数</p>
<p><a href="https://stackoverflow.com/questions/1291152/simple-way-to-calculate-median-with-mysql" target="_blank" rel="noopener">https://stackoverflow.com/questions/1291152/simple-way-to-calculate-median-with-mysql</a></p>
<pre><code>SELECT AVG(dd.val) as median_val
FROM (
SELECT d.val, @rownum:=@rownum+1 as `row_number`, @total_rows:=@rownum
  FROM data d, (SELECT @rownum:=0) r
  WHERE d.val is NOT NULL
  -- put some where clause here
  ORDER BY d.val
) as dd
WHERE dd.row_number IN ( FLOOR((@total_rows+1)/2), FLOOR((@total_rows+2)/2) );
</code></pre>
<p>两个数据库之间导数据<br>
How can I transfer data between 2 MySQL databases?<br>
<a href="https://stackoverflow.com/questions/3242504/how-can-i-transfer-data-between-2-mysql-databases" target="_blank" rel="noopener">https://stackoverflow.com/questions/3242504/how-can-i-transfer-data-between-2-mysql-databases</a></p>
<p>We have also used FIFO’s to great effect to avoid the overhead of actually writing to disk,<br>
or if we do need to write to disk for some reason, to pipe it through gzip.</p>
<pre><code>mkfifo /tmp/myfifo
gzip -c /tmp/myfifo &gt; /tmp/mytable.csv.gz &amp;
SELECT * FROM mytable INTO OUTFILE '/tmp/myfifo'
  FIELDS TERMINATED BY ',' 
  OPTIONALLY ENCLOSED BY '&quot;' 
  ESCAPED BY '\\\\' 
  LINES TERMINATED BY '\\n' ;

gunzip -c /tmp/mytable.csv.gz &gt; /tmp/myfifo &amp;
LOAD DATA INFILE '/tmp/myfifo' INTO TABLE mytable 
  FIELDS TERMINATED BY ',' 
  OPTIONALLY ENCLOSED BY '&quot;' 
  ESCAPED BY '\\\\' 
  LINES TERMINATED BY '\\n' ;
</code></pre>
<p>How to take mysql dump of selected columns of a table<br>
<a href="https://stackoverflow.com/questions/15264597/how-to-take-mysql-dump-of-selected-columns-of-a-table" target="_blank" rel="noopener">https://stackoverflow.com/questions/15264597/how-to-take-mysql-dump-of-selected-columns-of-a-table</a></p>
<pre><code>mysql&gt; CREATE TABLE `tempTable` AS SELECT `columnYouWant` from `table`;
$&gt; mysqldump yourDB tempTable &gt; temp.sql

$&gt; mysql yourDB &lt; temp.sql
mysql&gt; RENAME TABLE `table` TO `tableBackup`, `tempTable` TO `table`;
</code></pre>
<p>查看每个表的大小</p>
<pre><code>SELECT
  TABLE_NAME AS `Table`,
  ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024) AS `Size (MB)`
FROM
  information_schema.TABLES
WHERE
  TABLE_SCHEMA = &quot;dirtable&quot;
ORDER BY
  (DATA_LENGTH + INDEX_LENGTH)
DESC
limit 15;
</code></pre>
<h2 id="流媒体"><a class="header-anchor" href="#流媒体">¶</a>流媒体</h2>
<p>SRS是一个简单高效的实时视频服务器，支持RTMP/WebRTC/HLS/HTTP-FLV/SRT/GB28181。<br>
<a href="https://ossrs.net/lts/zh-cn/docs/v4/doc/introduction" target="_blank" rel="noopener">https://ossrs.net/lts/zh-cn/docs/v4/doc/introduction</a></p>
<p>开源复刻：OBS如何支持直播多人连麦，可连麦的在线发布会<br>
<a href="https://github.com/ossrs/srs/issues/2749" target="_blank" rel="noopener">https://github.com/ossrs/srs/issues/2749</a></p>
<h2 id="GO"><a class="header-anchor" href="#GO">¶</a>GO</h2>
<p>Go语言中你不知道的Interface详解<br>
<a href="https://www.jb51.net/article/135149.htm" target="_blank" rel="noopener">https://www.jb51.net/article/135149.htm</a></p>
<p>传统接口的缺陷</p>
<ul>
<li>侵入式通过 implements 把实现类与具体接口绑定起来了，因此有了强耦合;</li>
<li>如果我修改了接口，比如改了接口方法，则实现类必须改动；</li>
<li>如果我希望实现类再实现一个接口，实现类也必须进行改动；</li>
<li>后续跟进者，必须了解相关的接口。</li>
</ul>
<p>GO 接口的优点</p>
<ul>
<li>只要实现了与接口定义相同的方法，就算实现了某个接口，最重要的，随着代码的增加，你的类结构不会像 Java 那样发生爆炸。</li>
<li>实现类的时候也不需要像 Java、PHP 一样引入各种接口，有可能你定义类的时候，某个接口还不存在。</li>
</ul>
<h2 id="elasticsearch"><a class="header-anchor" href="#elasticsearch">¶</a>elasticsearch</h2>
<p>elasticsearch性能优化（一）<br>
<a href="https://www.cnblogs.com/jelly12345/p/15322814.html" target="_blank" rel="noopener">https://www.cnblogs.com/jelly12345/p/15322814.html</a></p>
<p>TF/IDF vs BM2.5<br>
<a href="https://zhuanlan.zhihu.com/p/573284091" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/573284091</a><br>
<a href="https://blog.csdn.net/qq_40859560/article/details/109147840" target="_blank" rel="noopener">https://blog.csdn.net/qq_40859560/article/details/109147840</a></p>
<p>TF/IDF</p>
<ul>
<li>直觉上，一个词项在文档中出现次数越多，那么该词项和文档的相关性也应该越大。</li>
<li>文档频率越大的词，在文档中越常见，区分作用越小，那么权重也应当越小。</li>
<li>优点：
<ul>
<li>简单，快速，如果语料库是不变的话，可以提前离线计算好语料库中所有词的 tfidf 值</li>
</ul>
</li>
<li>缺点：
<ul>
<li>仅以“词频”度量词的重要性，后续构成文档的特征值序列，词之间各自独立，无法反映序列信息</li>
<li>tfidf 得到是一个稀疏而庞大的矩阵，需要采用降维方式，才方便做后续的文本任务
<ul>
<li>而降维可能会损失一些信息，同时降维的也会提高模型的复杂度，而失去了原本快速的优点</li>
</ul>
</li>
<li>tfidf 得到的 embedings 再输入后续的模型，做文本分类、文本匹配等任务，在效果上通常会差于采用词向量模型训练得到的 embedding。</li>
</ul>
</li>
</ul>
<p>BM25</p>
<ul>
<li>BM25与之不同，它在TF计算方法中增加了一个常量k，用来限制TF值的增长极限。</li>
<li>业务上可以理解为某一个因素的影响强度不能是无限的，而是有个最大值，这也符合我们对文本相关性逻辑的理解。</li>
<li>bm25 其实就是把 query 中每个词，在每篇文档中的 tfidf（改良后的）值求和即为该query与该文档的相似性得分。</li>
<li>优点
<ul>
<li>可以方便线下做离线先计算好文档中出现的每一个词的 idf 并保存为一个字典
<ul>
<li>当用户搜了一个 query，直接分词然后查字典就能得到这个词的 idf，如果字典中没有idf值无意义，因为R=0。同于tfidf。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-202209" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/01/202209/" class="article-date">
  	<time datetime="2022-09-01T03:00:23.000Z" itemprop="datePublished">2022-09-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/01/202209/">202209</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="mysql-5"><a class="header-anchor" href="#mysql-5">¶</a>mysql</h2>
<p>数据同步平台CloudCanal的透明化、可视化运维之道<br>
<a href="https://zhuanlan.zhihu.com/p/409094498" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/409094498</a></p>
<p>数据中台<br>
<a href="https://gitee.com/zrxjava/srt-data" target="_blank" rel="noopener">https://gitee.com/zrxjava/srt-data</a><br>
<a href="https://toscode.gitee.com/LuckyFishSpace/datax-cloud" target="_blank" rel="noopener">https://toscode.gitee.com/LuckyFishSpace/datax-cloud</a><br>
<a href="https://gitee.com/LarkMidTable/LarkMidTable" target="_blank" rel="noopener">https://gitee.com/LarkMidTable/LarkMidTable</a><br>
<a href="https://gitee.com/475660/databand" target="_blank" rel="noopener">https://gitee.com/475660/databand</a><br>
<a href="https://gitee.com/WeBank/DataSphereStudio" target="_blank" rel="noopener">https://gitee.com/WeBank/DataSphereStudio</a></p>
<p>dataease + cloudcanal + clickhouse</p>
<pre><code>分布式存储：HDFS、HBase
行式关系存储：MySQL、Oracle
列式存储：ClickHouse
列族存储：HBase、Cassandra
文档库：ElasticSearch、MongoDB
</code></pre>
<p>查看默认密码</p>
<pre><code>sudo cat /etc/mysql/debian.cnf
</code></pre>
<p>修改 datadir</p>
<pre><code>systemctl stop mysql
mv /var/lib/mysql /data_ext/mysql_data_dir
# 父目录要有cd的权限
chmod o+x /data_ext

vi /etc/mysql/mysql.conf.d/mysqld.cnf
    datadir = /data_ext/mysql_data_dir


vi  /etc/apparmor.d/usr.sbin.mysqld
    # Allow data dir access
      /data_ext/mysql_data_dir/ r,
      /data_ext/mysql_data_dir/** rwk,
systemctl restart apparmor
systemctl start mysql

# 查看日志
journalctl -ru mysql

show variables like '%datadir%';
</code></pre>
<h3 id="linux-4"><a class="header-anchor" href="#linux-4">¶</a>linux</h3>
<p>TODO:<br>
一篇文章带你读懂 io_uring 的接口与实现<br>
<a href="https://zhuanlan.zhihu.com/p/380726590" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/380726590</a></p>
<p>存储大师班 | Linux IO 模式之 io_uring<br>
<a href="https://zhuanlan.zhihu.com/p/389978597" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/389978597</a></p>
<p><a href="https://man.archlinux.org/man/io_uring.7" target="_blank" rel="noopener">https://man.archlinux.org/man/io_uring.7</a><br>
<a href="https://blogs.oracle.com/linux/post/an-introduction-to-the-io-uring-asynchronous-io-framework" target="_blank" rel="noopener">https://blogs.oracle.com/linux/post/an-introduction-to-the-io-uring-asynchronous-io-framework</a></p>
<p>挂硬盘</p>
<pre><code>lsblk
fdisk -l
parted /dev/xvdg
    mklabel gpt
    print
    mkpart primary 0% 100% 
    q
fdisk -l

mkfs.ext4 -T largefile /dev/xvdg1
mkdir /data_ext2
mount -t ext4 /dev/xvdg1 /data_ext2
echo '/dev/xvdg1 /data_ext2  ext4    defaults    0   0'  &gt;&gt;/etc/fstab

mkfs.xfs -f -n ftype=1 /dev/nvme1n1
mkdir /data_ext
mount -t xfs /dev/nvme1n1 /data_ext
echo '/dev/nvme1n1 /data_ext xfs  defaults    0   0'  &gt;&gt;/etc/fstab
</code></pre>
<p>扩展磁盘</p>
<pre><code>在 aws 的 ebs console 修改卷的大小
lsblk
    nvme0n1     259:0    0   40G  0 disk
    └─nvme0n1p1 259:1    0   20G  0 part /
sudo growpart /dev/nvme0n1 1
df -hT
    Filesystem     Type      Size  Used Avail Use% Mounted on
    /dev/root      ext4       20G   20G  277M  99% /
# ext4
sudo resize2fs /dev/nvme0n1p1
# xfs 
sudo xfs_growfs -d /data_ext
df -hT /
    Filesystem     Type  Size  Used Avail Use% Mounted on
    /dev/root      ext4   39G   20G   20G  50% /
</code></pre>
<p>putty 免密无法登录 ubuntu 20.04</p>
<pre><code>pubkeyauthentication yes
pubkeyacceptedkeytypes ecdsa-sha2-nistp256-cert-v01@openssh.com,ecdsa-sha2-nistp384-cert-v01@openssh.com,ecdsa-sha2-nistp521-cert-v01@openssh.com,ssh-ed25519-cert-v01@openssh.com,rsa-sha2-512-cert-v01@openssh.com,rsa-sha2-256-cert-v01@openssh.com,ssh-rsa-cert-v01@openssh.com,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,ssh-ed25519,rsa-sha2-512,rsa-sha2-256,ssh-rsa
</code></pre>
<p>shell for</p>
<ul>
<li>
<p>for 循环在实际生成中应用非常多，避免人工重复的去操作某个事情</p>
</li>
<li>
<p>for 循环中的列表支持正则表达式</p>
</li>
<li>
<p>for 循环中使用(())，双括号内支持 C 语言的命令</p>
</li>
<li>
<p>for 循环中的变量，只是循环去取值列表中取值，然后进行 do 操作，所以取值列表中的参数个数，决定了循环的次数</p>
<p>for i in {1…5};do echo $i;done<br>
for((i=1;i&lt;=5;i++));do echo $i;done<br>
for i in <code>seq 5</code>;do echo $i;done</p>
<p>for IP in <code>cat /root/for/ip.txt</code>    #ip文件为存放ip地址的<br>
do<br>
ping -c 3 -i 0.2 -w 3 $IP &amp;&gt;/dev/null # -c 3 ping 3 次主机 -i 0.2 ping主机间隔 -w 3 ping主机超时间隔<br>
if [ $? -eq 0 ];then<br>
echo “host $IP is up”<br>
else echo “host $IP is down”<br>
fi<br>
done</p>
<p>for user in <code>cat /root/for/a.txt</code>    #a.txt为存放用户名单文件<br>
do<br>
if grep $user /etc/passwd &amp;&gt;/dev/null; then   #检查用户是否存在<br>
echo “$user用户已经存在”<br>
elif [ -d /home/$user ];then          #检查home下是否存在和用户相同的目录<br>
echo “$user用户存在宿主目录”<br>
else useradd $user                    #添加用户并设置初始密码<br>
echo “123456” |passwd --stdin $user &amp;&gt;/dev/null<br>
echo “$user用户已经创建，初始密码为：123456”<br>
fi<br>
done</p>
</li>
</ul>
<p>qemu-system-arm仿真vexpress-a9踩坑记<br>
<a href="https://www.jianshu.com/p/91baa4d140a2" target="_blank" rel="noopener">https://www.jianshu.com/p/91baa4d140a2</a></p>
<p>Das U-Boot 是一个主要用于嵌入式系统的引导加载程序，可以支持多种不同的计算机系统结构，包括PPC、ARM、AVR32、MIPS、x86、68k、Nios与MicroBlaze。这也是一套在GNU通用公共许可证之下发布的自由软件。</p>
<p>qemu 挂 U 盘</p>
<pre><code>qemu-img create -f raw disk.img 512M
mkfs -t ext4 ./disk.img
mkdir tmpfs
mount -o loop ./disk.img tmpfs/

vi tmpfs/hello.c
    #include &lt;stdio.h&gt;
    int main()
    {
        printf(&quot;HelloWorld! \n&quot;);
        return 0;
    }

arm-linux-gnueabi-gcc tmpfs/hello.c -o tmpfs/hello
arm-linux-gnueabi-gcc -static tmpfs/hello.c -o tmpfs/hello

ls tmpfs/
    hello  hello.c  lost+found
file tmpfs/hello
    tmpfs/hello: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=ee8ecff9cbfca92688bbbe7dd4e721ce9e6d23ce, not stripped
umount tmpfs

file disk.img
    disk.img: Linux rev 1.0 ext4 filesystem data, UUID=31c631fb-08fc-4874-8306-e2eae5441050 (extents) (64bit) (large files) (huge files)

qemu-system-arm -M vexpress-a9 -m 256M -kernel arch/arm/boot/zImage -append &quot;rdinit=/linuxrc console=ttyAMA0 loglevel=8&quot; -dtb arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -sd ./disk.img

ls /dev/mmcblk0* -l
    brw-rw----    1 0        0         179,   0 Sep 26 10:23 /dev/mmcblk0
mount -t ext4 /dev/mmcblk0 /mnt/
ls /mnt/
    hello       hello.c     lost+found
</code></pre>
<p>Linux ARM 环境<br>
<a href="https://zhuanlan.zhihu.com/p/146580665" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/146580665</a></p>
<pre><code>wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.4.5.tar.gz
wget https://busybox.net/downloads/busybox-1.28.4.tar.bz2
tar -xzvf linux-5.4.5.tar.gz
tar -jxvf busybox-1.28.4.tar.bz2
cd busybox-1.28.4
export ARCH=arm
export CROSS_COMPILE=arm-linux-gnueabi-
make menuconfig

    Settings ----&gt;
</code></pre>
<p>Build Options 　　　　　　　[*]Build static binary(no shared libs)<br>
make install<br>
cd …<br>
cp -r ./busybox-1.28.4/_install ./linux-5.4.5/</p>
<pre><code>cd ./linux-5.4.5/_install/
mkdir etc
mkdir dev
mkdir mnt
mkdir -p etc/init.d

cd ..
vi _install/etc/init.d/rcS
    mkdir -p /proc
    mkdir -p /tmp
    mkdir -p /sys
    mkdir -p /mnt
    /bin/mount -a
    mkdir -p /dev/pts
    mount -t devpts devpts /dev/pts
    echo /sbin/mdev &gt; /proc/sys/kernel/hotplug
    mdev –s

chmod +x _install/etc/init.d/rcS

vi _install/etc/fstab
    proc /proc proc defaults 0 0
    tmpfs /tmp tmpfs defaults 0 0
    sysfs /sys sysfs defaults 0 0
    tempfs /dev tmpfs defaults 0 0
    debugfs /sys/kernel/debug debugfs defaults 0 0

vi _install/etc/inittab
    ::sysinit:/etc/init.d/rcS
    ::respawn:-/bin/sh
    ::askfirst:-/bin/sh
    ::ctrlaltdel:/bin/umount -a -r

cd _install/dev
mknod console c 5 1
mknod null c 1 3
cd ..

export ARCH=arm
export CROSS_COMPILE=arm-linux-gnueabi-
make vexpress_defconfig
make menuconfig

General setup ----&gt;
    [*]Initial RAM filesystem and RAM disk (initramfs/initrd) support
    (_install)Initramfs source file(s)
Boot option ----&gt;
    ()Default kernel command string
Kernel features ----&gt;
    Memory split(3G/1G user/kernel split) 
    [*] High Memory Support

vi ./usr/gen_initramfs_list.sh+131
    local dev=&quot;`LC_ALL=C ls -l &quot;${location}&quot;`&quot;

make bzImage ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
make dtbs

apt-get install gcc qemu qemu-system-arm gcc-arm-linux-gnueabi libncurses5-dev build-essential flex bison bc
qemu-system-arm -M vexpress-a9 -m 256M -kernel arch/arm/boot/zImage \
    -append &quot;rdinit=/linuxrc console=ttyAMA0 loglevel=8&quot; \
    -dtb arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic

killall qemu-system-arm
</code></pre>
<p>windows gcc<br>
<a href="https://github.com/lordmilko/i686-elf-tools/releases/tag/7.1.0" target="_blank" rel="noopener">https://github.com/lordmilko/i686-elf-tools/releases/tag/7.1.0</a></p>
<p>浅析linux内存管理<br>
<a href="https://blog.csdn.net/faxiang1230/article/details/105720640" target="_blank" rel="noopener">https://blog.csdn.net/faxiang1230/article/details/105720640</a></p>
<p>linux-0.11<br>
<a href="https://github.com/karottc/linux-0.11" target="_blank" rel="noopener">https://github.com/karottc/linux-0.11</a></p>
<p>Remove Last character in String<br>
<a href="https://www.folkstalk.com/2012/05/remove-last-character-in-string-unix.html" target="_blank" rel="noopener">https://www.folkstalk.com/2012/05/remove-last-character-in-string-unix.html</a></p>
<pre><code>sed s/.$// filename

#! /bin/bash
while read LINE
do
echo ${LINE%?}
done &lt; filename

awk '{$0=substr($0,1,length($0)-1); print $0}' filename
</code></pre>
<p>awk 捕获正则分组<br>
<a href="https://www.markhneedham.com/blog/2013/06/26/unixawk-extracting-substring-using-a-regular-expression-with-capture-groups/" target="_blank" rel="noopener">https://www.markhneedham.com/blog/2013/06/26/unixawk-extracting-substring-using-a-regular-expression-with-capture-groups/</a></p>
<p>抓包分析 TCP 连接时间</p>
<pre><code>tcpdump -nn -v -i ens5 &quot;(host 1.1.1.1 or 2.2.2.2) and tcp[tcpflags] &amp; (tcp-syn) != 0&quot;

awk '{match($1,/.*([0-9]\.[0-9]+)$/,arr); if($7==&quot;[S],&quot;) {sync[$3]=arr[1];} {if($7==&quot;[S.],&quot;) {ep=substr($5,1,length($5)-1); if(sync[ep]){print &quot;local = &quot;ep&quot;, connect time = &quot;arr[1]-sync[ep];} }}} ' es_dump.txt| sort -rn -k7
</code></pre>
<p>tcpdump 看这一篇就够了<br>
<a href="https://www.jianshu.com/p/e3292f4dcc99" target="_blank" rel="noopener">https://www.jianshu.com/p/e3292f4dcc99</a></p>
<p><a href="https://askubuntu.com/questions/343727/filenames-with-spaces-breaking-for-loop-find-command" target="_blank" rel="noopener">https://askubuntu.com/questions/343727/filenames-with-spaces-breaking-for-loop-find-command</a><br>
<a href="https://unix.stackexchange.com/questions/81349/how-do-i-use-find-when-the-filename-contains-spaces" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/81349/how-do-i-use-find-when-the-filename-contains-spaces</a></p>
<p>查看当前目录下所有压缩文件的压缩内容</p>
<pre><code>find . -type f -name '*.*' -print0 |
while IFS= read -r -d '' file; do
    if [ &quot;${file##*.}&quot;x = &quot;zip&quot;x ];then
        echo '###', $file
        unzip -O gbk -l &quot;$file&quot;
    fi
    if [ &quot;${file##*.}&quot;x = &quot;rar&quot;x ];then
        echo '###' $file
        rar v &quot;$file&quot;
    fi
done
</code></pre>
<p>linux 0.11 源码<br>
linus曾经说过：RTFSC - Read The Fucking Source Code.<br>
<a href="https://github.com/karottc/linux-0.11" target="_blank" rel="noopener">https://github.com/karottc/linux-0.11</a></p>
<p>关于这个Tiny_OS 这个是我随着《操作系统真象还原》从零开始自写的项目 当然现在里面的代码都是最后版本的代码了<br>
<a href="https://gitee.com/residual_nozzle_on_dust/Tiny_OS" target="_blank" rel="noopener">https://gitee.com/residual_nozzle_on_dust/Tiny_OS</a></p>
<p>不解压查看压缩包文件列表</p>
<pre><code>unzip -l a.zip
tar tvf a.tar.gz
rar v a.rar
</code></pre>
<p>6.S081 — 操作系统这门课程<br>
<a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec01-introduction-and-examples/1.1-ke-cheng-jian-jie" target="_blank" rel="noopener">https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec01-introduction-and-examples/1.1-ke-cheng-jian-jie</a></p>
<ul>
<li>理解操作系统的设计和实现。设计是指整体的结构，实现是指具体的代码长什么样。</li>
<li>为了深入了解具体的工作原理，你们可以通过一个小的叫做 XV6 的操作系统，获得实际动手经验。</li>
<li>通过研究现有的操作系统，并结合课程配套的实验，你可以获得扩展操作系统，修改并提升操作系统的相关经验，并且能够通过操作系统接口，编写系统软件。</li>
</ul>
<p>ss 命令<br>
ss -o state established</p>
<p>Linux环境编程：从应用到内核<br>
<a href="https://book.douban.com/subject/26820213/" target="_blank" rel="noopener">https://book.douban.com/subject/26820213/</a></p>
<p>本书是Linux技术专家高峰和李彬的合力之作，是两个人多年开发经验的总结和分享，也是市场上唯一一本将Linux应用态与内核态相结合的技术图书，选择这种写作方式是为了向APUE的作者致敬。本书涵盖了APUE中大部分章节的内容，并针对Linux环境，以作者多年经验，详细解析了Linux常用接口的使用方法和陷阱。为了让读者更清楚地理解接口的工作原理，对于绝大部分接口，作者都会深入C库或内核源码进行全面分析。</p>
<p>Linux中的RCU机制[一] - 原理与使用方法<br>
<a href="https://zhuanlan.zhihu.com/p/89439043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/89439043</a><br>
rcu 机制简介<br>
<a href="https://zhuanlan.zhihu.com/p/113999842" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/113999842</a></p>
<p>iotop 非交互式</p>
<pre><code>iotop -o -b -k -P -n3
</code></pre>
<p>crontab 设置重启后执行</p>
<pre><code>sudo tail /var/spool/cron/crontabs/ubuntu
@reboot /home/ubuntu/reboot.sh &gt;&gt; /home/ubuntu/reboot.log 2&gt;&amp;1
</code></pre>
<p>rc.local里指定用户来运行程序</p>
<pre><code>/bin/su - urs -c &quot;/home/script/mount-oss.sh&quot;
</code></pre>
<p>Linux Kernel Hash Table Behavior:<br>
Analysis and Improvements<br>
<a href="http://www.citi.umich.edu/techreports/reports/citi-tr-00-1.pdf" target="_blank" rel="noopener">http://www.citi.umich.edu/techreports/reports/citi-tr-00-1.pdf</a></p>
<p>The Linux kernel employs hash table data structures to store high-usage data objects such as<br>
pages, buffers, inodes, and others. In this report we find significant performance boosts with<br>
careful analysis and tuning of four critical kernel data structures.</p>
<p>几种开源的TCP/IP协议栈分析<br>
<a href="https://www.cnblogs.com/littleKing163/p/5003778.html" target="_blank" rel="noopener">https://www.cnblogs.com/littleKing163/p/5003778.html</a></p>
<ul>
<li>BSD TCP/IP协议栈，BSD栈历史上是其他商业栈的起点，大多数专业TCP/IP栈（VxWorks内嵌的TCP/IP栈）是BSD栈派生的。</li>
<li>uC/IP是由Guy Lancaster编写的一套基于uC/OS且开放源码的TCP/IP协议栈，亦可移植到其它操作系统，是一套完全免费的、可供研究的TCP/IP协议栈，uC/IP大部分源码是从公开源码BSD发布站点和KA9Q（一个基于DOS单任务环境运行的TCP/IP协议栈）移植过来。</li>
<li>LwIP是瑞士计算机科学院（Swedish Institute of Computer Science）的Adam Dunkels等开发的一套用于嵌入式系统的开放源代码TCP/IP协议栈。LwIP的含义是Light Weight(轻型)IP协议，相对于uip。LwIP可以移植到操作系统上，也可以在无操作系统的情况下独立运行。
<ul>
<li>LwIP TCP/IP实现的重点是在保持TCP协议主要功能的基础上减少对RAM的占用，一般它只需要几十K的RAM和40K左右的ROM就可以运行，这使 LwIP协议栈适合在低端嵌入式系统中使用。</li>
<li>LwIP的特性如下：
<ul>
<li>支持多网络接口下的IP转发</li>
<li>支持ICMP协议</li>
<li>包括实验性扩展的的UDP（用户数据报协议），</li>
<li>包括阻塞控制，RTT估算和快速恢复和快速转发的TCP（传输控制协议），</li>
<li>提供专门的内部回调接口（Raw API）用于提高应用程序性能</li>
<li>并提供了可选择的Berkeley接口API。</li>
</ul>
</li>
</ul>
</li>
<li>uIP是专门为8位和16位控制器设计的一个非常小的TCP/IP栈。完全用C编写，因此可移植到各种不同的结构和操作系统上，一个编译过的栈可以在几KB ROM或几百字节RAM中运行。</li>
<li>TinyTcp 栈是TCP/IP的一个非常小和简单的实现，它包括一个FTP客户。TinyTcp是为了烧入ROM设计的并且现在开始对大端结构似乎是有用的（初始目标是68000芯片）。</li>
</ul>
<p>Cache和DMA一致性<br>
<a href="https://zhuanlan.zhihu.com/p/109919756" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/109919756</a><br>
并发基础理论：缓存可见性、MESI协议、内存屏障、JMM<br>
<a href="https://zhuanlan.zhihu.com/p/84500221" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84500221</a><br>
Java网络编程与NIO详解8：浅析mmap和Direct Buffer<br>
<a href="https://blog.csdn.net/AliCoder/article/details/103039202" target="_blank" rel="noopener">https://blog.csdn.net/AliCoder/article/details/103039202</a><br>
漫谈linux文件IO<br>
<a href="http://blog.chinaunix.net/uid-27105712-id-3270102.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-27105712-id-3270102.html</a></p>
<p>查看日志</p>
<pre><code>journalctl --since yesterday
journalctl --since &quot;30 min ago&quot;
</code></pre>
<p>OOM排查与优化<br>
<a href="https://blog.csdn.net/weixin_57400332/article/details/123812918" target="_blank" rel="noopener">https://blog.csdn.net/weixin_57400332/article/details/123812918</a></p>
<ul>
<li>Linux内核有个机制叫OOM killer（Out-Of-Memory killer），该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程，为了防止内存耗尽内核会把该进程杀掉。</li>
<li>root 权限的进程通常被认为很重要，不应该被轻易杀掉，所以打分的时候可以得到 3% 的优惠（分数越低越不容易被杀掉）。</li>
</ul>
<h3 id="elasticsearch-2"><a class="header-anchor" href="#elasticsearch-2">¶</a>elasticsearch</h3>
<p>Elasitcsearch CPU 使用率突然飙升，怎么办？<br>
<a href="https://blog.csdn.net/laoyang360/article/details/122816850" target="_blank" rel="noopener">https://blog.csdn.net/laoyang360/article/details/122816850</a></p>
<p>核查 CPU 使用率</p>
<pre><code>GET _cat/nodes?v=true&amp;s=cpu:desc
</code></pre>
<p>核查热点线程</p>
<pre><code>GET _nodes/my-node,my-other-node/hot_threads
</code></pre>
<p>检查长时间运行的搜索会阻塞搜索线程池中的线程。</p>
<pre><code>GET _tasks?actions=*search&amp;detailed
</code></pre>
<p>取消任务以释放资源</p>
<pre><code>POST _tasks/oTUltX4IQMOUUVeiohTt8A:464/_cancel
</code></pre>
<p>elasticsearch 中的fielddata 和 doc_values<br>
<a href="http://t.zoukankan.com/thewindyz-p-14360503.html" target="_blank" rel="noopener">http://t.zoukankan.com/thewindyz-p-14360503.html</a></p>
<ul>
<li>Doc Values 本质上是一个序列化的 列式存储， 列式存储 适用于聚合、排序、脚本等操作</li>
<li>Doc Values 通过序列化把数据结构持久化到磁盘，我们可以充分利用操作系统的内存，而不是 JVM 的 Heap
<ul>
<li>当 working set 远小于系统的可用内存，系统会自动将 Doc Values 驻留在内存中，使得其读写十分快速</li>
<li>当 working set 远大于可用内存时，系统会根据需要从磁盘读取 Doc Values，然后选择性放到分页缓存中</li>
<li>很显然，这样性能会比在内存中差很多，但是它的大小就不再局限于服务器的内存了。</li>
<li>如果是使用 JVM 的 Heap 来实现那么只能是因为 OutOfMemory 导致程序崩溃了。</li>
</ul>
</li>
<li>与 doc values 不同， fielddata 构建和管理 100% 在内存中，常驻于 JVM 内存堆;
<ul>
<li>fielddata 结构不会在索引时创建。相反，它是在查询运行时，动态填充;</li>
<li>这意味着它本质上是不可扩展的，有很多边缘情况下要提防</li>
</ul>
</li>
</ul>
<p>同义词<br>
Synonyms in Elasticsearch<br>
<a href="https://medium.com/version-1/synonyms-in-elasticsearch-c527280ba8a5" target="_blank" rel="noopener">https://medium.com/version-1/synonyms-in-elasticsearch-c527280ba8a5</a></p>
<p>The same, but different: Boosting the power of Elasticsearch with synonyms<br>
<a href="https://www.elastic.co/blog/boosting-the-power-of-elasticsearch-with-synonyms" target="_blank" rel="noopener">https://www.elastic.co/blog/boosting-the-power-of-elasticsearch-with-synonyms</a></p>
<p>acronyms on Elastic Search request<br>
<a href="https://stackoverflow.com/questions/67707925/acronyms-on-elastic-search-request" target="_blank" rel="noopener">https://stackoverflow.com/questions/67707925/acronyms-on-elastic-search-request</a></p>
<p>Function score query<br>
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html</a></p>
<h3 id="java"><a class="header-anchor" href="#java">¶</a>java</h3>
<p>java.security 框架之签名、加密、摘要及证书<br>
<a href="https://blog.csdn.net/piaoranyuji/article/details/126122378" target="_blank" rel="noopener">https://blog.csdn.net/piaoranyuji/article/details/126122378</a></p>
<p><a href="https://blog.csdn.net/am_Sun/article/details/106374866" target="_blank" rel="noopener">https://blog.csdn.net/am_Sun/article/details/106374866</a><br>
Maven编译项目显示 程序包com.sun.*包不存在 【原因及三种解决方案】</p>
<p>IDEA 正常编译的项目，在生产环境 <code>mvn package</code> 报错</p>
<pre><code>[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.8.1:compile (default-compile) on project wxpaydemo: Compilation failure
[ERROR] /src/main/java/com/example/wxpaydemo/controller/TestController.java:[8,61] package com.sun.org.glassfish.external.statistics.annotations does not exist
</code></pre>
<p>解决：在 <code>maven-compiler-plugin</code>下 增加 <code>fork</code> 和 <code>compilerArgs</code></p>
<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.8.1&lt;/version&gt;
    &lt;configuration&gt;
        &lt;source&gt;1.8&lt;/source&gt;
        &lt;target&gt;1.8&lt;/target&gt;
        &lt;encoding&gt;UTF-8&lt;/encoding&gt;
        &lt;fork&gt;true&lt;/fork&gt;
        &lt;compilerArgs&gt;
            &lt;arg&gt;-XDignore.symbol.file&lt;/arg&gt;
        &lt;/compilerArgs&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>线上启动</p>
<pre><code>mvn clean package -Dmaven.test.skip=true
mkdir config
cp src/main/resources/application.yml ./config/
vi ./config/application.yml # 修改端口
    server:
      port: 8081        
java -jar target/wxpaydemo-0.0.1-SNAPSHOT.jar

# 修改代码或 resource 后要重新 mvn package 再启动 jar
mvn package &amp;&amp; java -jar target/wxpaydemo-0.0.1-SNAPSHOT.jar
</code></pre>
<p>MVCS - Model View Controller Service<br>
<a href="https://stackoverflow.com/questions/5702391/mvcs-model-view-controller-service" target="_blank" rel="noopener">https://stackoverflow.com/questions/5702391/mvcs-model-view-controller-service</a></p>
<p>一般而言，影响视频画质的因素主要有以下几点：</p>
<h3 id="硬件-2"><a class="header-anchor" href="#硬件-2">¶</a>硬件</h3>
<p>一块带给无数人年少欢乐的CPU，别说你没用过它<br>
<a href="https://zhuanlan.zhihu.com/p/415064726" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/415064726</a></p>
<p>《自己动手写CPU》读后感<br>
<a href="https://zhuanlan.zhihu.com/p/278434972" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/278434972</a></p>
<p>MIPS架构CPU设计<br>
<a href="https://gaozhiyuan.net/series/mips-cpu-design" target="_blank" rel="noopener">https://gaozhiyuan.net/series/mips-cpu-design</a></p>
<p>【手写CPU】7.9 除法指令说明及实现<br>
<a href="https://gaozhiyuan.net/computer/cpu/division-instruction-description-and-implementation.html" target="_blank" rel="noopener">https://gaozhiyuan.net/computer/cpu/division-instruction-description-and-implementation.html</a></p>
<p>半导体所用的高纯硅是如何提纯到 99.999999999% 的？<br>
<a href="https://www.zhihu.com/question/341011975" target="_blank" rel="noopener">https://www.zhihu.com/question/341011975</a></p>
<p>基础逻辑门<br>
<a href="https://vlab.ustc.edu.cn/guide/doc_basic_logic.html" target="_blank" rel="noopener">https://vlab.ustc.edu.cn/guide/doc_basic_logic.html</a><br>
Verilog语法<br>
<a href="https://vlab.ustc.edu.cn/guide/doc_verilog.html" target="_blank" rel="noopener">https://vlab.ustc.edu.cn/guide/doc_verilog.html</a></p>
<p>KiCad EDA<br>
A Cross Platform and Open Source Electronics Design Automation Suite<br>
<a href="https://www.kicad.org/" target="_blank" rel="noopener">https://www.kicad.org/</a></p>
<p>流片一次有多贵？<br>
<a href="http://news.sohu.com/a/564182392_121341339" target="_blank" rel="noopener">http://news.sohu.com/a/564182392_121341339</a></p>
<p>先引用CMP（Circuits Multi-Projets,美国一家非营利性多项目晶圆服务组织）的公开报价吧。<br>
按照这份报价，以业内裸芯（die）面积最小的处理器高通骁龙855为例（尺寸为8.48毫米×8.64毫米，面积为73.27平方毫米），用28纳米制程流片一次的标准价格为499,072.5欧元，也就是近400万元人民币！</p>
<p><a href="https://vlab.ustc.edu.cn/guide/index.html" target="_blank" rel="noopener">https://vlab.ustc.edu.cn/guide/index.html</a><br>
Logisim是一种用于设计和模拟数字逻辑电路的教育工具。</p>
<p>芯片设计之仿真工具<br>
<a href="https://www.elecfans.com/d/1876977.html" target="_blank" rel="noopener">https://www.elecfans.com/d/1876977.html</a></p>
<ul>
<li>在通过Verilog语言完成芯片设计，且通过测试平台设计（编写testbench）对所设计的芯片施加激励和观测输出后，需要在计算机上模拟芯片设计，以判断所编写的代码是否符合预期。</li>
<li>在计算机上模拟芯片设计需运用仿真工具，常用的EDA仿真工具主要由三家集成电路公司提供，分别是Mentor Graphics、Cadence、SYNOPSYS。</li>
</ul>
<p>仿真的步骤如下：</p>
<ul>
<li>设置环境。包括在软件里设置相应的工程环境，设置相应的库文件，库文件是其他人员已完成的设计文件，当设计芯片需要某些已设计完成的文件时，可以调用库文件。</li>
<li>编写Verilog代码。编写Verilog代码既可以使用文本编辑工具，也可以使用Modelsim中提供的代码编辑工具。</li>
<li>编译。编译的目标是将Verilog代码转化成计算机上可以执行的程序。</li>
<li>仿真。在仿真工具中模拟电路执行过程。</li>
<li>分析仿真结果。 分析仿真结果是比较重要的步骤。分析仿真结果的目的是检查电路模拟的结果是否正确，是否符合预期的设计目标。</li>
</ul>
<p>分析仿真结果的方法有多种：</p>
<ul>
<li>最直接的方法是用波形的方式检查，</li>
<li>更高层次的方法包括数据流图（以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程）</li>
<li>有限机（全称有限状态机，是一种用于进行对象行为建模的工具，作用是描述对象在其生命周期内所经历的状态序列，以及如何响应来自外界的各种事件）</li>
<li>或用比较高效的方法定位故障发生的位置。</li>
</ul>
<p>流程</p>
<ol>
<li>用 Verilog 语言设计电路</li>
<li>编写 Testbench 施加激励，观测输出</li>
<li>使用 Modelsim 做仿真</li>
<li>用 KiCad 画 pcb</li>
<li>去立创平台做流片</li>
</ol>
<p><a href="https://brng.dev/blog/technical/tutorial/2019/05/11/icarus_gtkwave/" target="_blank" rel="noopener">https://brng.dev/blog/technical/tutorial/2019/05/11/icarus_gtkwave/</a></p>
<ul>
<li>Icarus Verilog is a free Verilog simulator with some SystemVerilog support.</li>
<li>I personally enjoy using it because it’s really easy and quick to get it up and running.</li>
<li>Icarus Verilog compiles the Verilog source into a file that is executed by its simulator vvp.</li>
<li>GTKWave is a free waveform viewer, which is useful for debugging designs.</li>
</ul>
<p>Xilinx Vivado卡在Initializing Language Server的解决方法<br>
<a href="https://blog.csdn.net/yihuajack/article/details/120830612" target="_blank" rel="noopener">https://blog.csdn.net/yihuajack/article/details/120830612</a></p>
<p>打开 Tools -&gt; Settings -&gt; Tool Settings -&gt; Text Editor -&gt; Syntax Checking，将 Syntax checking 从 Sigasi 改为 Vivado：</p>
<p>【计算机组成原理】MIPS单周期CPU设计 | Verilog<br>
<a href="https://www.bilibili.com/video/BV1rD4y1D7h9" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1rD4y1D7h9</a><br>
<a href="https://github.com/qing-2/CPU" target="_blank" rel="noopener">https://github.com/qing-2/CPU</a></p>
<p><a href="http://buthowdoitknow.com/" target="_blank" rel="noopener">http://buthowdoitknow.com/</a><br>
But How Do It Know? is the book you have been looking for if you want to know how computers work.</p>
<ul>
<li>What is a bit?</li>
<li>What is a byte?</li>
<li>What is RAM?</li>
<li>What is a CPU?</li>
<li>What is a clock?</li>
<li>What is a computer?</li>
<li>What is a program?</li>
<li>How do the parts work together?</li>
<li>And much much more…</li>
</ul>
<p><a href="https://mcpedl.com/scott-cpu-map/" target="_blank" rel="noopener">https://mcpedl.com/scott-cpu-map/</a></p>
<ul>
<li>This is a fully functional 8Bit Computer in Minecraft Bedrock.</li>
<li>The design of the computer is based on the famous Scott CPU in the book But How Do It Know?</li>
<li>The Basic Principles of Computers for Everyone by J. Clark Scott. Give it a try!</li>
</ul>
<p>QEMU虚拟机相关概念介绍<br>
原文链接：<a href="https://blog.csdn.net/qq_34719392/article/details/125543643" target="_blank" rel="noopener">https://blog.csdn.net/qq_34719392/article/details/125543643</a></p>
<ul>
<li>Hypervisor介于虚拟机和宿主机操作系统之间，负责对宿主机资源（为方便表述，本文均以硬件资源为例，但实际上被虚拟化的不只有硬件资源）进行虚拟化，并将虚拟化后的硬件资源提供给虚拟机。Hypervisor分为两类：
<ul>
<li>Type-1 Hypervisor：位于操作系统内核空间，具备对宿主机硬件资源的直接访问权限。代表：Microsoft Hyper-V、Linux KVM、VMWare ESXi。</li>
<li>Type-2 Hypervisor：位于用户空间，需要通过操作系统内核才能访问硬件。代表：QEMU、Oracle VirtualBox。</li>
</ul>
</li>
<li>QEMU 有两种工作模式：
<ul>
<li>QEMU 本身作为 Hypervisor。QEMU 与Linux 内核交互，从而获取虚拟化后的硬件。这就是前文所述的 Type-2 Hypervisor。
<ul>
<li>交互层次：VM - QEMU - Linux Kernel - Driver - Hardware</li>
</ul>
</li>
<li>QEMU 作为虚拟机与 Linux KVM 交互的中间层，仅负责传递交互信息，而不发挥 Hypervisor 的实际功能。真正发挥 Hypervisor 功能的是 Linux KVM。
<ul>
<li>交互层次：VM - QEMU - Linux KVM - KVM Virtual Driver - Hardware</li>
</ul>
</li>
<li>第二种工作模式能够直接利用 KVM，因而效率更高。</li>
<li>而第一种工作模式多用于不需要和硬件直接交互的场合，例如在虚拟机中启动虚拟机。</li>
</ul>
</li>
<li>libvirtd、libvirt、virt-manager 的概念及与 QEMU 的关系
<ul>
<li>libvirtd 是 Linux 中的一个守护进程，其使用的是 libvirt 库。</li>
<li>libvirt 与 QEMU 的关系，类似于 Kubernetes 与 Docker 的关系：
<ul>
<li>QEMU 负责实际管理一台宿主机上的所有虚拟机；</li>
<li>而 libvirtd 适用于一台宿主机上启用多台虚拟机的场景，它提供了一系列在虚拟机之间进行资源调度的接口，这些接口底层仍然是以 QEMU 命令来实现的。</li>
</ul>
</li>
<li>virt-manager 是 libvirt 的图形化界面。
<ul>
<li>在 virt-manager 上的所有操作，都会被映射为 libvirt 命令；</li>
<li>libvirt 命令又会被映射为 QEMU 命令；</li>
<li>如果 QEMU 处于第二种工作模式，那么 QEMU 命令又会再次被映射为 KVM 命令。</li>
</ul>
</li>
<li>virt-manager、libvirt、QEMU 与 KVM 都属于 Hypervisor 层次。
<ul>
<li>前三者都处于用户空间，只有KVM处于内核空间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Vivado安装和使用<br>
<a href="https://vlab.ustc.edu.cn/guide/doc_vivado.html" target="_blank" rel="noopener">https://vlab.ustc.edu.cn/guide/doc_vivado.html</a></p>
<p>一个典型的设计流程包括创建 model，创建用户约束文件，创建 Vivado 项目，导入已创建的model，编译约束文件，选择性调试运行时的行为仿真，综合你的design，实现design，生成 bitstream 文件，最后将 bitstream 文件下载到硬件中，并确认硬件能否正确的实现功能。</p>
<p>如何快速掌握一款MCU，可以从这几方面入手<br>
<a href="https://mp.weixin.qq.com/s/YBP-bU3OfGqmSdniI-_3Tg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YBP-bU3OfGqmSdniI-_3Tg</a></p>
<p>中断嵌套</p>
<p>中断嵌套是指中断系统正在执行一个中断服务时，有另一个优先级更高的中断提出中断请求，这时会暂时终止当前正在执行的级别较低的中断源的服务程序，去处理级别更高的中断源，待处理完毕，再返回到被中断了的中断服务程序继续执行的过程。</p>
<p>mcu就是单片机的意思，而plc是可编程逻辑控制器，两者都是可编程的控制器件。<br>
<a href="https://www.sohu.com/a/569640464_120676425" target="_blank" rel="noopener">https://www.sohu.com/a/569640464_120676425</a></p>
<ul>
<li>PLC 就能够满足设备工业级要求，在抗干扰方面、输入和输出点可靠性方面更为优越，并采用可靠的组态方式，因此可靠性更高，而且通信方面有很多工业控制设备采用光纤以抗干扰。</li>
<li>PLC 等设备可采用整体式或者积木式，各个组件可以按需选用，并便于组态实现。各个工作站之间采用规范的总线通讯，这都是模块内置的，只需配置无须编写代码，简单可靠。</li>
<li>在工业环境下，传感器的输出多采用4~20mA、0~10V的形式，这与MCU常用的0~3.3V或者0~5V的AD模块不相符合，因此需要针对工业环境设计传感信号接收模块。</li>
<li>PLC 是基于 mcu 的产品，在 mcu 的基础上增加了模块化的开发。不用编写底层的代码，无须了解单片机的底层资源。</li>
<li>单片机开发需要从底层代码开始，需要用汇编或者C语言编写，其I/O接口、协议、读写时序、算法与数据结构都必须自己编写开发。</li>
</ul>
<p>如何正确的评测视频画质<br>
<a href="https://wangwei1237.github.io/2022/05/09/How-to-Assess-the-Video-Quality-Correctly/" target="_blank" rel="noopener">https://wangwei1237.github.io/2022/05/09/How-to-Assess-the-Video-Quality-Correctly/</a></p>
<ul>
<li>分辨率：图像中的像素数量，在特定尺寸下，分辨率越高，像素越多，显示的细节则更精细。[3]</li>
<li>帧率：一秒内显示的图像数量，电影的帧率一般是 24fps，标准电视的帧率通常是 30fps。[3:1]</li>
<li>亮度：可以显示的图像照明强度的范围，人眼能感知到的亮度范围在 10W 尼特左右。</li>
<li>位深：每个像素可以显示的颜色数量，位深度越大，可显示的颜色越多，从而渐变更平滑、更自然。[4]</li>
<li>色域：色域是某个特定的色彩的子集，用以表示可以显示的所有颜色的范围。色域一般使用 CIE 1931 色度图上的面积来表示，CIE 1931 曲线的边缘代表可见光光谱颜色的范围。[4:1]</li>
<li>码率：编码每秒视频需要的 bit 数量称之为码率（bitrate）。在一定条件下，码率会影响视频的质量，码率越低，压缩率越大，画质相对越差。当然，并非码率越高画质越好，在很多情况下，更高的码率带来的往往却只是带宽的浪费。[5]</li>
</ul>
<p>关于时钟与触发器的感想<br>
<a href="https://blog.csdn.net/weixin_30349597/article/details/96950680" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30349597/article/details/96950680</a></p>
<ul>
<li>时钟是时序电路的控制者” 这句话太经典了，可以说是FPGA设计的圣言。</li>
<li>FPGA的设计主要是以时序电路为主，因为组合逻辑电路再怎么复杂也变不出太多花样，理解起来也不没太多困难。 但是时序电路就不同了，它的所有动作都是在时钟一拍一拍的节奏下转变触发，可以说时钟就是整个电路的控制者，控制不好，电路功能就会混乱。</li>
<li>时序逻辑电路的时钟是控制时序逻辑电路状态转换的“发动机”，没有它时序逻辑电路就不能正常工作，因为时序逻辑电路主要是利用触发器存储电路的状态，而触发器状态变换需要时钟的上升或下降沿!由此可见时钟在时序电路中的核心作用!</li>
</ul>
<p>FPGA能代替CPU架构吗？<br>
<a href="https://www.cnblogs.com/alifpga/p/9503593.html" target="_blank" rel="noopener">https://www.cnblogs.com/alifpga/p/9503593.html</a></p>
<p>FPGA基础知识介绍<br>
<a href="https://vlab.ustc.edu.cn/guide/doc_fpga.html" target="_blank" rel="noopener">https://vlab.ustc.edu.cn/guide/doc_fpga.html</a></p>
<ul>
<li>FPGA（Field－Programmable Gate Array），即现场可编程门阵列。</li>
<li>它是作为专用集成电路（ASIC）领域中的一种半定制电路而出现的，既解决了定制电路的不足，又克服了原有可编程器件门电路数有限的缺点。</li>
<li>现如今的集成电路绝大部分采用 CMOS 工艺,基本结构是一个 N 沟道 MOS 管和一个 P 沟道 MOS 管。</li>
<li>NMOS 和 PMOS 可以认为是两种开关电路，两种电路均包含 G（栅极）、D（漏极）、S（源极）三个极。</li>
<li>一个 NMOS 和一个 PMOS 可构成一个 CMOS 反相器, 同理，可构成 CMOS 的与非门、或非门。</li>
<li>多个与非门可组成一个带有复位、置位功能的D触发器，而D触发器则是时序逻辑电路的最核心部件。</li>
<li>由此可知，通过非门、与非门、或非门的有序堆叠，可实现任意功能的数字电路。</li>
<li>如果有一款电路，其基本单元可配置成各种基本门，则其就具备了硬件编程能力。</li>
<li>FPGA就是这种芯片，它基于查找表（LUT：Look Up Table）技术的可编程逻辑器件。</li>
<li>通过配置，LUT 可实现与门、或门、与非门、或非门或者其他简单组合逻辑功能，其本质上就是 1bit 位宽的 RAM。</li>
<li>CPU 中拥有控制取指、译码等流程，具备处理各式各样千奇百怪的指令要求的能力。</li>
<li>相比之下 FPGA 只能根据一个固定的模式来处理输入的数据然后输出，这也是为什么 FPGA 经常被看作一种行家专属的架构。</li>
<li>不同于 CPU 的是，FPGA 和 GPU 内都有大量的计算单元，因此它们的计算能力都很强。在进行神经网络运算的时候，两者的速度会比 CPU 快很多。</li>
<li>但是 GPU 由于架构固定硬件原生支持的指令固定了，而 FPGA 则是可编程的。</li>
</ul>
<h3 id="mysql-6"><a class="header-anchor" href="#mysql-6">¶</a>mysql</h3>
<p>UTC 时间</p>
<pre><code>SET time_zone ='+8:00';

mysql&gt; select now(),CONVERT_TZ(NOW(), '+08:00', 'UTC') utc, UTC_TIMESTAMP(),UTC_DATE(),UTC_TIME();
+---------------------+---------------------+---------------------+------------+------------+
| now()               | utc                 | UTC_TIMESTAMP()     | UTC_DATE() | UTC_TIME() |
+---------------------+---------------------+---------------------+------------+------------+
| 2022-09-07 17:43:23 | 2022-09-07 09:43:23 | 2022-09-07 09:43:23 | 2022-09-07 | 09:43:23   |
+---------------------+---------------------+---------------------+------------+------------+
1 row in set (0.00 sec)
</code></pre>
<h3 id="code"><a class="header-anchor" href="#code">¶</a>code</h3>
<p>Feature Toggles (aka Feature Flags)<br>
<a href="https://martinfowler.com/articles/feature-toggles.html" target="_blank" rel="noopener">https://martinfowler.com/articles/feature-toggles.html</a></p>
<h3 id="docker"><a class="header-anchor" href="#docker">¶</a>docker</h3>
<p>修改一个容器开机自动启动</p>
<pre><code>docker update --restart=always c0d6948dae7a
</code></pre>
<h3 id="PHP-2"><a class="header-anchor" href="#PHP-2">¶</a>PHP</h3>
<p>config php slowlog</p>
<pre><code>touch /var/log/php8.1-slow.log
chmod o+w /var/log/php8.1-slow.log
vi /etc/php/8.1/fpm/pool.d/www.conf
slowlog = /var/log/php8.1-slow.log
request_slowlog_timeout = 5s
php-fpm8.1 -tt
systemctl status php8.1-fpm
systemctl restart php8.1-fpm
</code></pre>
<p>nginx 超时</p>
<pre><code>client_header_timeout 1000000;
client_body_timeout 1000000;
send_timeout 1000000;
fastcgi_read_timeout 1000000;
</code></pre>
<p>php-fpm 超时</p>
<pre><code>request_terminate_timeout = 5s
</code></pre>
<p>遇到如下错误</p>
<pre><code>2022/09/16 15:24:28 [crit] 3550790#3550790: *62 open() &quot;/var/lib/nginx/fastcgi/1/03/0000000031&quot; failed (13: Permission denied) while reading upstream, client: 122.5.23.146,
</code></pre>
<p>这样解决</p>
<pre><code>sudo chown -R www-data:www-data /var/lib/nginx
</code></pre>
<p>nginx</p>
<pre><code>location ~ \.php$ {
    include snippets/fastcgi-php.conf;
    fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
</code></pre>
<p>composer 安装</p>
<pre><code>curl -x 111.111.103.12:8080 ifconfig.me
composer config -l
composer config -g repo.packagist composer https://repo.packagist.org
sudo apt-get install php8.1-intl
HTTP_PROXY=http://111.111.103.12:8080  composer self-update
HTTP_PROXY=http://111.111.103.12:8080 composer -vvv install
sudo systemctl restart php8.1-fpm
</code></pre>
<p>composer install和update的使用经验<br>
<a href="https://blog.csdn.net/u012449363/article/details/90436769" target="_blank" rel="noopener">https://blog.csdn.net/u012449363/article/details/90436769</a></p>
<ul>
<li>composer install 是从 composer.lock 读取第三方组件及其版本，并将其安装到 vendor 目录下。
<ul>
<li>如果 composer.lock 文件不存在，则读取 composer.json 第三方组件及其版本，然后安装到 vendor 目录下。</li>
</ul>
</li>
<li>update是直接从 composer.json 获取第三方组件及其版本，然后更新 composer.lock 文件。
<ul>
<li>如果依赖的第三方组件有版本更新，update 会将最新的版本安装到 vendor 目录下，并更新 composer.lock。</li>
</ul>
</li>
<li>在生产环境下，直接使用 composer update 命令是有较大风险的。</li>
<li>比较推荐的做法，将composer.json 和 composer.lock 都加入到版本管理中
<ul>
<li>在开发过程中注意 composer.lock 中依赖版本的变化</li>
<li>每次上线打包使用 composer install，从 composer.lock 中获取依赖的第三方组件和版本。</li>
<li>如果需要更新第三方组件，执行 composer update 命令时，应该在后面追加有必要更新的组件库。</li>
</ul>
</li>
</ul>
<p>Get a stack trace of a running or hung PHP script<br>
<a href="https://stackoverflow.com/questions/14261821/get-a-stack-trace-of-a-running-or-hung-php-script" target="_blank" rel="noopener">https://stackoverflow.com/questions/14261821/get-a-stack-trace-of-a-running-or-hung-php-script</a></p>
<h2 id="前端-2"><a class="header-anchor" href="#前端-2">¶</a>前端</h2>
<p>coffee script, less<br>
<a href="https://coffeescript.org/" target="_blank" rel="noopener">https://coffeescript.org/</a><br>
<a href="https://lesscss.org/" target="_blank" rel="noopener">https://lesscss.org/</a></p>
<h2 id="go"><a class="header-anchor" href="#go">¶</a>go</h2>
<p>go runtime 简析<br>
<a href="https://zhuanlan.zhihu.com/p/111370792" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/111370792</a></p>
<h2 id="gdb-2"><a class="header-anchor" href="#gdb-2">¶</a>gdb</h2>
<p>用QEMU模拟调试裸机ARM64汇编，支持gdb单步调试<br>
<a href="https://blog.csdn.net/luteresa/article/details/119615923" target="_blank" rel="noopener">https://blog.csdn.net/luteresa/article/details/119615923</a></p>
<p>gdb调试的layout使用<br>
<a href="https://blog.csdn.net/zhangjs0322/article/details/10152279" target="_blank" rel="noopener">https://blog.csdn.net/zhangjs0322/article/details/10152279</a></p>
<p>远程调试内核：</p>
<pre><code>target remote localhost:1234
b start_kernel
c
layout src
</code></pre>
<p>基本命令</p>
<pre><code>layout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：
layout src：显示源代码窗口
layout asm：显示汇编窗口
layout regs：显示源代码/汇编和寄存器窗口
layout split：显示源代码和汇编窗口
layout next：显示下一个layout
layout prev：显示上一个layout
Ctrl + L：刷新窗口
Ctrl + x，再按1：单窗口模式，显示一个窗口
Ctrl + x，再按2：双窗口模式，显示两个窗口
Ctrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。

run（简写r）： 运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。
continue（简写c）：继续执行，到下一个断点处（或运行结束）
next（简写n）： 单步跟踪程序，当遇到函数调用时，直接调用，不进入此函数体；
step（简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的
until：运行程序直到退出循环体; / until+行号： 运行至某行
finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。
call 函数(参数)：调用“函数”，并传递“参数”，如：call gdb_test(55)
quit：简记为 q ，退出gdb
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-重新定义Hello-World" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/20/重新定义Hello-World/" class="article-date">
  	<time datetime="2022-08-20T03:26:14.000Z" itemprop="datePublished">2022-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/20/重新定义Hello-World/">重新定义Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目录</p>
<ul>
<li>原始的 Hello World 程序</li>
<li>配置开发环境</li>
<li>单元测试</li>
<li>代码实现</li>
<li>代码调试</li>
<li>安全测试 fuzz</li>
<li>性能测试</li>
<li>性能剖析</li>
<li>性能优化</li>
</ul>
<h3 id="原始的-Hello-World"><a class="header-anchor" href="#原始的-Hello-World">¶</a>原始的 Hello World</h3>
<p>原始的 Hello World 程序是 Brian Kernighan 和 Dennis Ritchie(K&amp;R) 在 1978 年为《The C Programming Language》一书写的例子，后来成为了所有程序员的入门必学的例子。</p>
<pre><code>#include &lt;stdio.h&gt;

main()
{
    printf(&quot;hello, world\n&quot;);
}
</code></pre>
<p>可以看到，这段代码和现在的 C 代码有很大的差别，main 函数没有参数也没有返回值，因为那会 C 语言的规范还没有确定，硬件也比较受限。而且原始的 hello world 程序全是小写，hello 后面有个逗号，但结尾没有句号，这应该是随手示例的。</p>
<p>要编译这段古老的代码，我们要使用 C90 标准：</p>
<pre><code>$ gcc -std=gnu90 k-r-hello-world.c
$ ./a.out
hello, world
</code></pre>
<p>参考链接：</p>
<ul>
<li><a href="https://riptutorial.com/c/example/3675/original--hello--world---in-k-r-c" target="_blank" rel="noopener">Original “Hello, World!” in K&amp;R C</a></li>
</ul>
<h3 id="配置开发环境"><a class="header-anchor" href="#配置开发环境">¶</a>配置开发环境</h3>
<p>工欲善其事必先利其器，假设我们使用 VIM 开发 C 语言，首先要在 <code>~/.vimrc</code> 里设置一些简单的配置:</p>
<pre><code>set nocp nu et ts=4 sw=4 sta hls si noeb vb t_vb=
autocmd FileType c nnoremap &lt;buffer&gt; &lt;F5&gt; :!gcc -g -Wall  % &amp;&amp; ./a.out&lt;CR&gt;
</code></pre>
<p>第一行是通用的设置，要使用 VIM 写代码我一般都会先设置它，就一行也很好好记</p>
<ul>
<li><code>nocp</code>: 让 VIM 不在兼容模式下运行</li>
<li><code>nu</code>: 显示行号</li>
<li><code>et</code>: expandtab 的缩写，表示输入 tab 时插入空格</li>
<li><code>ts=4</code>: tabstop 的缩写，输入 tab 插入 4 个空格</li>
<li><code>sw=4</code>: shiftwidth 缩写，用shift+&gt;&gt; 时调整缩进时移动 4 个空格</li>
<li><code>sta</code>: smarttab 的缩写，基于已有行的缩进来确定，在新行的开始位置</li>
<li><code>hls</code>: hlsearch 的缩写，高亮显示搜索的关键字</li>
<li><code>si</code>: smartindent 的缩写，每一行都和前一行有相同的缩进量</li>
<li><code>noeb</code> vb t_vb=: 关闭按错键时的响铃声和屏幕闪烁，否则太烦了</li>
</ul>
<p>第二行是设置当文件是 C 语言文件时，在正常模式下按 F5 键会编译和运行程序，相当于一个快速运行快捷键。</p>
<ul>
<li><code>-g</code> 是开启调试模式，会生成调试符号，出错时的错误信息能看到行号。</li>
<li><code>-Wall</code> 是开启所有警告，以最严格的模式来写代码，养成好的习惯。</li>
</ul>
<p>写一个新的 <code>hello-world.c</code> 再按 F5 试试：</p>
<pre><code>#include &lt;stdio.h&gt;

int main()
{
    printf(&quot;hello world.\n&quot;);
    return 0;
}
</code></pre>
<p>好了，现在我们就可以快乐的写代码了，如果你记不住 VIM 的配置，那可以简化一下：</p>
<pre><code>set nu et ts=4
</code></pre>
<p>然后新开一个窗口进行编译和测试</p>
<pre><code>gcc hello-world.c &amp;&amp; ./a.out
</code></pre>
<p>还有一个小技巧是写 C 代码的时候，有时候需要查看函数的帮助，可以将光标移动到函数上，按 <code>shit+k</code> 查看帮助，按 q 退出，这是 VIM 内置的。</p>
<p>一个好的开发工具往往会事半功倍，自己试一下在自己熟悉的编程工具里如何完成如下任务：</p>
<ul>
<li>跳转到上一次编辑的位置</li>
<li>跳转到一个函数的定义</li>
<li>查找函数的所有引用</li>
<li>跳到匹配括号的开始和结尾</li>
<li>快速注释和取消注释一行或多行</li>
</ul>
<h3 id="单元测试"><a class="header-anchor" href="#单元测试">¶</a>单元测试</h3>
<p>下面我们写一个有意义的程序，把一个路径和一个文件名连接在一起，比如把 <code>/tmp</code> 和 <code>girl.jpg</code> 连接在一起就是 <code>/tmp/girl.jpg</code>。</p>
<p>大家一定听过 TDD 测试驱动，就是写代码之前先写测试，但写测试前得先有测试框架，我们可以使用 CMocka，原因是简单够用，下面是安装过程：</p>
<pre><code>git clone --single-branch --depth 1 https://git.cryptomilk.org/projects/cmocka.git
cd cmocka
mkdir build &amp;&amp; cd build
cmake ..
make -j8
sudo make install
</code></pre>
<p>编写一个 <code>cmocka-test.c</code> 文件，测试下官方例子：</p>
<pre><code>#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdint.h&gt;
#include &lt;cmocka.h&gt;

/* A test case that does nothing and succeeds. */
static void null_test_success(void **state) {
    (void) state; /* unused */
}

int main(void) {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test(null_test_success),
    };

    return cmocka_run_group_tests(tests, NULL, NULL);
}
</code></pre>
<p>这时候按 F5 是无法编译了，大概会看到这样的错误：</p>
<pre><code>/tmp/cc1roVOc.o: In function `main':
cmocka-test.c:(.text+0x6f): undefined reference to `_cmocka_run_group_tests'
collect2: error: ld returned 1 exit status
</code></pre>
<p>这因为我们编译的时候没有链接 <code>cmocka</code> 的库，所以要修改下 <code>~/.vimrc</code> 的配置</p>
<pre><code>autocmd FileType c nnoremap &lt;buffer&gt; &lt;F5&gt; :!gcc -g -Wall %  -lcmocka &amp;&amp; ./a.out&lt;CR&gt;
</code></pre>
<p>这时候按 F5 应该能够看到单元测试的输出，可以看到运行了一个测试，并且通过了。</p>
<pre><code>[==========] tests: Running 1 test(s).
[ RUN      ] null_test_success
[       OK ] null_test_success
[==========] tests: 1 test(s) run.
[  PASSED  ] 1 test(s).
</code></pre>
<p>如果运行程序的时候报如下的错误：</p>
<pre><code>./a.out: error while loading shared libraries: libcmocka.so.0: cannot open shared object file: No such file or directory
</code></pre>
<p>这是因为运行时找不到动态链接库，我们要修改下环境变量来解决，在 shell 里修改 <code>LD_LIBRARY_PATH</code> 并重新用 VIM 打开代码运行：</p>
<pre><code>export LD_LIBRARY_PATH=/usr/local/lib/:$LD_LIBRARY_PATH
</code></pre>
<p>要永久修改共享库查找路径的话可以在 <code>/etc/ld.so.conf</code> 里指定。</p>
<p>好了，单元测试库是可以用了，我们就可以写代码了，写代码之前我们还要先定义接口，就是函数的签名，参数和返回值。<br>
本着接口和实现分离的原则，我们一般会把函数声明放到头文件里，新建一个 <code>join-path.h</code> 文件：</p>
<pre><code>int join_path(char *buf, int buflen, const char *base, const char *file);
</code></pre>
<p>我们做如下约定</p>
<ul>
<li>函数名是 <code>join_path</code></li>
<li><code>buf</code> 是拼接结果的缓冲区</li>
<li><code>buflen</code> 是缓冲区长度，防止拼接后缓冲区溢出</li>
<li><code>base</code> 是目录的路径，如 <code>/tmp</code></li>
<li><code>file</code> 是文件名，如 <code>girl.jpg</code></li>
<li>返回值为 int，0 表示成功，非 0 表示出错，一般 unix 下是这样约定的。</li>
</ul>
<p>新建代码实现文件 <code>join-path.c</code>，先写个空的实现函数，没有实际逻辑：</p>
<pre><code>#include &lt;stdio.h&gt;

int join_path(char *buf, int buflen, const char *base, const char *file) {
    return 0;
}
</code></pre>
<p>新建 <code>join-path-test.c</code> 文件来写测试代码</p>
<pre><code>#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdint.h&gt;
#include &lt;cmocka.h&gt;
#include &quot;join-path.h&quot;
#include &quot;join-path.c&quot;

static void join_test01(void **state) {
    char buf[100];
    int ret = join_path(buf, 100, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
    assert_int_equal(0, ret);
    assert_string_equal(&quot;/tmp/girl.jpg&quot;, buf);
}

int main(void) {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test(join_test01),
    };

    return cmocka_run_group_tests(tests, NULL, NULL);
}
</code></pre>
<p>大部分代码和 CMocka 的实例代码是一样的，不同的地方是：</p>
<ul>
<li>include 了被测代码的头文件和实现文件，因为我们是测试自己的代码，可以直接引入源码文件，这样 F5 就可以看到测试结果, 不需要修改链接选项。</li>
<li>定义了一个 join_test01 的函数，相当于第一个测试用例：
<ul>
<li>定义一个长度 为 100 个 buffer；</li>
<li>调用 join_path 函数；</li>
<li>断言函数返回 0；</li>
<li>断言缓冲区为预期的结果 <code>/tmp/girl.jpg</code>。</li>
</ul>
</li>
<li>在 main 函数里执行上面定义的测试。</li>
</ul>
<p>好了，接口声明，代码实现和第一个单元测试都有了，我们 F5 来运行测试，预期会失败，但我们后面再让他成功。</p>
<pre><code>[==========] tests: Running 1 test(s).
[ RUN      ] join_test01
111
[  ERROR   ] --- &quot;/tmp/girl.jpg&quot; != &quot;&quot;
[   LINE   ] --- join-path-test.c:13: error: Failure!
[  FAILED  ] join_test01
[==========] tests: 1 test(s) run.
[  PASSED  ] 0 test(s).
[  FAILED  ] tests: 1 test(s), listed below:
[  FAILED  ] join_test01

 1 FAILED TEST(S)
</code></pre>
<p>在 VIM 同时打开多个文件的话，可以按 <code>:bn</code> 和 <code>:bp</code> 进行切换，比如我们就打开了 3 个文件：<code>join-path.h</code>，<code>join-path.c</code> 和 <code>join-path-test.c</code>。</p>
<p>我们要对单元测试进行更多的熟悉，尝试做如下任务：</p>
<ul>
<li>了解更多的断言，如断言数组中包含指定元素；</li>
<li>在每个单元测试前面进行准备工作，后面做资源回收工作；</li>
<li>对被测函数依赖的函数进行 mock；</li>
<li>断言某个函数以指定的参数被调用；</li>
<li>临时屏蔽某个测试用例；</li>
<li>评估被测代码的测试覆盖率；</li>
</ul>
<h3 id="代码实现"><a class="header-anchor" href="#代码实现">¶</a>代码实现</h3>
<p>终于可以正式的开始写代码实现了，第一个可以想到的就是用 <code>snprintf</code> 函数实现：</p>
<pre><code>int join_path(char *buf, int buflen, const char *base, const char *file) {
    snprintf(buf, buflen, &quot;%s/%s&quot;, base, file);
    return 0;
}
</code></pre>
<p>F5 运行测试</p>
<pre><code>[==========] tests: Running 1 test(s).
[ RUN      ] join_test01
[       OK ] join_test01
[==========] tests: 1 test(s) run.
[  PASSED  ] 1 test(s).
</code></pre>
<p>妥了，测试通过了，喝杯咖啡奖励一下自己。接着做更多的测试，写第 2 个用例，并在 main 函数里增加一行以便测试它：</p>
<pre><code>static void join_test02(void **state) {
    char buf[3];
    int ret = join_path(buf, 3, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
    assert_int_equal(0, ret);
    assert_string_equal(&quot;/tmp/girl.jpg&quot;, buf);
}

int main(void) {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test(join_test01),
        cmocka_unit_test(join_test02),
    };

    return cmocka_run_group_tests(tests, NULL, NULL);
}
</code></pre>
<p>F5 测试，发现这次用例失败了：</p>
<pre><code>[==========] tests: Running 2 test(s).
[ RUN      ] join_test01
[       OK ] join_test01
[ RUN      ] join_test02
[  ERROR   ] --- &quot;/tmp/girl.jpg&quot; != &quot;/t&quot;
[   LINE   ] --- join-path-test.c:20: error: Failure!
[  FAILED  ] join_test02
[==========] tests: 2 test(s) run.
[  PASSED  ] 1 test(s).
[  FAILED  ] tests: 1 test(s), listed below:
[  FAILED  ] join_test02

 1 FAILED TEST(S)
</code></pre>
<p>因为这次的缓冲区长度我们故意给了 3 个，根本放不下拼接后的结果，所以我们预期这时候返回值不应该为 0 ，我们修改下测试用例:</p>
<pre><code>static void join_test02(void **state) {
    char buf[3];
    int ret = join_path(buf, 3, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
    assert_int_not_equal(0, ret);
}
</code></pre>
<p>这时候运行测试肯定还是失败，我们的主要工作流程就是：</p>
<ul>
<li>编写新的单元测试，默认执行会失败</li>
<li>修改代码，让失败的单元测试成功</li>
</ul>
<p>上面的用例失败，说明我们没有对参数做严格的检查，我们来完完善它：</p>
<pre><code>#include &lt;string.h&gt;

int join_path(char *buf, int buflen, const char *base, const char *file) {
    if (strlen(base)+strlen(file)+1+1&gt;buflen) return -1;
    snprintf(buf, buflen, &quot;%s/%s&quot;, base, file);
    return 0;
}
</code></pre>
<p>我们在 base 加上 file 再加上路径连接符 <code>/</code> 再加上 C 语言字符串终止符 <code>0</code> 的长度大于缓冲区长度时返回 -1。F5 测试：</p>
<pre><code>[==========] tests: Running 2 test(s).
[ RUN      ] join_test01
[       OK ] join_test01
[ RUN      ] join_test02
[       OK ] join_test02
[==========] tests: 2 test(s) run.
[  PASSED  ] 2 test(s).
</code></pre>
<p>妥了， 2 个测试用例成功了，但我们不能靠假设编程，每个参数都会有各种可能的值传进来，还有别的边界条件要测吗？想一想：</p>
<ul>
<li>如果参数 buf, base, file 有一个是 NULL 程序能否正常运行，应如何修复。</li>
<li>如果参数 buflen 是负数，程序能否正常运行，应如何修复。</li>
<li>如果参数 base 或 file 不是一个以 <code>\0</code> 结尾的字符串，会发生什么，应如何修复。</li>
<li>如何缓冲区的大小并没有 buflen 那么长，会发生什么，我们能修复吗？</li>
</ul>
<h3 id="代码调试"><a class="header-anchor" href="#代码调试">¶</a>代码调试</h3>
<p>写 C 程序最常遇到的错误是什么？那肯定是内存错误，因为 C 语言里内存都要手动管理，各种数组也没有越界检查，一不小心就会出现内存错误。</p>
<p>我们新建 <code>join-path-debug.c</code> 来学习如何调试代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;join-path.c&quot;
int main()
{
    char buf[3];
    join_path(buf, 100, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
    return 0;
}
</code></pre>
<p>手工编译并运行，直接报错了，类型是调用栈错误，也是一种典型的内存错误，其它常见的还有段错误等。</p>
<pre><code>$ gcc join-path-debug.c
$ ./a.out
*** stack smashing detected ***: &lt;unknown&gt; terminated
Aborted (core dumped)
</code></pre>
<p>如果我们的代码量很大，执行程序异常崩溃，我们如何定位原因呢？这就得用到 gdb 调试工具了。首先编译时要加 -g 参数</p>
<pre><code>gcc -g join-path-debug.c
</code></pre>
<p>然后用 gdb 来运行它：</p>
<pre><code>$ gdb ./a.out
GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1
Reading symbols from ./a.out...done.
</code></pre>
<p>输入 r 会运行程序，这里会看到遇到了内存错误，程序被终止了。</p>
<pre><code>(gdb) r
Starting program: a.out
*** stack smashing detected ***: &lt;unknown&gt; terminated

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
51      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
</code></pre>
<p>输入 bt 可以查看线程调用栈, 程序是被 libc 的栈检查机制终止的，最顶层的栈帧是 join-path-debug.c 的第 8 行 main 函数里引起的错误</p>
<pre><code>(gdb) bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
#1  0x00007ffff7a227f1 in __GI_abort () at abort.c:79
#2  0x00007ffff7a6b837 in __libc_message (entry=do_abort, fmt=fmt@entry=0x7ffff7b98869 &quot;*** %s ***: %s terminated\n&quot;) at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007ffff7b16b31 in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false, msg=msg@entry=0x7ffff7b98847 &quot;stack smashing detected&quot;) at fortify_fail.c:33
#4  0x00007ffff7b16af2 in __stack_chk_fail () at stack_chk_fail.c:29
#5  0x00005555555547cc in main () at join-path-debug.c:8
</code></pre>
<p>用 <code>f 5</code> 切换栈帧，并用 <code>l</code> 查看附近的代码</p>
<pre><code>(gdb) f 5
#5  0x00005555555547cc in main () at join-path-debug.c:8
8       }
(gdb) l
3       int main()
4       {
5           char buf[3];
6           join_path(buf, 100, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
7           return 0;
8       }
</code></pre>
<p>我们发现第 8 行代码并没有实际代码执行，怎么会出错呢，这其实是正常的。C 程序遇到的好多错误就是这样，出错的地点和引起错误的地点有可能离的很远，因为引起内存错误的代码可能执行了很久，才会被其它的代码使用这块内存的时候发现。</p>
<p>现在我们看到的例子是个特例，因为在第 8 行往上看一下就能找到问题：代码定义的缓冲区长度只有 3， 但给 join_path 传入的 buflen 参数是 100，所以 join_path 的参数检查并没有失败，这时候运行就会报错了。</p>
<p>那我们还有没有更可靠的方法来定位这种错误呢？有，那就是用 Address Sanitizer（Asan），这个工具已经集成到 gcc 里了，我们直接加几个参数就可以使用：</p>
<pre><code>$ gcc -g -Wall -fsanitize=address -fno-omit-frame-pointer join-path-debug.c
$ ./a.out
=================================================================
==13565==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff97c3b743 at pc 0x7fb8cbce4f09 bp 0x7fff97c3b5d0 sp 0x7fff97c3ad60
WRITE of size 14 at 0x7fff97c3b743 thread T0
    #0 0x7fb8cbce4f08 in __interceptor_vsnprintf (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xa0f08)
    #1 0x7fb8cbce5286 in snprintf (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xa1286)
    #2 0x55bb3a82cb80 in join_path join-path.c:6
    #3 0x55bb3a82cc2c in main join-path-debug.c:6
    #4 0x7fb8cb874c86 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21c86)
    #5 0x55bb3a82ca29 in _start (a.out+0xa29)

Address 0x7fff97c3b743 is located in stack of thread T0 at offset 35 in frame
    #0 0x55bb3a82cb9c in main join-path-debug.c:4

  This frame has 1 object(s):
    [32, 35) 'buf' &lt;== Memory access at offset 35 overflows this variable
</code></pre>
<p>这次妥了，直接定位到 join-path.c 的第 6 行触发了栈溢出，而且还显示这块内存是在 join-path-debug.c 的第4 行在栈上分配的，有了这些信息候再结合代码和调用栈就很容易定位错误了。</p>
<p>如果还是没有定位到错误，因为一些运行时的信息不确定，那可以继续用 gdb 来调试，去掉 asan 编译选项重新编译程序并用 gdb 启动</p>
<pre><code>$ gcc -g -Wall join-path-debug.c
$ gdb ./a.out
</code></pre>
<p>根据 asan 的信息，在 join-path.c 的第 6 行增加断点：</p>
<pre><code>(gdb) b join-path.c:6
Breakpoint 1 at 0x745: file join-path.c, line 6.
</code></pre>
<p>运行程序，可以看到在断点处停住了，可以很清楚的看到各个参数的值：</p>
<pre><code>(gdb) r
Starting program: a.out

Breakpoint 1, join_path (buf=0x7fffffffe385 &quot;\177&quot;, buflen=100, base=0x555555554863 &quot;/tmp&quot;,
    file=0x55555555485a &quot;girl.jpg&quot;) at join-path.c:6
6           snprintf(buf, buflen, &quot;%s/%s&quot;, base, file);
</code></pre>
<p>也可以用 p 命令查看具体某个变量的值</p>
<pre><code>(gdb) p base
$1 = 0x555555554863 &quot;/tmp&quot;
(gdb) p buflen
$2 = 100
(gdb) p file
$3 = 0x55555555485a &quot;girl.jpg&quot;
(gdb) p buf
$4 = 0x7fffffffe385 &quot;\177&quot;
</code></pre>
<p>这里看到 buflen 为 100，我们尝试跳到上一层堆栈找找有没有 buf 分配的代码：</p>
<pre><code>(gdb) bt
#0  join_path (buf=0x7fffffffe385 &quot;\177&quot;, buflen=100, base=0x555555554863 &quot;/tmp&quot;, file=0x55555555485a &quot;girl.jpg&quot;)
    at join-path.c:6
#1  0x00005555555547b3 in main () at join-path-debug.c:6
(gdb) f 1
#1  0x00005555555547b3 in main () at join-path-debug.c:6
6           join_path(buf, 100, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
(gdb) l
1       #include &lt;stdio.h&gt;
2       #include &quot;join-path.c&quot;
3       int main()
4       {
5           char buf[3];
6           join_path(buf, 100, &quot;/tmp&quot;, &quot;girl.jpg&quot;);
7           return 0;
8       }
</code></pre>
<p>这里定位到 join-path-debug.c 的第 5 行定义 buf 只有 3 个的长度，找到了问题的原因。</p>
<p>假如说是一个正在运行的进程突然崩溃了，我们如何来定位原因呢？这时候就要调试 core dump文件了，首先在服务器上要做一些设置允许程序崩溃是产生 dump 文件。</p>
<pre><code>sudo mkdir -p /data/coredump/
sudo chmod o+w /data/coredump
sudo bash -c 'echo /data/coredump/core.%e.%p&gt; /proc/sys/kernel/core_pattern'
ulimit -c unlimited
</code></pre>
<p>上面代码是让 core dump 文件保存在 <code>/data/coredump</code> 下，并且 dump 文件名称包含程序名称和进程 ID，然后设置 dump 文件大小为无限制。</p>
<p>直接运行代码，就会产生 core dump 了。</p>
<pre><code>$ ./a.out
*** stack smashing detected ***: &lt;unknown&gt; terminated
Aborted (core dumped)
$ ls /data/coredump/
core.a.out.14375
</code></pre>
<p>拿到 dump 文件后需要有原始的文件才能进行调试，先启动 gdb:</p>
<pre><code>$ gdb ./a.out
GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1
Reading symbols from ./a.out...done.
</code></pre>
<p>然后用 core-file 指令加载 core dump:</p>
<pre><code>(gdb) core-file /data/coredump/core.a.out.14375
[New LWP 14375]
Core was generated by `./a.out'.
Program terminated with signal SIGABRT, Aborted.
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
51      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
</code></pre>
<p>查看调用栈</p>
<pre><code>(gdb) bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
#1  0x00007fadd6b0f7f1 in __GI_abort () at abort.c:79
#2  0x00007fadd6b58837 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7fadd6c85869 &quot;*** %s ***: %s terminated\n&quot;) at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007fadd6c03b31 in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false, msg=msg@entry=0x7fadd6c85847 &quot;stack smashing detected&quot;) at fortify_fail.c:33
#4  0x00007fadd6c03af2 in __stack_chk_fail () at stack_chk_fail.c:29
#5  0x000055df3b1a47cc in main () at join-path-debug.c:8
</code></pre>
<p>live debug 能单步调试，设置断点等，但调试 core dump 基本上就是看一下调用栈，这是最重要的信息，一般也能够提供足够的线索来定位问题。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-202208" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/03/202208/" class="article-date">
  	<time datetime="2022-08-03T05:57:06.000Z" itemprop="datePublished">2022-08-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/03/202208/">202208</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="postgree-2"><a class="header-anchor" href="#postgree-2">¶</a>postgree</h3>
<p>How to copy with statement result to local in postgresql<br>
<a href="https://stackoverflow.com/questions/64438775/how-to-copy-with-statement-result-to-local-in-postgresql" target="_blank" rel="noopener">https://stackoverflow.com/questions/64438775/how-to-copy-with-statement-result-to-local-in-postgresql</a></p>
<pre><code>create temporary view data_to_export
as
with cte as (..)
select *
from cte
;

\copy (select * data_to_export) to ...
</code></pre>
<p>Postgres: return first N rows per group for groups having a minimum countI<br>
<a href="https://stackoverflow.com/questions/38589305/postgres-return-first-n-rows-per-group-for-groups-having-a-minimum-counti" target="_blank" rel="noopener">https://stackoverflow.com/questions/38589305/postgres-return-first-n-rows-per-group-for-groups-having-a-minimum-counti</a></p>
<pre><code>SELECT userid, createdat, displaydate
FROM (SELECT t.*,
             ROW_NUMBER() OVER (PARTITION BY userid ORDER BY createdat) as seqnum,
             COUNT(*) OVER (PARTITION BY userid) as cnt
      FROM data t
     ) x
WHERE x.seqnum &lt;= 100 AND x.cnt &gt; 100;
</code></pre>
<p>PostgreSQL操作JSON数据<br>
<a href="https://blog.csdn.net/qq_42715450/article/details/121350279" target="_blank" rel="noopener">https://blog.csdn.net/qq_42715450/article/details/121350279</a></p>
<pre><code> // -&gt; 返回json
 select '[{&quot;a&quot;:&quot;foo&quot;},{&quot;b&quot;:&quot;bar&quot;},{&quot;c&quot;:&quot;baz&quot;}]'::json-&gt;2 // 输出 {&quot;c&quot;:&quot;baz&quot;}
 select '{&quot;a&quot;: {&quot;b&quot;:&quot;foo&quot;}, &quot;c&quot;:{&quot;a&quot;: &quot;aaa&quot;}}'::json-&gt;'a' // 输出 {&quot;b&quot;:&quot;foo&quot;}

 // -&gt;&gt; 返回文本
 select '[{&quot;a&quot;:&quot;foo&quot;},{&quot;b&quot;:&quot;bar&quot;},{&quot;c&quot;:&quot;baz&quot;}]'::json-&gt;&gt;2 // 输出 {&quot;c&quot;:&quot;baz&quot;}
 select '{&quot;a&quot;: {&quot;b&quot;:&quot;foo&quot;}, &quot;c&quot;:{&quot;a&quot;: &quot;aaa&quot;}}'::json-&gt;&gt;'a' // 输出 {&quot;b&quot;:&quot;foo&quot;}

 // #&gt; 获取json子对象
 select '{&quot;a&quot;: {&quot;b&quot;:{&quot;c&quot;: &quot;foo&quot;}}}'::json#&gt; '{a,b}' // 输出 {&quot;c&quot;: &quot;foo&quot;}
 select '{&quot;a&quot;: {&quot;b&quot;:{&quot;c&quot;: &quot;foo&quot;}}}'::json#&gt;&gt; '{a,b}' // 输出 {&quot;c&quot;: &quot;foo&quot;}

 // @&gt; ———— 判断第一个json是否包含第二个
 select '{&quot;a&quot;:1, &quot;b&quot;:2}'::jsonb @&gt; '{&quot;b&quot;:2}'::jsonb   //输出t
 // &lt;@ ———— 判断第一个json是否在第一个中
 select '{&quot;b&quot;:2}'::jsonb &lt;@ '{&quot;a&quot;:1, &quot;b&quot;:2}'::jsonb   //输出t
</code></pre>
<p>PostgreSQL 安装<br>
<a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-20-04" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-20-04</a></p>
<pre><code>sudo apt install postgresql postgresql-contrib
sudo systemctl start postgresql.service
sudo -i -u postgres
psql

sudo -u postgres createuser --interactive
    mydb 
sudo -u postgres createdb mydb 
sudo adduser mydb 
sudo -u mydb psql
    \conninfo
    create schema mydb 
grep -n CREATE 1.sql
sed -n '1147637,1148637p' 1.sql  &gt; 5.sql
sudo -u mydb psql -d mydb -U mydb -f 5.sql
</code></pre>
<p>PostgreSQL查询当前执行中SQL的执行计划——pg_show_plans<br>
<a href="https://www.cnblogs.com/lovezhr/p/15180691.html" target="_blank" rel="noopener">https://www.cnblogs.com/lovezhr/p/15180691.html</a></p>
<ul>
<li>通常情况，我们可以通过explain、explain analyze、explain verbose来获取执行计划。</li>
<li>但是explain查询当前缓存的执行计划，在实际中估算的成本可能是不准确的，因为很可能估算的成本和实际运行的成本不一致。而explain analyze、explain verbose则会实际执行SQL，但在某些场景不会被允许执行。</li>
<li>可以尝试采用开启一个事务后，explain analyze、explain verbose查看执行计划，最后rollback。</li>
<li>pg_show_plans是一个显示当前运行的所有SQL语句执行计划的模块。</li>
</ul>
<h3 id="AI"><a class="header-anchor" href="#AI">¶</a>AI</h3>
<p>小波变换和傅里叶变换<br>
<a href="https://blog.csdn.net/qq_43528044/article/details/121533574" target="_blank" rel="noopener">https://blog.csdn.net/qq_43528044/article/details/121533574</a></p>
<ul>
<li>要讲小波变换，我们必须了解傅立叶变换。要了解傅立叶变换，我们先要弄清楚什么是”变换“。</li>
<li>很多处理，不管是压缩也好，滤波也好，图形处理也好，本质都是变换。变换的是什么东西呢?是基，也就是basis。</li>
<li>简单说，在线性代数里，basis 是指空间里一系列线性独立的向量，而这个空间里的任何其他向量，都可以由这些个向量的线性组合来表示。</li>
<li>小波指的是一种能量在时域非常集中的波，它的能量有限，都集中在某一点附近，而且积分的值为零，这说明它与傅里叶波一样是正交波。</li>
</ul>
<p>MediaPipe介绍<br>
<a href="https://blog.csdn.net/weixin_38346042/article/details/123399492" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38346042/article/details/123399492</a></p>
<ul>
<li>MediaPipe为我们日常使用的革命性产品和服务提供动力。与资源消耗型的机器学习框架不同，MediaPipe只需要最少的资源。</li>
<li>MediaPipe是一个用于构建机器学习管道的框架，用于处理视频、音频等时间序列数据。</li>
<li>Solutions是基于特定的预训练TensorFlow或TFLite模型的开源预构建示例：
<ul>
<li>人脸检测</li>
<li>Face Mesh</li>
<li>虹膜</li>
<li>手势</li>
<li>姿态</li>
<li>人体</li>
<li>人物分割</li>
<li>头发分割</li>
<li>目标检测</li>
<li>Box Tracking</li>
<li>Instant Motion Tracking</li>
<li>3D目标检测</li>
<li>特征匹配</li>
<li>AutoFlip</li>
<li>MediaSequence</li>
<li>YouTube-8M</li>
</ul>
</li>
<li>MediaPipe依赖OpenCV来处理视频，FFMPEG来处理音频数据。它还有其他依赖项，如OpenGL/Metal、Tensorflow、Eigen等。</li>
</ul>
<h3 id="javascript-函数时"><a class="header-anchor" href="#javascript-函数时">¶</a>javascript 函数时</h3>
<p>实现分组聚合</p>
<pre><code>&gt; var group_by_count = list =&gt; list.reduce((a, b) =&gt; (a[b] = a[b] ? a[b]+1 : 1,a) , {})
undefined
&gt; group_by_count([1,2,3,2,2,3])
{ '1': 1, '2': 3, '3': 2 }
&gt; group_by_count('aabbbcc'.split(''))
{ a: 2, b: 3, c: 2 }
&gt; var by_fun = x =&gt; x
undefined
&gt; by_fun(5)
5
&gt; var sum = list =&gt; list.reduce((r, x) =&gt; r+x, 0)
undefined
&gt; sum([1,2,3])
6
&gt; var avg = list =&gt; sum(list)/list.length
undefined
&gt; avg([1,2,3])
2
&gt; var group_by = (list, by) =&gt; list.reduce((r, x) =&gt; (k = by(x),r[k]||(r[k]=[]),r[k].push(x),r), {})
undefined
&gt; groups = group_by([1,2,3,2,2,3], x=&gt;x)
{ '1': [ 1 ], '2': [ 2, 2, 2 ], '3': [ 3, 3 ] }
&gt; var agg = (groups, fun) =&gt; Object.entries(groups).reduce((r, x) =&gt; (r[x[0]]=fun(x[1]),r), {})
undefined
&gt; agg(groups, sum)
{ '1': 1, '2': 6, '3': 6 }
&gt; by_a = x=&gt;x['a']
[Function: by_a]
&gt; sum_b = x=&gt;sum(x.map(y=&gt;y['b']))
[Function: sum_b]
&gt; var group_agg = (list, by_fun, agg_fun) =&gt; agg(group_by(list, by_fun), agg_fun)
undefined
&gt; group_agg([{a:1,b:2},{a:1,b:2},{a:2,b:3}], by_a, sum_b)
{ '1': 4, '2': 3 }
</code></pre>
<h3 id="Laravel"><a class="header-anchor" href="#Laravel">¶</a>Laravel</h3>
<p>Schedule</p>
<pre><code>$schedule-&gt;call(function () {
    Log::info('任务调度');
})-&gt;everyMinute();
-&gt;cron(‘* * * * *’); 在自定义Cron调度上运行任务

-&gt;everyMinute(); 每分钟运行一次任务
-&gt;everyFiveMinutes(); 每五分钟运行一次任务
-&gt;everyTenMinutes(); 每十分钟运行一次任务
-&gt;everyThirtyMinutes(); 每三十分钟运行一次任务
-&gt;hourly(); 每小时运行一次任务
-&gt;daily(); 每天凌晨零点运行任务
-&gt;dailyAt(‘13:00’); 每天13:00运行任务
-&gt;twiceDaily(1, 13); 每天1:00 &amp; 13:00运行任务
-&gt;weekly(); 每周运行一次任务
-&gt;monthly(); 每月运行一次任务
</code></pre>
<h3 id="C-语言"><a class="header-anchor" href="#C-语言">¶</a>C 语言</h3>
<p>请SSE/SSE2熟悉的前辈指点下指令，比较简单<br>
<a href="https://bbs.csdn.net/topics/391003443" target="_blank" rel="noopener">https://bbs.csdn.net/topics/391003443</a></p>
<ul>
<li>src/des 地址十六字节对齐</li>
<li>复制数据量 大于 512 bytes</li>
</ul>
<p>标准库的 memcpy 在满足这两个条件的情况下 会使用 sse 的 movdqa 来复制</p>
<p>TLB缓存是个神马鬼，如何查看TLB miss？<br>
<a href="https://zhuanlan.zhihu.com/p/79607142" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79607142</a></p>
<pre><code>perf stat -e dTLB-loads,dTLB-load-misses,iTLB-loads,iTLB-load-misses
</code></pre>
<p>How to increase performance of memcpy<br>
<a href="https://stackoverflow.com/questions/4260602/how-to-increase-performance-of-memcpy" target="_blank" rel="noopener">https://stackoverflow.com/questions/4260602/how-to-increase-performance-of-memcpy</a></p>
<p>you should have SSE or similar extensions enabled as the vector unit often can write 128 bits to the memory compared to 64 bits for the CPU. and make sure that both the source and destination is aligned to 128 bits. If your source and destination are not aligned respective to each other your memcpy() will have to do some serious magic. :)</p>
<p>First of all, you need to check that memory is aligned on 16 byte boundary, otherwise you get penalties. This is the most important thing.</p>
<p>rep movsb指令解析<br>
movsb指令用于把字节从ds:si 搬到es:di；rep是repeat的意思，rep movsb 就是多次搬运。搬运前先把字符串的长度存在cx寄存器中，然后重复的次数就是cx寄存器所存数据的值。</p>
<p>gcc 内联asm<br>
<a href="https://blog.csdn.net/farmwang/article/details/50153529" target="_blank" rel="noopener">https://blog.csdn.net/farmwang/article/details/50153529</a></p>
<pre><code>#include &lt;stdio.h&gt;  
  
int main()  
{  
    int a=1, b=2, c=0;  
  
    // 蛋疼的 add 操作  
    asm(  
        &quot;addl %2, %0&quot;       // 1  
        : &quot;=g&quot;(c)           // 2  
        : &quot;0&quot;(a), &quot;g&quot;(b)    // 3  
        : &quot;memory&quot;);        // 4  
  
    printf(&quot;现在c是:%d\n&quot;, c);  
    return 0;  
}  
</code></pre>
<p>软件架构设计 专栏<br>
<a href="https://www.zhihu.com/column/kls-software-arch-world" target="_blank" rel="noopener">https://www.zhihu.com/column/kls-software-arch-world</a></p>
<p>弟子规：美国军方禁止在C语言程序中使用malloc<br>
<a href="https://zhuanlan.zhihu.com/p/69365944" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69365944</a></p>
<p>多核MMU和ASID管理逻辑<br>
<a href="https://zhuanlan.zhihu.com/p/118244515" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/118244515</a></p>
<p>false sharing（伪共享） 及 c代码实现<br>
<a href="https://zhuanlan.zhihu.com/p/417325161" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/417325161</a></p>
<p>MESI协议将cache line的状态分成以下四种：</p>
<ul>
<li>Modified：当前CPU cache拥有最新数据，被修改过的（最新的cache line），其他CPU拥有失效数据（cache line的状态是Invalid），当被写回主存之后，该缓存行的状态会变成Exclusive状态，其他CPU必须在下次需要时从主存读取数据；</li>
<li>Exclusive：只有当前CPU中有数据，其他CPU中没有改数据，当前CPU的数据和主存中的数据是一致的，当有其他CPU读取该缓存行时，变为Shared；</li>
<li>Shared：当前CPU和其他CPU中都有共同数据，并且和主存中的数据一致，当一个CPU修改该缓存行时，其他CPU对应的缓存行数据变为Modified；</li>
<li>Invalid：当前CPU中的数据失效，数据应该从主存中获取，其他CPU中可能有数据也可能无数据，当前CPU中的数据和主存被认为是不一致的；</li>
</ul>
<p>memcpy() implementation<br>
<a href="https://codereview.stackexchange.com/questions/41094/memcpy-implementation" target="_blank" rel="noopener">https://codereview.stackexchange.com/questions/41094/memcpy-implementation</a></p>
<p>Very fast memcpy for image processing?<br>
<a href="https://stackoverflow.com/questions/1715224/very-fast-memcpy-for-image-processing/1715385#1715385" target="_blank" rel="noopener">https://stackoverflow.com/questions/1715224/very-fast-memcpy-for-image-processing/1715385#1715385</a></p>
<p>implicit declaration of function ‘gets’； did you mean ‘fgets’?<br>
c11下去除了gets函数，我们可以用fgets函数来代替。</p>
<p>Address Sanitizer 用法 asan<br>
<a href="https://www.jianshu.com/p/3a2df9b7c353" target="_blank" rel="noopener">https://www.jianshu.com/p/3a2df9b7c353</a></p>
<p>Implementing realloc in C<br>
<a href="https://codereview.stackexchange.com/questions/151019/implementing-realloc-in-c" target="_blank" rel="noopener">https://codereview.stackexchange.com/questions/151019/implementing-realloc-in-c</a></p>
<p>munmap_chunk(): invalid pointer<br>
<a href="https://stackoverflow.com/questions/32118545/munmap-chunk-invalid-pointer" target="_blank" rel="noopener">https://stackoverflow.com/questions/32118545/munmap-chunk-invalid-pointer</a></p>
<p>realloc() invalid old size<br>
<a href="https://stackoverflow.com/questions/24579698/realloc-invalid-old-size" target="_blank" rel="noopener">https://stackoverflow.com/questions/24579698/realloc-invalid-old-size</a></p>
<p>appending to a memory-mapped file<br>
<a href="https://stackoverflow.com/questions/4460507/appending-to-a-memory-mapped-file" target="_blank" rel="noopener">https://stackoverflow.com/questions/4460507/appending-to-a-memory-mapped-file</a></p>
<pre><code>void *new_mapping = mremap(mapping, size, size + GROWTH, MREMAP_MAYMOVE);
if (new_mapping == MAP_FAILED)
    // handle error
mapping = new_mapping;
</code></pre>
<p>How to get mmap’ed memory to sync to the file?<br>
<a href="https://stackoverflow.com/questions/16032396/how-to-get-mmaped-memory-to-sync-to-the-file" target="_blank" rel="noopener">https://stackoverflow.com/questions/16032396/how-to-get-mmaped-memory-to-sync-to-the-file</a></p>
<p>Also, you need to set the size of the file with ftruncate. Otherwise the mmaped area just covers parts of the file that don’t exist.</p>
<p>If you really want to make sure that the data ends up on disk, use msync, but normally you’ll be able to see the contents you wrote into the mmap:ed area immediately unless you’re on one of the few operating systems that doesn’t have a unified buffer and object cache.</p>
<p>Linux内存映射<br>
<a href="https://blog.csdn.net/qq_43334597/article/details/124306981" target="_blank" rel="noopener">https://blog.csdn.net/qq_43334597/article/details/124306981</a></p>
<p>按文件分：</p>
<ul>
<li>文件映射：将一个文件的一部分直接映射到调用进程的虚拟内存中</li>
<li>匿名映射：没有对应文件，被映射的分页会初始化为0</li>
</ul>
<p>按权限分：</p>
<ul>
<li>私有映射：写时复制，变更不会再底层文件进行</li>
<li>共享映射：变更发生在底层文件</li>
</ul>
<p>将上面两两组合：</p>
<ul>
<li>私有文件映射：使用一个文件的内容来初始化一块内存区域</li>
<li>私有匿名映射：为一个进程分配新的内存</li>
<li>共享文件映射：代替 read() 和 write() 、IPC</li>
<li>共享匿名映射：实现相关进程实现类似于共享内存</li>
</ul>
<p>进程执行 exec() 时映射会丢失，但通过 fork() 的子进程会继承映射</p>
<p>qsort doesn’t sort negative floats correctly<br>
<a href="https://github.com/emscripten-core/emscripten/issues/4204" target="_blank" rel="noopener">https://github.com/emscripten-core/emscripten/issues/4204</a></p>
<p>用库函数 qsort 对 float 数组进行排序的时候有 bug，不能写成</p>
<pre><code>return *(float*)a-*(float*)b
</code></pre>
<p>因为qsort对负的浮点数支持有问题，得写成</p>
<pre><code>if (a&gt;b) return 1;
if (a&lt;b) return -1;
return 0;
</code></pre>
<p>随机浮点数: <a href="https://stackoverflow.com/questions/13408990/how-to-generate-random-float-number-in-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/13408990/how-to-generate-random-float-number-in-c</a></p>
<pre><code>float float_rand( float min, float max )
{
    float scale = rand() / (float) RAND_MAX; /* [0, 1.0] */
    return min + scale * ( max - min );      /* [min, max] */
}
</code></pre>
<p>How do realloc and memcpy work?<br>
<a href="https://stackoverflow.com/questions/362760/how-do-realloc-and-memcpy-work" target="_blank" rel="noopener">https://stackoverflow.com/questions/362760/how-do-realloc-and-memcpy-work</a></p>
<p>The performance of memcpy can’t really be better than O(N) but it can be optimized so that it outperforms manual copying; for example, it might be able to copy 4 bytes in the time it takes you to copy 1 byte. Many memcpy implementations are written in assembly using optimized instructions that can copy multiple elements at a time which is usually faster than copying data one byte at a time.</p>
<p>C - split string into an array of strings<br>
<a href="https://stackoverflow.com/questions/11198604/c-split-string-into-an-array-of-strings" target="_blank" rel="noopener">https://stackoverflow.com/questions/11198604/c-split-string-into-an-array-of-strings</a></p>
<pre><code>char    str[]= &quot;ls -l&quot;;
char ** res  = NULL;
char *  p    = strtok (str, &quot; &quot;);
int n_spaces = 0, i;


/* split string and append tokens to 'res' */
while (p) {
  res = realloc (res, sizeof (char*) * ++n_spaces);
  if (res == NULL)
    exit (-1); /* memory allocation failed */
  res[n_spaces-1] = p;
  p = strtok (NULL, &quot; &quot;);
}

/* realloc one extra element for the last NULL */
res = realloc (res, sizeof (char*) * (n_spaces+1));
res[n_spaces] = 0;

/* print the result */
for (i = 0; i &lt; (n_spaces+1); ++i)
  printf (&quot;res[%d] = %s\n&quot;, i, res[i]);

/* free the memory allocated */
free (res);
</code></pre>
<p>Removing trailing newline character from fgets() input<br>
<a href="https://stackoverflow.com/questions/2693776/removing-trailing-newline-character-from-fgets-input" target="_blank" rel="noopener">https://stackoverflow.com/questions/2693776/removing-trailing-newline-character-from-fgets-input</a></p>
<pre><code>buffer[strcspn(buffer, &quot;\n&quot;)] = 0;
buffer[strcspn(buffer, &quot;\r\n&quot;)] = 0; // works for LF, CR, CRLF, LFCR, ...

line[strlen(line) - 1] = '\0';

char buffer[100];
if (fgets(buffer, sizeof buffer, stdin) != NULL) {
    size_t len = strlen(buffer);
    if (len &gt; 0 &amp;&amp; buffer[len-1] == '\n') {
        buffer[--len] = '\0';
    }
}
</code></pre>
<p>Trim a string in C [duplicate]<br>
<a href="https://stackoverflow.com/questions/656542/trim-a-string-in-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/656542/trim-a-string-in-c</a></p>
<pre><code>char *ltrim(char *s)
{
    while(isspace(*s)) s++;
    return s;
}

char *rtrim(char *s)
{
    char* back = s + strlen(s);
    while(isspace(*--back));
    *(back+1) = '\0';
    return s;
}

char *trim(char *s)
{
    return rtrim(ltrim(s));
}

// Note: This function returns a pointer to a substring of the original string.
// If the given string was allocated dynamically, the caller must not overwrite
// that pointer with the returned value, since the original pointer must be
// deallocated using the same allocator with which it was allocated.  The return
// value must NOT be deallocated using free() etc.
char *trimwhitespace(char *str)
{
  char *end;

  // Trim leading space
  while(isspace((unsigned char)*str)) str++;

  if(*str == 0)  // All spaces?
    return str;

  // Trim trailing space
  end = str + strlen(str) - 1;
  while(end &gt; str &amp;&amp; isspace((unsigned char)*end)) end--;

  // Write new null terminator character
  end[1] = '\0';

  return str;
}
</code></pre>
<p>C read file line by line<br>
<a href="https://stackoverflow.com/questions/3501338/c-read-file-line-by-line" target="_blank" rel="noopener">https://stackoverflow.com/questions/3501338/c-read-file-line-by-line</a></p>
<pre><code>#define _GNU_SOURCE

FILE * fp;
char * line = NULL;
size_t len = 0;
ssize_t read;
while ((read = getline(&amp;line, &amp;len, fp)) != -1) {
    printf(&quot;Retrieved line of length %zu:\n&quot;, read);
    printf(&quot;%s&quot;, line);
}
if (line) free(line);
</code></pre>
<h3 id="python-2"><a class="header-anchor" href="#python-2">¶</a>python</h3>
<p>基于pywebview的桌面小工具开发记录<br>
<a href="https://www.jianshu.com/p/3909e8b90c22" target="_blank" rel="noopener">https://www.jianshu.com/p/3909e8b90c22</a></p>
<p>史上最全面K近邻算法/KNN算法详解+python实现<br>
<a href="https://zhuanlan.zhihu.com/p/341572059" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/341572059</a></p>
<pre><code>def euc_dis(instance1, instance2):
    return np.sqrt(np.sum((instance1-instance2)**2))

def knn_classify(X, y, testInstance, k):
    dists=[euc_dis(x,testInstance) for x in X]
    idxknn= np.argsort(dists)[:k]
    yknn=y[idxknn]
    return Counter(yknn).most_common(1)[0][0]

predictions = [knn_classify(X_train, y_train, data, 3) for data in X_test]
correct = np.count_nonzero((predictions==y_test)==True)
print (&quot;Accuracy is: %.3f&quot; %(correct/len(X_test)))
</code></pre>
<p>如果选择较大K值，就相当于用较大邻域中的训练实例进行预测，其优点是可以减少学习的估计误差，但近似误差会增大，也就是对输入实例预测不准确，K值得增大就意味着整体模型变的简单</p>
<ul>
<li>近似误差：**可以理解为对现有训练集的训练误差。</li>
<li>估计误差：**可以理解为对测试集的测试误差。</li>
<li>近似误差关注训练集，如果k值小了会出现过拟合的现象，对现有的训练集能有很好的预测，但是对未知的测试样本将会出现较大偏差的预测。模型本身不是最接近最佳模型。</li>
<li>估计误差关注测试集，估计误差小了说明对未知数据的预测能力好。模型本身最接近最佳模型。</li>
</ul>
<p>鸢尾花(Iris)数据集<br>
<a href="https://blog.csdn.net/qinzhongyuan/article/details/106434854" target="_blank" rel="noopener">https://blog.csdn.net/qinzhongyuan/article/details/106434854</a></p>
<ul>
<li><a href="http://download.tensorflow.org/data/iris_training.csv" target="_blank" rel="noopener">http://download.tensorflow.org/data/iris_training.csv</a>
<ul>
<li>120条样本数据</li>
<li>花萼长度（Sepal Length）、花萼宽度（Sepal Width）、花瓣长度（Petal Length）、花瓣宽度（Petal Width）</li>
<li>标签0、1、2分别表示山鸢尾（Setosa）、变色鸢尾（Versicolor）、维吉尼亚鸢尾（Virginical）。</li>
</ul>
</li>
<li><a href="http://download.tensorflow.org/data/test.csv" target="_blank" rel="noopener">http://download.tensorflow.org/data/test.csv</a>
<ul>
<li>30条数据</li>
</ul>
</li>
</ul>
<h2 id="算法"><a class="header-anchor" href="#算法">¶</a>算法</h2>
<p>史上最强图解Treap总结， 不是浅谈！<br>
<a href="https://blog.csdn.net/simpsonk/article/details/72832959" target="_blank" rel="noopener">https://blog.csdn.net/simpsonk/article/details/72832959</a></p>
<p>树堆（Treap）图文详解与实现<br>
<a href="https://cloud.tencent.com/developer/article/1177129" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1177129</a></p>
<p>面试官问我：什么是树堆（Treap）？<br>
<a href="https://zhuanlan.zhihu.com/p/375122996" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/375122996</a></p>
<h3 id="gdb"><a class="header-anchor" href="#gdb">¶</a>gdb</h3>
<pre><code>gcc -g 051.c
gdb ./a.out
    r
</code></pre>
<h3 id="javascript"><a class="header-anchor" href="#javascript">¶</a>javascript</h3>
<p>使用 Service Workers<br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers</a></p>
<p>The difference between Service Workers, Web Workers and WebSockets<br>
<a href="https://aarontgrogg.com/blog/2015/07/20/the-difference-between-service-workers-web-workers-and-websockets/" target="_blank" rel="noopener">https://aarontgrogg.com/blog/2015/07/20/the-difference-between-service-workers-web-workers-and-websockets/</a></p>
<h3 id="linux"><a class="header-anchor" href="#linux">¶</a>linux</h3>
<p>聊聊CPU的LOCK指令<br>
<a href="https://mp.weixin.qq.com/s/8A4sas51tqMmpOwa7pCnJg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8A4sas51tqMmpOwa7pCnJg</a></p>
<p>计算机组成-无锁编程追求极致性能<br>
<a href="https://zhuanlan.zhihu.com/p/330476321" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/330476321</a></p>
<p>Cache和DMA一致性<br>
<a href="https://zhuanlan.zhihu.com/p/109919756" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/109919756</a></p>
<p>并发基础理论：缓存可见性、MESI协议、内存屏障、JMM<br>
<a href="https://zhuanlan.zhihu.com/p/84500221" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84500221</a></p>
<p>单片机入门之锁存器<br>
<a href="https://baijiahao.baidu.com/s?id=1725115907776029134&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1725115907776029134&amp;wfr=spider&amp;for=pc</a></p>
<ul>
<li>数字系统中，要经常用到能存储二进制信息（数字信息）的电路，而锁存器就具有这种功能。</li>
<li>双稳态电路的特点是具有两个稳定的状态，并且在外加触发信号的作用下，可以由一种稳定状态转换为另一种稳定状态。</li>
<li>锁存器基本特性：
<ul>
<li>它有两个稳定状态，可分别用来表示二进制数0和1；</li>
<li>在输入信号作用下锁存器的两个稳定状态可相互转换，输入信号消失后，已转换的稳定状态可长期保持（在通电状态下）。</li>
</ul>
</li>
<li>RS锁存器可以由两个与非门，或者两个或非门实现。</li>
<li>与非门的逻辑特点：全1输出0，有0输出1</li>
</ul>
<p>特殊用途寄存器，顾名思义是仅为一项任务而设计的寄存器。例如，cs，ds，gs 和其他段寄存器属于特殊目的寄存器，因为它们的存在是为了保存段号。 eax，ecx 等是一般用途的寄存器，因为你可以无限制地使用它们。 例如，你不能移动 ds，但是可以移动 eax，ebx。</p>
<ul>
<li>通用目的寄存器比如有：eax、ecx、edx、ebx、esi、edi、ebp、esp</li>
<li>特殊目的寄存器比如有：cs、ds、ss、es、fs、gs、eip、flag</li>
</ul>
<p>分享一些eBPF技术相关的PDF<br>
<a href="https://www.cnxct.com/ebpf-slide-pdf-share/" target="_blank" rel="noopener">https://www.cnxct.com/ebpf-slide-pdf-share/</a><br>
<a href="https://github.com/ehids/ebpf-slide" target="_blank" rel="noopener">https://github.com/ehids/ebpf-slide</a></p>
<p>linux下直接I/O（direct io）深入解析与实践<br>
<a href="http://t.zoukankan.com/zhjh256-p-12182523.html" target="_blank" rel="noopener">http://t.zoukankan.com/zhjh256-p-12182523.html</a></p>
<ul>
<li>默认情况下，linux会将进程未使用的内存用于页面缓存，因为相比直接读写磁盘而言，内存的性能高几个数量级，即使是SSD亦如此。</li>
<li>虽然页面缓存能够极大的提升性能，但是其不是没有缺点的，尤其是哪些只会读写一次或应用自身对数据进行了缓存的应用如oracle/mysql，如果全部os缓存，很可能会导致应用内存不足（特别是在应用不支持启动时lock memory或多应用环境下无法这么做时）。</li>
<li>如果没有缓存，随机直接（指的是4K/8K块）I/O的性能是非常低下的。大块（顺序I/O）则快得多。
<ul>
<li><code>echo 1 &gt; /proc/sys/vm/drop_caches</code> 清空缓存</li>
<li><code>dd if=/dev/zero of=./a.dat bs=4k count=1M oflag=direct</code> 小块io</li>
<li><code>dd if=/dev/zero of=./a.dat bs=1M count=4K oflag=direct</code> 大块 io</li>
<li><code>sar -r 3 1000</code> 监控内存变化</li>
</ul>
</li>
<li>nocache命令，能够使得cp/scp等命令在执行后立刻清理页面缓存。</li>
<li>可以通过 cgroup memcg 限制用户的使用量，但是因为 pagecache 是全局共享的（有可能是别的group申请的），所以 memcg 只能保证 rss+pagecache 不超过内存配额，不能单独限制每个 group 的 pagecache 用量，只是在内存不足时 pagecache 会被直接丢掉，虽然提供了 group 级别的统计功能，这样要精确隔离的话，就得为这些命令建立单独一个 cgroup。
<ul>
<li>从上可知 cgroup 也可以和 dd 一样，可以保证不额外占用 pagecache，即使是用来过渡，但 cgroup 一定要保证有 rss 和 anon 外有一定的最小额外内存，否则容易发生 OOM。</li>
</ul>
</li>
<li>nginx
<ul>
<li>增加 <code>directio 512k</code> 指令后，nginx 对于静态资源就会走直接 I/O 模式了，也只有增加了该指令才是真正的直接I/O。</li>
<li>sendfile（它调用的是系统调用 sendfile，但是 sendfile 默认情况下并不走 NOCACHE_IO 模式，所以仍然会走页面缓存。</li>
</ul>
</li>
<li>对于文件读写，curl 的 --no-buffer 选项好像并没有生效，这样要想实现低内存占用文件，就得使用 java nio 或 c direct io 自行实现。</li>
<li>java 虽然提供了大量的 I/O 接口，但是大部分上层接口都是基于文件系统缓存的。要操作底层就需要对 NIO 比较熟悉了，核心又是 DirectBuffer 和 ByteBuffer
<ul>
<li>java 原生并不支持O_DIRECT选项，这样有个缺点就是写大文件会占用pagecache、亦或性能受到影响，因为要每次映射一部分，</li>
</ul>
</li>
</ul>
<p>一些主要应用和命令对文件I/O的管理方式。</p>
<pre><code>应用	    默认模式（依赖OS或自身管理）	        相关控制参数
oracle	    sga控制	                                filesystemio_options
mysql	    buffer_pool控制	                        innodb_flush_log_at_trx_commit
mongodb	    依赖于操作系统	 
c	        通过 open 文件带上 O_DIRECT 参数，
            直接写到设备上。	 
java	    自己控制（文件读写除外），
            没有直接的参数控制	 
kafka	    scala写的，依赖于JVM，所以本质上也
            是自己控制，文件则依赖于OS	 
redis	    自己控制	                            maxmemory，提供了超过后的策略
zookeeper	跟kafka类似
</code></pre>
<p>cgroup</p>
<pre><code>yum install libcgroup
service cgconfig start
cgcreate -a uft_trade_mysql -gmemory:memcg
cd /cgroup/memory/memcg/
cat memory.limit_in_bytes
echo 1048576 &gt; memory.limit_in_bytes
echo $$ &gt; tasks
cp a.dat.new ~/a.dat  # 限额 1M 时内存不足被OOM kill Killed
</code></pre>
<p>nginx 中的直接 I/O：</p>
<pre><code>aio threads;
directio 512k;
output_buffers 1 8m;   # 其对性能会有高达10%的影响，用于设置从磁盘读取缓冲区响应的数量和大小。
</code></pre>
<p>TODO:</p>
<p>Linux 直接I/O 原理与实现<br>
<a href="https://blog.csdn.net/qq_40989769/article/details/110645449" target="_blank" rel="noopener">https://blog.csdn.net/qq_40989769/article/details/110645449</a><br>
Linux操作系统I/O机制原理与实现(图文详解)<br>
<a href="https://zhuanlan.zhihu.com/p/438526019" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/438526019</a><br>
Java-NIO之Channel（通道）<br>
<a href="https://blog.csdn.net/weixin_45566993/article/details/124096517" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45566993/article/details/124096517</a><br>
MMAP和DIRECT IO区别<br>
<a href="https://www.cnblogs.com/zhaoyl/p/5901680.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyl/p/5901680.html</a><br>
Java网络编程与NIO详解8：浅析mmap和Direct Buffer<br>
<a href="https://blog.csdn.net/AliCoder/article/details/103039202" target="_blank" rel="noopener">https://blog.csdn.net/AliCoder/article/details/103039202</a></p>
<p>文件系统性能对比：<a href="https://blog.csdn.net/linkyy5/article/details/125955196" target="_blank" rel="noopener">https://blog.csdn.net/linkyy5/article/details/125955196</a></p>
<ul>
<li>高并发读写：btrfs 最优，xfs 及 ext4 稍好，zfs 及 ntfs 最差。</li>
<li>随机读写：ntfs 最优，其余相差不大。</li>
<li>顺序读写：ntfs 最优，btrfs 最差，其余相差不大</li>
<li>顺序多文件写入：f2fs 最优，其余相差不大。</li>
<li>并发多文件写入：ext4 最优，ntfs 最差，zfs 较弱，其余相差不大。</li>
<li>顺序多文件写入不同子目录：f2fs 最优，其余相差不大。</li>
<li>多客户使用体验：xfs 最优，ntfs 最差，reiserFS 较弱，其余皆优秀。</li>
</ul>
<p>各个文件系统具有特性，且各有优缺点：</p>
<ul>
<li>btrfs 仍处于开发阶段，其 COW (Copy On Write) 机制使其对数据库的插入操作表现较差。</li>
<li>xfs 和 ext4 的综合素质优秀，特定能力上不会过于耀眼，但是对用户来说综合体验最佳。</li>
<li>f2fs 在多文件情境下表现出色。</li>
<li>reiserFS 即将被 reiser4 文件系统取代，综合性能大不及其它系统。</li>
<li>ntfs 在串行的工作模式下，其随机读写和顺序读写能力都极高；反之，其在高并发高压环境下表现不佳。</li>
</ul>
<p>许多文件系统并不一定专门为性能而生，它们都有自己的适用场景，每个文件系统都有其独特的设计初衷。例如：</p>
<ul>
<li>btrfs 和 zfs 都具有 COW(Copy On Write) 机制。COW 机制使得它们在进行修改操作时具有不俗的性能，但也带来了磁盘空间的浪费，并增加了读取时的消耗。</li>
<li>btrfs 和 zfs 都自带 raid 功能。在数据可用性有要求的情况下，相比其他的文件系统，它们能提供开箱即用的 raid 阵列能力。</li>
<li>btrfs 对所有数据都带有 checksum 机制，确保文件完整性。</li>
<li>xfs 具有动态 inode 分配能力，适合大文件分配。</li>
</ul>
<p>陈炽卉 AIX 性能管理与监控建议<br>
<a href="http://www.360doc.com/content/22/0629/22/2245786_1038015973.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/22/0629/22/2245786_1038015973.shtml</a></p>
<p>How to check disk I/O utilization per process?<br>
<a href="https://serverfault.com/questions/169676/how-to-check-disk-i-o-utilization-per-process" target="_blank" rel="noopener">https://serverfault.com/questions/169676/how-to-check-disk-i-o-utilization-per-process</a></p>
<pre><code>iotop
pidstat -dl 20
cut -d&quot; &quot; -f 1,2,42 /proc/[0-9]*/stat | sort -n -k +3

atop -a -w historical_everything.atop 10 1080 &amp;
atop -r historical_everything.atop

    t - move forward to the next data gathering (10 seconds)
    d - show the disk io oriented information per process
    D - sort the processes based on disk activity
    T - go backwards 1 data point (10 seconds probably)
    h - bring up help
    b - jump to a time (nearest prior datapoint) - e.g. b12:00 - only jumps forward
    1 - display per second instead of delta since last datapiont in the upper half of the display

sudo apt install blktrace
sudo btrace /dev/mapper/ubuntu--server--vg-root
date &gt;&gt;/tmp/wtf &amp;&amp; ps -eo &quot;cmd,pid,min_flt,maj_flt&quot; &gt;&gt;/tmp/wtf
</code></pre>
<p>Amazon MySQL RDS迁移到Amazon Aurora并要求最小停机时间<br>
<a href="https://aws.amazon.com/cn/blogs/china/every-scene-mysql-database-move-to-amazon-aurora/" target="_blank" rel="noopener">https://aws.amazon.com/cn/blogs/china/every-scene-mysql-database-move-to-amazon-aurora/</a></p>
<p>Perf with GUI<br>
<a href="https://oopsmonk.github.io/posts/2022-04-28-perf/" target="_blank" rel="noopener">https://oopsmonk.github.io/posts/2022-04-28-perf/</a><br>
<a href="https://github.com/KDAB/hotspot" target="_blank" rel="noopener">https://github.com/KDAB/hotspot</a></p>
<pre><code>perf stat -d ./a.out
</code></pre>
<p>View size of CPU cache through the command-line?<br>
<a href="https://askubuntu.com/questions/724449/view-size-of-cpu-cache-through-the-command-line" target="_blank" rel="noopener">https://askubuntu.com/questions/724449/view-size-of-cpu-cache-through-the-command-line</a></p>
<pre><code>lscpu | grep &quot;cache&quot;
getconf -a | grep CACHE
</code></pre>
<p>How to Use the time Command on Linux<br>
<a href="https://www.howtogeek.com/415977/how-to-use-the-time-command-on-linux/" target="_blank" rel="noopener">https://www.howtogeek.com/415977/how-to-use-the-time-command-on-linux/</a></p>
<p>Using a \ character before the command name is the same as using command before the command name.</p>
<pre><code>\time -f &quot;Program: %C\nTotal time: %E\nUser Mode (s) %U\nKernel Mode (s) %S\nCPU: %P&quot; sleep 1
</code></pre>
<h3 id="游戏"><a class="header-anchor" href="#游戏">¶</a>游戏</h3>
<ul>
<li>GBA
<ul>
<li>牧场物语：矿石镇的伙伴们</li>
<li>最终幻想Advance</li>
<li>恶魔城</li>
<li>塞尔达传说缩小帽</li>
<li>口袋妖怪
<ul>
<li>精灵宝可梦红宝石·蓝宝石（2002-11-21）</li>
<li>精灵宝可梦火红·叶绿（2004-01-29）</li>
<li>精灵宝可梦绿宝石（2004-09-16）</li>
<li>精灵宝可梦不可思议的迷宫：赤之救助队（2005-11-17）</li>
</ul>
</li>
<li>火焰纹章</li>
</ul>
</li>
</ul>
<p>马里奥大叔的所有资料<br>
<a href="http://www.youxi131.com/wlyx/125604.html" target="_blank" rel="noopener">http://www.youxi131.com/wlyx/125604.html</a></p>
<h3 id="PHP"><a class="header-anchor" href="#PHP">¶</a>PHP</h3>
<p>显示错误<br>
php -d display_errors=on artisan</p>
<h3 id="mysql-2"><a class="header-anchor" href="#mysql-2">¶</a>mysql</h3>
<p>查看 buffer pool</p>
<pre><code>select @@innodb_buffer_pool_size / pow(2,30) as gibibytes;
</code></pre>
<p>按条件修改列</p>
<pre><code>mysql&gt; create database test;
Query OK, 1 row affected (0.01 sec)

mysql&gt; use test;
Database changed
mysql&gt; create table t1(c varchar(4));
Query OK, 0 rows affected (0.05 sec)

mysql&gt; insert into t1 values (1),(2),(3);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; select * from t1;
+------+
| c    |
+------+
| 1    |
| 2    |
| 3    |
+------+
3 rows in set (0.00 sec)

mysql&gt; update t1 set c = case when c='1' then 'a' when c='2' then 'b' when c='3' then 'c' else c end;
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0

mysql&gt; select * from t1;
+------+
| c    |
+------+
| a    |
| b    |
| c    |
+------+
3 rows in set (0.00 sec)
</code></pre>
<h3 id="VIM"><a class="header-anchor" href="#VIM">¶</a>VIM</h3>
<p>vim 里的正则搜索，有特殊的语法+要转义</p>
<pre><code>/^[0-9]\+,[^,]\+\n
</code></pre>
<p>How do I jump to the location of my last edit?<br>
<a href="https://vi.stackexchange.com/questions/2001/how-do-i-jump-to-the-location-of-my-last-edit" target="_blank" rel="noopener">https://vi.stackexchange.com/questions/2001/how-do-i-jump-to-the-location-of-my-last-edit</a></p>
<pre><code>`.
g, g;
ctrl+O ctrl+I
</code></pre>
<p>跳转指令</p>
<pre><code>% 跳转到相配对的括号
gD 跳转到局部变量的定义处
'' 跳转到光标上次停靠的地方, 是两个', 而不是一个&quot;
mx 设置书签,x只能是a-z的26个字母
`x 跳转到书签处(&quot;`&quot;是1左边的键)
&gt; 增加缩进,&quot;x&gt;&quot;表示增加以下x行的缩进
&lt; 减少缩进,&quot;x&lt;&quot;表示减少以下x行的缩进

{ 跳到上一段的开头
} 跳到下一段的的开头
( 移到这个句子的开头
) 移到下一个句子的开头

[[ 跳转至上一个函数(要求代码块中'{'必须单独占一行)
]] 跳转至下一个函数(要求代码块中'{'必须单独占一行)

C-] 跳转至函数或变量定义处
C-O 返回跳转前位置
C-T 同上
nC-T 返回跳转 n 次

0 数字0,跳转至行首
^ 跳转至行第一个非空字符
$ 跳转至行尾
</code></pre>
<h3 id="python-3"><a class="header-anchor" href="#python-3">¶</a>python</h3>
<p>Invalid control character with Python json.loads<br>
<a href="https://stackoverflow.com/questions/22394235/invalid-control-character-with-python-json-loads" target="_blank" rel="noopener">https://stackoverflow.com/questions/22394235/invalid-control-character-with-python-json-loads</a></p>
<pre><code>json_str = json.loads(jsonString, strict=False)
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-202207" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/07/01/202207/" class="article-date">
  	<time datetime="2022-07-01T10:51:43.000Z" itemprop="datePublished">2022-07-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/01/202207/">202207</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>机构是如何评价基金经理的？<br>
<a href="https://zhuanlan.zhihu.com/p/67250336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/67250336</a></p>
<p>如何评价基金经理及基金的选择？<br>
<a href="https://www.zhihu.com/question/22771562" target="_blank" rel="noopener">https://www.zhihu.com/question/22771562</a></p>
<h2 id="python"><a class="header-anchor" href="#python">¶</a>python</h2>
<p>lxml 使用<br>
<a href="https://blog.csdn.net/ydw_ydw/article/details/82227699" target="_blank" rel="noopener">https://blog.csdn.net/ydw_ydw/article/details/82227699</a></p>
<pre><code>from lxml import etree
html = etree.HTML(text)
for n in html.xpath('//h3[@class=&quot;text-heading css-1a2yizx&quot;]'):
    print(n.text)
    for n2 in n.getnext().findall('li[@data-cy=&quot;browse-list-link&quot;]/a'):
        print('\t%s' % (n2.text))
</code></pre>
<p>金融评测指标empyrical库详解Sortino、calmar、omega、sharpe、annual_return、max_drawdown<br>
<a href="https://dev-docs.csdn.net/articles/c9ab471ae39247efa635f52081d88796/sharpe-sortino-omega-calmar-empyrical" target="_blank" rel="noopener">https://dev-docs.csdn.net/articles/c9ab471ae39247efa635f52081d88796/sharpe-sortino-omega-calmar-empyrical</a></p>
<p>国内装 virtual-env 报错</p>
<pre><code>$ pip install virtual-env
Looking in indexes: http://mirrors.tencentyun.com/pypi/simple
ERROR: Could not find a version that satisfies the requirement virtual-env (from versions: none)
ERROR: No matching distribution found for virtual-env
</code></pre>
<p>如下可解决</p>
<pre><code>pip install virtualenv -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com
</code></pre>
<p>将matplotlib绘制的图形直接以base64格式传递到html使用<br>
<a href="https://www.jianshu.com/p/f3ea49e05600" target="_blank" rel="noopener">https://www.jianshu.com/p/f3ea49e05600</a></p>
<pre><code>from io import BytesIO
import base64
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(100)
y = np.sin(x)

fig = plt.figure()
ax = fig.add_subplot(111)
ax.plot(x,y)

# 写入内存
save_file = BytesIo()
plt.savefig(save_file, format='png')

# 转换base64并以utf8格式输出
save_file_base64 = base64.b64encode(save_file.getvalue()).decode('utf8')
</code></pre>
<h2 id="vim"><a class="header-anchor" href="#vim">¶</a>vim</h2>
<p>vim 最精简配置</p>
<pre><code>set nocp nu ts=4 sw=4 et sta hls si noeb vb t_vb=
</code></pre>
<h2 id="tmux"><a class="header-anchor" href="#tmux">¶</a>tmux</h2>
<pre><code>sudo apt-get install tmux
$ vim ~/.tmux.conf
    set-option -g mouse on

ctrl+b d
ctrl+b %
ctrl+b &quot;
ctrl+b alt+left
tmux -ls
tmux tmux attach -t 0
</code></pre>
<p>tmux的复制粘贴</p>
<pre><code>1. C-b [ 进入复制模式
2. 参考上表移动鼠标到要复制的区域，移动鼠标时可用vim的搜索功能&quot;/&quot;,&quot;?&quot;
3. 安空格键开始选择复制区域
4. 选择完成后安enter键退出
5. C-b ] 粘贴
</code></pre>
<h2 id="postgree"><a class="header-anchor" href="#postgree">¶</a>postgree</h2>
<p>取消分页</p>
<pre><code>\pset pager off
</code></pre>
<p>显示边框</p>
<pre><code>\pset linestyle ascii
\pset border 2
SELECT * FROM Pets;
</code></pre>
<p>sql split string by space into table in postgresql<br>
<a href="https://stackoverflow.com/questions/1986491/sql-split-string-by-space-into-table-in-postgresql" target="_blank" rel="noopener">https://stackoverflow.com/questions/1986491/sql-split-string-by-space-into-table-in-postgresql</a></p>
<pre><code>select unnest(string_to_array('the quick lazy fox', ' '));
</code></pre>
<p>Word frequencies from strings in Postgres?<br>
<a href="https://stackoverflow.com/questions/5226202/word-frequencies-from-strings-in-postgres" target="_blank" rel="noopener">https://stackoverflow.com/questions/5226202/word-frequencies-from-strings-in-postgres</a></p>
<p>postgresql 数组类型<br>
<a href="https://www.jb51.cc/postgresql/194660.html" target="_blank" rel="noopener">https://www.jb51.cc/postgresql/194660.html</a></p>
<p>用 python 写 postgree 自定义函数<br>
<a href="https://www.postgresql.org/docs/current/plpython-funcs.html" target="_blank" rel="noopener">https://www.postgresql.org/docs/current/plpython-funcs.html</a></p>
<pre><code># CREATE EXTENSION plpythonu;
CREATE EXTENSION

# CREATE OR REPLACE FUNCTION pysplit(s text)
#   RETURNS text
# AS $$
#   words = s.split()
#   return '|'.join([words[i]+' '+words[i+1] for i in range(len(words)-1)])
# $$ LANGUAGE plpythonu;
CREATE FUNCTION

# select regexp_split_to_table(pysplit('a b c d'), '\|');
 regexp_split_to_table
-----------------------
 a b
 b c
 c d
(3 rows)
</code></pre>
<p>PostgreSQL-触发器<br>
<a href="http://www.manongjc.com/detail/29-qzkmtgoohzmphaz.html" target="_blank" rel="noopener">http://www.manongjc.com/detail/29-qzkmtgoohzmphaz.html</a></p>
<p>触发器函数中的特殊变量</p>
<ul>
<li>NEW：该变量为 INSERT/UPDATE 操作触发的行级触发器中存储的新的数据行，数据类型是 RECORD。 在语句级别的触发器里此变量没有分配，DELETE 操作触发的行级触发器中此变量也没有分配。</li>
<li>OLD：该变量为 UPDATE/DELETE 操作触发的行级触发器中存储的旧数据行，数据类型是 RECORD。 在语句级别的触发器里此变量没有分配， INSERT 操作触发的行级触发器中此变量也没有分配。</li>
<li>TG_NAME：数据类型是 name，该变量包含实际触发的触发器名。</li>
<li>TG_OP: 内容为 INSERT、UPDATE、DELETE、TRUNCATE 之一的字符串，用于指定 DML 语句的类型。</li>
<li>TG_TABLE_NAME: 触发器所在表的名称。</li>
</ul>
<p>PostgreSQL 触发器<br>
<a href="https://blog.csdn.net/pg_hgdb/article/details/121560616" target="_blank" rel="noopener">https://blog.csdn.net/pg_hgdb/article/details/121560616</a></p>
<pre><code># CREATE TABLE AUDIT(
EMP_ID INT NOT NULL,
ENTRY_DATE TEXT NOT NULL);

# CREATE TRIGGER example_trigger AFTER INSERT ON COMPANY FOR EACH ROW EXECUTE PROCEDURE auditlogfunc();

CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, current_timestamp);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 列出所有触发器 
SELECT * FROM pg_trigger;

-- 查看特定表的触发器
SELECT tgname FROM pg_trigger, pg_class WHERE tgrelid=pg_class.oid AND relname='company';

-- 删除触发器
drop trigger example_trigger on company;
</code></pre>
<p>postgres 自增序列<br>
<a href="https://blog.csdn.net/m0_37664223/article/details/90052783" target="_blank" rel="noopener">https://blog.csdn.net/m0_37664223/article/details/90052783</a></p>
<pre><code>-- 查找 xxx 自增序列的当前值
select currval('xxx');
-- 查找 xxx 自增序列的下一个值
select nextval('xxx');
-- 创建 xxx 自增序列
CREATE SEQUENCE xxx
    INCREMENT 1    序列增长步值
    MINVALUE 1   最小值
    MAXVALUE 9999999999    最大值
    START 1  开始值
    CACHE 1  缓存值，会在cache中预存序列值，如果数据库异常关闭，序列值会丢失
    CYCLE;   循环，表示到最大值后从头开始

-- 修改 xxx 自增序列，除了 start 之外的其他值都可以修改
ALTER SEQUENCE xxx
    INCREMENT 10 
    MAXVALUE 100000000 
    CYCLE 
    NOCACHE ; 

----删除前先解除某个字段，例如表名是 student, name 字段对该序列的(序列名字是 name_seq)依赖
ALTER TABLE student ALTER COLUMN name SET DEFAULT null;

DROP SEQUENCE IF EXISTS &quot;name_seq&quot;;

---- start_id 即 id 目前的最大值，可写为 1，
CREATE SEQUENCE &quot;name_seq&quot; START WITH start_id;
ALTER TABLE student ALTER COLUMN name SET DEFAULT nextval('name_seq'::regclass);

-- 设置自增长从当前最大值开始
select setval('seq', (select max(name) from &quot;student&quot;));

-- 重置自增字段为1
ALTER SEQUENCE seq RESTART WITH 1;
</code></pre>
<p>Postgresql 创建主键并设置自动递增的三种方法<br>
<a href="https://blog.csdn.net/songchunyi/article/details/7711108" target="_blank" rel="noopener">https://blog.csdn.net/songchunyi/article/details/7711108</a></p>
<pre><code>create table test_b
(
  id serial PRIMARY KEY,
  name character varying(128)
);

create table test_c 
(
  id integer PRIMARY KEY,
  name character varying(128)
);  
CREATE SEQUENCE test_c_id_seq
START WITH 1
INCREMENT BY 1
NO MINVALUE
NO MAXVALUE
CACHE 1;
alter table test_c alter column id set default nextval('test_c_id_seq');
</code></pre>
<p>创建索引</p>
<pre><code>CREATE INDEX index_moni_gk_city_day ON moni_gk_city_day USING btree (datatime, citycode);
</code></pre>
<p>删除索引</p>
<pre><code>drop index tab1_bill_code_index  ;
</code></pre>
<h2 id="mysql"><a class="header-anchor" href="#mysql">¶</a>mysql</h2>
<p>ip is blocked because of many connection errors 错误<br>
<a href="https://debugah.com/host-blocked-because-of-many-connection-errors-how-to-solve-10147/" target="_blank" rel="noopener">https://debugah.com/host-blocked-because-of-many-connection-errors-how-to-solve-10147/</a></p>
<p>当客户端连接服务端超时(超过connect_timeout), 服务端就会给这个客户端记录一次error，当出错的次数达到max_connect_errors的时候，这个客户端就会被锁定。所以根据业务来尽量把这个值设置大一点，mysql默认值为10，我们可以根据具体需要设置大一点，这里设置为1000.（并非越大越好，越大被攻击时安全性越低）。<br>
配置有master/slave主从数据库的要把主库和从库都修改一遍。</p>
<pre><code>show status like  'Threads%';
SHOW VARIABLES LIKE '%error%';
SHOW VARIABLES LIKE '%wait_timeout%';
set global max_connect_errors = 1000;
flush hosts;
</code></pre>
<p>The value of the max_connection_errors system variable determines how many successive interrupted connection requests are permitted to myqsl server.</p>
<p>选取部分数据到新表</p>
<pre><code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ;
create table temp_temp as SELECT * FROM TABLE_NAME where a = 1;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ ;
</code></pre>
<p>Any way to select without causing locking in MySQL?<br>
<a href="https://stackoverflow.com/questions/917640/any-way-to-select-without-causing-locking-in-mysql" target="_blank" rel="noopener">https://stackoverflow.com/questions/917640/any-way-to-select-without-causing-locking-in-mysql</a></p>
<pre><code>SELECT * FROM TABLE_NAME WITH (nolock)

SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ;
SELECT * FROM TABLE_NAME ;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ ;

SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ;
SELECT * FROM TABLE_NAME ;
COMMIT ;
</code></pre>
<p>mysql 出现  unblock with ‘mysqladmin flush-hosts’<br>
<a href="https://wenku.baidu.com/view/0e7f56b268ec0975f46527d3240c844769eaa034.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/0e7f56b268ec0975f46527d3240c844769eaa034.html</a></p>
<pre><code>show variables like '%max_connect_errors%'; 
set global max_connect_errors = 100; 

flush hosts;

# vi /etc/my.cnf
max_connect_errors = 100
</code></pre>
<h2 id="nginx"><a class="header-anchor" href="#nginx">¶</a>nginx</h2>
<p>Nginx proxy_pass DNS Cache<br>
<a href="https://www.nadeau.io/post/nginx-proxy_pass-dns-cache/" target="_blank" rel="noopener">https://www.nadeau.io/post/nginx-proxy_pass-dns-cache/</a></p>
<p>After some debugging, I finally discovered that the IP address nginx was hitting was different from the one that DNS was returning. It turns out that nginx resolves hostnames only once on load, meaning whatever IP address it got on load would stick around until reload.</p>
<pre><code>server {
  listen 80;
  server_name files.example.com;

  // or use whatever resolver your machine is set to use
  resolver 8.8.8.8;

  set $proxy_pass_url http://example.s3.amazonaws.com;

  location / {
    proxy_pass $proxy_pass_url;
  }
}
</code></pre>
<p>nginx proxy_pass 后面是域名的时候，它会只解析一次 ip，然后缓存起来。</p>
<h2 id="shell"><a class="header-anchor" href="#shell">¶</a>shell</h2>
<p>ip 地址库：</p>
<ul>
<li><a href="https://github.com/mbcc2006/GeoLiteCity-data" target="_blank" rel="noopener">https://github.com/mbcc2006/GeoLiteCity-data</a></li>
<li><a href="https://www.miyuru.lk/geoiplegacy" target="_blank" rel="noopener">https://www.miyuru.lk/geoiplegacy</a></li>
</ul>
<p>命令行查询 ip 的所在地<br>
<a href="https://www.maketecheasier.com/ip-address-geolocation-lookups-linux/" target="_blank" rel="noopener">https://www.maketecheasier.com/ip-address-geolocation-lookups-linux/</a></p>
<pre><code>sudo apt-get install geoip-bin
geoiplookup 8.8.4.4

wget https://dl.miyuru.lk/geoip/maxmind/country/maxmind4.dat.gz
gunzip maxmind4.dat.gz
sudo mv maxmind4.dat /usr/share/GeoIP/GeoIP.dat.gz

wget https://dl.miyuru.lk/geoip/maxmind/city/maxmind4.dat.gz
gunzip maxmind4.dat.gz
sudo mv maxmind4.dat /usr/share/GeoIP/maxmind4.city.dat

wget https://dl.miyuru.lk/geoip/maxmind/asn/maxmind4.dat.gz
gunzip maxmind4.dat.gz
sudo mv maxmind4.dat /usr/share/GeoIP/maxmind4.asn.dat

geoiplookup -f /usr/share/GeoIP/GeoIP.dat.gz 54.241.194.177
geoiplookup -f /usr/share/GeoIP/maxmind4.city.dat 54.241.194.177
geoiplookup -f /usr/share/GeoIP/maxmind4.asn.dat 54.241.194.177
</code></pre>
<p>获取文件名</p>
<pre><code>input=&quot;/home/data.txt&quot;
file_name=&quot;${input##*/}&quot;
</code></pre>
<p>How can I use sed to replace a multi-line string?<br>
<a href="https://unix.stackexchange.com/questions/26284/how-can-i-use-sed-to-replace-a-multi-line-string" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/26284/how-can-i-use-sed-to-replace-a-multi-line-string</a></p>
<p>sed 多行模式</p>
<pre><code>cat alpha.txt | tr '\n' '\r' | sed -e 's/a test\rPlease do not/not a test\rBe/'  | tr '\r' '\n'
</code></pre>
<p>sed 不带 -r 的正则表达式中括号里的空格要写在前面，不能写在后面</p>
<pre><code>$ echo 'a-b c'| sed 's/[ a-z\-]/6/g'
66666
$ echo 'a-b c'| sed 's/[a-z\- ]/6/g'
sed: -e expression #1, char 14: Invalid range end
$ echo 'a-b c'| sed 's/[a-z- ]/6/g'
sed: -e expression #1, char 13: Invalid range end
</code></pre>
<h2 id="tshark"><a class="header-anchor" href="#tshark">¶</a>tshark</h2>
<p><a href="https://www.jianshu.com/p/b78191fa4305" target="_blank" rel="noopener">https://www.jianshu.com/p/b78191fa4305</a></p>
<p>实时打印当前mysql查询语句</p>
<pre><code>tshark -s 512 -i eth1 -n -f 'tcp dst port 3306' -R 'mysql.query' -T fields -e mysql.query
</code></pre>
<p>实时打印当前http请求的url(包括域名)</p>
<pre><code>tshark  -s 512 -i eth0 -n -f 'tcp dst port 80'  -T fields -e http.host -e http.request.uri -l | grep -Ev '^\s+$' 
</code></pre>
<h2 id="cloudwatch-logs"><a class="header-anchor" href="#cloudwatch-logs">¶</a>cloudwatch logs</h2>
<p>nginx log format：带空格，带逗号的字段用引号括起来</p>
<pre><code>log_format main '$time_iso8601 $status $request_time $upstream_response_time $upstream_cache_status $remote_addr &quot;$http_x_forwarded_for&quot; $http_host $upstream_addr &quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot;';
</code></pre>
<p>解析字段对应字段用引号括起来</p>
<pre><code>parse '* * * * * * &quot;*&quot; * * &quot;* * *&quot; * * &quot;*&quot;' as time_iso8601,status,request_time,upstream_response_time,upstream_cache_status,remote_addr,http_x_forwarded_for, http_host,upstream_addr,method,url,http_version,body_bytes_sent,http_referer,http_user_agent
| limit 10
</code></pre>
<h2 id="量化"><a class="header-anchor" href="#量化">¶</a>量化</h2>
<h3 id="宏观指标"><a class="header-anchor" href="#宏观指标">¶</a>宏观指标</h3>
<ul>
<li>GDP：国内生产总值
<ul>
<li>GDP 越高，表示国内经济越繁荣</li>
</ul>
</li>
<li>CPI: 物价指数，反应通胀水平
<ul>
<li>3% 是警戒线，高于警戒线，一般会紧缩</li>
<li>低于 0 会通缩，问题更严重</li>
<li>1-2% 是温和通胀，属于正常情况</li>
</ul>
</li>
<li>PPI: 工业品价格指数，主要指原材料和能源价格，是周期类投资必看的指标。
<ul>
<li>经济周期向上一般 PPI 会向上，</li>
</ul>
</li>
<li>M0 M1 M2: M0 表示流通中的现金；M1 是 M0 + 活期存款； M2 是 M1 + 定期存款
<ul>
<li>如果 M1 增速 大于 M2 说明市场资金很活跃，一般发生在牛市，原理就是大家把定期存款取出来到市场上了</li>
<li>相反 M1 下穿 M2，意味着市场货币收缩了，大家把活期转成了定期，房价和权益市场就会下跌。</li>
</ul>
</li>
<li>十年期国债收益率：可以当做无风险收益率，
<ul>
<li>国债收益率上升表示市场缺钱，对股市利空，如果利率长的太急，很有可能形成股债双杀。</li>
<li>国债收益率下行，意味着市场上的钱越来越多，市场资金充裕，是投资债券的好时机。</li>
<li>新债利率低于老债，所以大家都去买老债，所以债券价格就会上升。</li>
</ul>
</li>
<li>社融：社会融资总额，包括银行贷款，股票融资，发债融资，非标融资，专项债，社融反应资金的需求程度，
<ul>
<li>社融一般会跟随 M2 的走势，如果 M2 上穿社融，说明放水意义不大了。</li>
<li>社融下降意味着经济需求不足，说明大家对未来预期不好。</li>
</ul>
</li>
<li>社消总额：代表大家消费能力和意愿。
<ul>
<li>社消下降说明消费出了问题。</li>
<li>经济三驾马车：投资，进出口，消费。进出口受外部影响比较大，自己说了不算，假如投资也拉不动经济，就全部指望消费了。</li>
</ul>
</li>
<li>PMI：采购人经理指数，表示工厂里的采购经理如何看待经济，通常是经济的先行指标。
<ul>
<li>50 为枯荣线，枯荣线之上表示经济扩张，之下表示经济收缩。</li>
<li>每个月会公布两个 PMI 指标，统计局的数据偏向国企大型企业，财新的数据代表中小企业。</li>
</ul>
</li>
<li>CRB 指数：路透社编制的反应大宗商品周期性波动的指数，
<ul>
<li>大宗商品主要分 4 类：1、工业金属，铜铝锌锡；2、贵金属，黄金白银；3、农产品，小麦玉米；4、能源品，煤炭石油。</li>
<li>关注大宗商品的投资者需要关注 CRB 商品指数，如果不呈现上升趋势，周期行业还是少碰为好。</li>
</ul>
</li>
<li>库存周期：库存是一个重要的经济指标，反应经济周期。
<ul>
<li>主动去库存：经济不景气，库存太大，降价甩卖，所以大宗商品会走低。</li>
<li>被动去库存：经济复苏，涨价去库存，仓库的东西不多了，不着急卖了，因为供应短缺，所以大宗商品价格甚至会有上涨</li>
<li>主动补库存：经济繁荣，价格涨，库存升，仓库的东西不够卖了，所以一边加价，一边压货。</li>
<li>被动补库存：开始衰退，价格开始下降了，库存还在上升。</li>
</ul>
</li>
<li>信用利差：不同信用的人的融资利率不同，高信用和低信用的融资利率差就是信用利差。
<ul>
<li>信用利差上升说明经济遇冷，银行给信用差的人的贷款利率提高，所以中小企业成本会上升。</li>
<li>信用利差下降，说明银行不担心信用差的人违约，所以降低利率，中小企业会收益。</li>
<li>信用利差上升时，股市表现就会不好。</li>
<li>信用利差下降时，股市就不会那么糟糕了。</li>
</ul>
</li>
<li>MLF 麻辣粉：中期借款便利，央行印出来的钱并借给商业银行的钱的利率，它代表基准贷款利率
<ul>
<li>MLF 下降，贷款利率也会下降，相当于变相降息</li>
<li>相反，MLF 上升就有加息的效果</li>
</ul>
</li>
<li>DR 007: 银行间市场 7 天质押回购利率
<ul>
<li>上升过快，表示银行开始收缩了</li>
</ul>
</li>
<li>其它：逆回购，银行间拆借利率，税，失业率，铜金比，油金比，GDP和国债比值</li>
</ul>
<h3 id="WorldQuant-101-Alphas"><a class="header-anchor" href="#WorldQuant-101-Alphas">¶</a>WorldQuant 101 Alphas</h3>
<p>WorldQuant 101 Alphas及一些思考<br>
<a href="https://zhuanlan.zhihu.com/p/52459234" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52459234</a></p>
<p>价量关系。就算是新股民也会听说价量的段子，什么最近大盘缩量啊，量在价先啊，高手只看K线和成交量啊啥的。确实，价量是交易最基本的组成要素，无论提到多高的高度不为过。通常把价涨量缩和价跌量升称为背离，剩下两个有人喜欢叫同向，我喜欢叫共振。最简单描述价量关系的指标就是相关系数，101 Alphas中有很多种写法。</p>
<ul>
<li>背离
<ul>
<li><code>-1 * correlation(volume, close, N)</code> : 成交量与收盘价在N日内的背离程度</li>
<li><code>-1 * correlation(delta(volume, 1)</code>, delta(close,1), N): 成交量变动与收盘价日内变动在N日内的背离程度</li>
<li><code>-1 * correlation(rank(delta(volume), 1)), rank(delta(close,1)), N)</code> : 成交量变动全市场强度与收盘价日内变动全市场强度在N日内的背离程度</li>
<li><code>-1 * correlation(ts_rank(delta(volume), 1),M), ts_rank(delta(close,1),K), N)</code>: 当日成交量变动在M日内的相对强度与当日收盘价日内变动在K日内的相对强度 在N日内的背离程度</li>
</ul>
</li>
<li>共振
<ul>
<li>上面所有公式去掉-1</li>
</ul>
</li>
<li>契合程度
<ul>
<li><code>abs(correlation(·))</code> 这种写法，我称其为契合程度，在#036和#087中出现</li>
</ul>
</li>
</ul>
<p>单单就一个涨停板限制就可以把其中大多数alpha的构造逻辑摧毁，对于波动，在中国市场不太适合rank和ts_rank函数。</p>
<ul>
<li>rank是横截面排序，某一股票的alpha在当前时刻下在其他所有股票的alpha中的位置；ts_rank是序列排序，某一股票的当前alpha在某段时间内的alpha中的位置。一个是与其他股票比较，一个是与自己比较，这两个函数都是在描述强弱。</li>
<li>然而作用于涨跌幅的时候涨停板会从中作梗：首先是四舍五入的问题，涨停板的涨幅可以上达10.05%，下达9.95%，明明都是板却非要比个高低。由于磁吸效应的存在，涨停板强度的描述可以利用封板时间比，报成比，换手率等指标衡量。不过说回来，现在的主力真不喜欢拉板，熊市的磁吸效应没那么强而且从监管的角度来讲太危险了。</li>
<li>其次是一字板本身的价量背离问题。对于单一bar来讲，一字板是最严重的价量背离。我不知道大多数人讲的价量关系是不是在流动性充裕的基础上的，当流动性有问题的时候，价量关系的衡量标准和平常必然不同。这个问题可以通过拉长时间区间来缓解，可以用长周期如周线来抵消涨停板带来的异常，也可以针对特点改一下rank与ts_rank。</li>
</ul>
<p>基于短周期价量特征的多因子选股体系<br>
<a href="https://www.cnblogs.com/bitquant/p/8393936.html" target="_blank" rel="noopener">https://www.cnblogs.com/bitquant/p/8393936.html</a></p>
<p>通过交易型阿尔法策略的研究，我们发现在A股市场，与传统多因子模型所获取的股票价值阿尔法收益相比，交易型阿尔法收益的空间更大、收益稳定性也更强。</p>
<p>即便是最纯粹的价值投资者也不得不承认，交易行为在短期内对股票价格起着几乎是决定性的影响，而发掘这种交易型套利空间正是量化投资的优势所在，因此量化模型在这一领域内应有着广泛的运用空间。</p>
<p>数值型因子的大规模分层测试—WorldQuant 101、国泰191、Sundays100+<br>
<a href="https://zhuanlan.zhihu.com/p/60872286" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60872286</a></p>
<p>国泰191 Alphas的研报《基于短周期价量特征的多因子选股体系》于2017年6月份公布，其中191个alphas有70个是WorldQuant 101因子原样照抄或者是小改一下</p>
<p>单因子测试</p>
<ul>
<li>主流单一因子测试方法也就分层法和 IC 法。</li>
<li>不过需要注意的是，通常金工研究认为，测试单一因子的有效性应考虑市场因子、市值因子和行业因子的风险暴露，也即用线性回归残差替代因子本身。</li>
<li>但我感觉不一定必须用，毕竟之后的因子库还要降维的。虽然可解释性上更低了一点，也更不符合金融行业的习惯，但在不深入挖掘某一因子的风险（收益）来源时，此举加大了工作量，说到底还是看需求。</li>
</ul>
<p>分层法: 剔除风险暴露的因子值进行了月度调仓的分层法测试</p>
<ul>
<li>显著性（TOP20% 与 BOTTOM20% 差值的期望大不大）</li>
<li>稳健性（TOP20% 与 BOTTOM20% 差值的方差小不小）</li>
<li>在一条线上可以理解为收益率与回撤。</li>
<li>但有很多因子你会发现，尾部的超额收益怎么都比不上中间两组。这就要用全市场的几条线来看了。</li>
</ul>
<p>关于市值：<code>Alpha = - close</code>，<code>rank(vwap - close) / rank(vwap + close)</code></p>
<ul>
<li>市值因子一般认为是 CAPM 的漏洞，定价时就没考虑这个；</li>
<li>市场对小公司的信息也没有挖掘得很充分。</li>
<li>对于我国的低价因子还有两点，
<ul>
<li>一是市场监管不到位导致的财务造假，</li>
<li>二是注册制不到位导致的壳资源预期。</li>
</ul>
</li>
<li>这些都是制度问题，制度带来的收益必然随制度变化而变化。因此当我国退市、注册两个制度变化的时候，必然会对小市值策略产生影响，但不至于颠覆。</li>
<li>我的愚见，对于一个所谓的好因子，首先应看是不是市值暴露带来的收益，即有没有市值味儿。</li>
<li>wq_alpha 和 gt_alpha 中，十分显著且稳定的基本上都有市值暴露。</li>
</ul>
<p>短期价量背离程度的强度：<code>rank(covariance(rank(high), rank(volume), 5))</code></p>
<ul>
<li>价量背离之前说过了是一个不错的因子，除了牛市中后期（加速）的时候，基本都有稳定的反向关系，无论参数从 5 到 20。</li>
<li>加入 rank() 函数之后，牛市中后期也不会影响因子的稳定性，反而会得到超额收益，</li>
<li>所以说，“放量大涨能延续” 说的是大盘，而不是个股（甚至大盘也不对）。缩量才是王道！！！</li>
</ul>
<p>研报中的一些圣经</p>
<ul>
<li>事件因子圣经：20160527-国泰-事件驱动的因子化特征</li>
<li>价值投资圣经：20170831-东方-质优股量化投资</li>
<li>资金流因子圣经？：20180611-长江-资金流因子全测试</li>
<li>多因子模型组合圣经：20171117-中信-多因子模型的组合优化与风险</li>
</ul>
<p>技术指标调参<br>
<a href="https://zhuanlan.zhihu.com/p/53279433" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53279433</a></p>
<ul>
<li>技术分析到底有没有用我不知道，画线派、价量派和指标派各有各的理；</li>
<li>有人认为只要精通一两种方法，也有人认为多种方法要结合使用。</li>
<li>说到底，在技术分析没有引入“决策”之前，依旧可以将其视为因子，毕竟万物皆因子。是因子就可以检验相关性，这就是本文所探讨的东西。</li>
</ul>
<p>本文选取了 6 类 10 种技术指标，计算他们的值，变动率，波动率与未来股票的值，变动率的关系。</p>
<ul>
<li>趋势类：MACD — macd；DMI — pdi-mdi；ADX — adx；</li>
<li>随机类：KD — k-d；CCI — cci；</li>
<li>波动类：STD — 平均股价的标准差；ATR—atr；</li>
<li>成交量类：OBV — obv简单平均；</li>
<li>通道类：SAR — 股价均值-sar；</li>
<li>能量类：BRAR — br-ar；</li>
<li>benchmark：n日前的平均股价；</li>
</ul>
<p>精选研报复现—牛熊线BBCurve<br>
<a href="https://zhuanlan.zhihu.com/p/36437315" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36437315</a></p>
<pre><code>@jit
def cal_bull(close,mu,sigma,T,epsilon):
    return close * np.exp(T*mu + np.sqrt(T)*sigma*epsilon)

epsilon = scipy.stats.t.ppf(1-alpha/2,n) #ε
ripesd['logreturn'] = ripesd['close'].map(lambda x: np.log(x)).diff() #对数收益率
ripesd['mu'] = ripesd['logreturn'].rolling(n*T).mean() #μ
ripesd['sigma'] = ripesd['logreturn'].rolling(n*T).std() #σ
ripesd['close_-t'] = ripesd['close'].shift(T)
ripesd['bull'] = ripesd.apply(lambda x: cal_bull(x['close_-t'],x['mu'],x['sigma'],T,epsilon),axis=1)
ripesd = ripesd.dropna()

#上穿下穿买卖点
ripesd['buy'] = ripesd.apply(lambda x: True if x['close'] &gt;= x['bull'] and x['close_-1'] &lt;= x['bull_-1'] else False,axis=1)
ripesd['sell'] = ripesd.apply(lambda x: True if x['close'] &lt;= x['bull'] and x['close_-1'] &gt;= x['bull_-1'] else False,axis=1)


@jit
def cal_bull_3ver(close,mu,sigma,T,epsilon):
    return close * ((1+mu)**T + np.sqrt(T)*sigma*epsilon)

epsilon = scipy.stats.t.ppf(1-alpha/2,n)
ripesd['return'] = ripesd['close'].pct_change() #算术收益率
ripesd['mu'] = ripesd['return'].rolling(n*T).mean()
ripesd['sigma'] = ripesd['return'].rolling(n*T).std()
ripesd['close_-t'] = ripesd['close'].shift(T)
ripesd['bull'] = ripesd.apply(lambda x: cal_bull_3ver(x['close_-t'],x['mu'],x['sigma'],T,epsilon),axis=1)
</code></pre>
<p>世坤WorldQuant因子分析框架<br>
<a href="https://zhuanlan.zhihu.com/p/396465853" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/396465853</a></p>
<ul>
<li>2015年公布的世坤101alpha论文讲述了World Quant（投资机构）用量价，波动率，流动性概念构建的101个当时实盘中被使用的选股因子。</li>
<li>从本质来说因子可分趋势，回归，和趋势+回归；统计因子，和条件触发。</li>
<li>实际交易中，盘口数据（order book），对冲成本，过拟合的哲学问题，怎么用机器学习去撸数以万计的alpha rank，时序，截面，lead-lag自变量因子，并保证系统先进（计算速度，cuda，防止internal crossing等）才是真正赚钱的机制。</li>
<li>因此世坤公布这篇论文是目前国内大部分私募研究的基石，只能给大家提供研究的方向，根本不会堵塞公司本来的 alpha 通道。</li>
<li>另外，一个很重要的结论是波动率对因子起决定性作用。而换手率（交易量）和对数回报并没有很大的相关性。</li>
<li>因此除了频段以外，波动率是一个很好发分类法则去判断做趋势还是回归。（高频偏趋势，低频偏回归）</li>
<li>在世坤 101 个因子里，平均协方差和夏普分别为 15.9% 和 2.25。</li>
</ul>
<p>教你用Python计算对量化交易至关重要的VWAP指标<br>
<a href="https://zhuanlan.zhihu.com/p/488527696" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/488527696</a></p>
<ul>
<li>
<p>TP =（最高价+最低价+收盘价）/3V = 成交量</p>
</li>
<li>
<p>VWAP = (TP_1 * V_1 + TP_2 * V_2 + TP_n * V_n)/n</p>
<h1>Create VWAP function</h1>
<p>def vwap(df):<br>
v = df[‘volume’].values<br>
tp = (df[‘low’] + df[‘close’] + df[‘high’]).div(3).values<br>
return df.assign(vwap=(tp * v).cumsum() / v.cumsum())</p>
<p>vwap(df)</p>
</li>
</ul>
<p>Backtesting a Trading Strategy with Pandas and Python<br>
<a href="https://www.learnpythonwithrune.org/backtesting-a-trading-strategy-with-pandas-and-python/" target="_blank" rel="noopener">https://www.learnpythonwithrune.org/backtesting-a-trading-strategy-with-pandas-and-python/</a></p>
<pre><code>data['Signal'] = data['Adj Close'].rolling(5).mean() - data['Adj Close'].rolling(20).mean()
data['Position'] = (data['Signal'].apply(np.sign) + 1)/2

data.drop(['High', 'Low', 'Open', 'Volume', 'Close'], axis=1, inplace=True)
data.dropna(inplace=True)

data['Log return'] = np.log(data['Adj Close']/data['Adj Close'].shift())
data['Return'] = data['Position'].shift(1)*data['Log return']

data[['Log return', 'Return']].cumsum().apply(np.exp)

np.exp(data[['Log return', 'Return']].mean()*252)

data[['Log return', 'Return']].std()*252**.5
</code></pre>
<p>jupyter 无法预览</p>
<pre><code>python -m pip install -I jinja2==3.0.3  
</code></pre>
<hr>
<p>《甄嬛传》妃嫔合集<br>
<a href="https://zhuanlan.zhihu.com/p/352962760" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/352962760</a></p>
<p>1.皇后2.华妃3.端妃4.敬嫔5.齐妃6.菀贵人/熹贵妃7.惠贵人8.安答应9.丽嫔10.曹贵人11.宁贵人12.瑛贵人13.欣常在14.祺嫔15.富察贵人16.夏常在17.余答应18.芝答应19.淳常在20.贞嫔21.康常在22.孙答应</p>
<p>An introduction to Byobu<br>
<a href="https://simonfredsted.com/1588" target="_blank" rel="noopener">https://simonfredsted.com/1588</a></p>
<p>Byobu advertises itself as a terminal multiplexer and a terminal window manager.</p>
<p>不ROOT不刷机，小米手机如何安装谷歌 GMS 三件套<br>
<a href="https://zhuanlan.zhihu.com/p/211362120" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/211362120</a></p>
<ul>
<li>Google Services Framework</li>
<li>Google play Services</li>
<li>Google Play Store</li>
</ul>
<p>Effortless API Design<br>
<a href="https://stoplight.io/studio" target="_blank" rel="noopener">https://stoplight.io/studio</a></p>
<p>iotop常用快捷键：</p>
<ul>
<li>左右箭头：改变排序方式，默认是按IO排序。</li>
<li>r：改变排序顺序。</li>
<li>o：只显示有IO输出的进程。</li>
<li>p：进程/线程的显示方式的切换。</li>
<li>a：显示累积使用量。</li>
<li>q：退出。</li>
</ul>
<p>Linux stress 命令<br>
<a href="https://www.cnblogs.com/sparkdev/p/10354947.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/10354947.html</a></p>
<pre><code>#消耗 CPU 资源
stress -c 4

# 消耗内存资源
stress --vm 2 --vm-bytes 300M --vm-keep

#消耗 IO 资源
stress -i 4

# 压测磁盘及 IO
stress -d 1 --hdd-bytes 10M
</code></pre>
<p>ulimit 命令详解<br>
<a href="https://www.cnblogs.com/zengkefu/p/5649407.html" target="_blank" rel="noopener">https://www.cnblogs.com/zengkefu/p/5649407.html</a></p>
<pre><code>vi /etc/security/limits.conf
    * soft noproc 11000
    * hard noproc 11000

vi /etc/profile
    ulimit -u 10000
    ulimit -n 4096
</code></pre>
<p><a href="https://unix.stackexchange.com/questions/34334/how-to-create-a-user-with-limited-ram-usage" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/34334/how-to-create-a-user-with-limited-ram-usage</a></p>
<p>The limits imposed by ulimit and limits.conf is per process. I definitely wasn’t clear on that point.<br>
If you want to limit the total amount of memory a users uses (which is what you asked). You want to use cgroups.</p>
<p>Limit memory usage of a user<br>
<a href="https://unix.stackexchange.com/questions/305026/limit-memory-usage-of-a-user" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/305026/limit-memory-usage-of-a-user</a></p>
<p>限制某用户每个进程的内存使用上限</p>
<ul>
<li>直接使用 ulimit 命令，作用范围是当前会话</li>
<li>修改 /etc/profile，作用范围是所有人</li>
<li>修改 /etc/security/limits.conf，作用范围可以是所有人，也可以指定组或人</li>
</ul>
<p>测试</p>
<pre><code># 限制进程最大使用 2000M 内存 
$ ulimit -v 2000000

# 启动一个进程，使用 1G 内存，保持 5 秒 
$ stress --vm 1 --vm-bytes 1024M --vm-keep -t 5
stress: info: [2889506] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd
stress: info: [2889506] successful run completed in 5s

# 限制单进程最大使用 1000M 内存 
$ ulimit -v 1000000

# 启动一个进程，使用 1G（大于 1000M） 内存，预期运行失败 
$ stress --vm 1 --vm-bytes 1024M -t 5
stress: info: [2889759] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd
stress: FAIL: [2889760] (494) hogvm malloc failed: Cannot allocate memory
stress: FAIL: [2889759] (394) &lt;-- worker 2889760 returned error 1
stress: WARN: [2889759] (396) now reaping child worker processes
stress: FAIL: [2889759] (451) failed run completed in 0s

# 启动 2 个进程，各使用 512M (小于 1000M) 内存，总共使用 1024 M，进程能够运行成功。
stress --vm 2 --vm-bytes 512M -t 5
stress: info: [2898454] dispatching hogs: 0 cpu, 0 io, 2 vm, 0 hdd
stress: info: [2898454] successful run completed in 5s
</code></pre>
<h3 id="限制某个用户所有进程的总内存"><a class="header-anchor" href="#限制某个用户所有进程的总内存">¶</a>限制某个用户所有进程的总内存</h3>
<p>创建一个资源限制组，限制最多使用 2 G 内存</p>
<pre><code>$ cat /etc/cgconfig.conf
group memlimit2G {
    memory {
        memory.limit_in_bytes = 2000000000;
    }
}
</code></pre>
<p>设置 testuser 的内存只用上面定义的资源组</p>
<pre><code>$ cat /etc/cgrules.conf
testuser   memory   memlimit2G/
</code></pre>
<p>安装和启动相关工具和服务</p>
<pre><code>sudo apt install cgroup-tools
sudo cgconfigparser -l /etc/cgconfig.conf
sudo cgrulesengd
</code></pre>
<p>以 testuser 身份运行 2 个进程，每个进程使用 512M 内存，执行 5 秒，预期运行成功</p>
<pre><code>$ sudo -u testuser stress --vm 2 --vm-bytes 512M -t 5
stress: info: [2946198] dispatching hogs: 0 cpu, 0 io, 2 vm, 0 hdd
stress: info: [2946198] successful run completed in 5s
</code></pre>
<p>以 testuser 身份运行 4 个进程，每个进程使用 512M 内存，执行 5 秒，预期运行失败</p>
<pre><code>$ sudo -u testuser stress --vm 4 --vm-bytes 512M -t 5
stress: info: [2946363] dispatching hogs: 0 cpu, 0 io, 4 vm, 0 hdd
stress: FAIL: [2946363] (415) &lt;-- worker 2946367 got signal 9
stress: WARN: [2946363] (417) now reaping child worker processes
stress: FAIL: [2946363] (421) kill error: No such process
stress: FAIL: [2946363] (451) failed run completed in 5s
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-todo" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/06/10/todo/" class="article-date">
  	<time datetime="2022-06-10T01:27:50.000Z" itemprop="datePublished">2022-06-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/10/todo/">todo</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>技术学习</p>
<ul>
<li>可以任意维度筛选，排序，分组，分栏的 TODO LIST。</li>
</ul>
<p>理财</p>
<ul>
<li>使用前一天的开盘收盘最高最低成交价换手率波动率等作为特征，取 1-3 年的数据作为样本，以第二天的涨跌为分类标签，使用贝叶斯算法训练模型并预测第二天涨跌。</li>
<li>把同一基金经理管理年限超过 5 年的基金，计算最近 1 年，3 年， 5 年的波动率，夏普率，年化收益，α 收益，β 收益，最大回撤，以及两两之间的相关性做成一个表格。</li>
</ul>
<p>定期检查</p>
<ul>
<li>域名过期检查</li>
<li>云主机过期检查</li>
<li>HTTPS 证书过期检查</li>
<li>云主机定时备份</li>
<li>手机定时备份</li>
<li>电脑定时备份</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-202206" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/06/02/202206/" class="article-date">
  	<time datetime="2022-06-02T03:22:45.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/02/202206/">202206</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>解读历史波动率，发现交易机会<br>
<a href="https://new.qq.com/rain/a/20210830A08VW100" target="_blank" rel="noopener">https://new.qq.com/rain/a/20210830A08VW100</a></p>
<p>波动率具有聚集性、均值回归、长记忆性和非对称性等特征。</p>
<ul>
<li>聚集性是指波动率具有高低波动率各自聚集的特征，即高波动率之后大概率还是高波动率，低波动率之后大概率还是低波动率，而且高波动率和低波动率聚集的时期会交替出现，呈现出的就是周期性。</li>
<li>均值回归是指波动率没有长期上涨或者下跌的趋势，而是围绕均值上下波动。</li>
<li>长记忆性指波动率存在较高的自相关特性，现在的波动率在很大程度上取决于其过去的波动率。</li>
<li>波动率的非对称性主要体现在隐含波动率上，即标的价格上涨或下跌相同幅度对期权隐含波动率的影响并不相同。</li>
</ul>
<p>说到企业估值，你怎能不知道现金流折现法？<br>
<a href="https://baijiahao.baidu.com/s?id=1722719168861071511" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1722719168861071511</a></p>
<p>一个公司的内在价值，取决于该公司未来能产生的自由现金流。</p>
<p>自由现金流折现法（Discounted Cash Flow ），简称 DCF。</p>
<p>无杠杆自由现金流/企业自由现金流</p>
<ul>
<li>= EBIT－调整的所得税+折旧摊销—营运资金的增加—资本支出。</li>
<li>= 净利润＋利息费用＋所得税－调整的所得税＋折旧摊销—营运资金的增加—资本支出。</li>
</ul>
<hr>
<p>为了防止 ssh 或 scp 时，提示是否需要确认 hosts，可以提前执行如下语句</p>
<pre><code>ssh-keyscan abc.com &gt;&gt; ~/.ssh/known_hosts
</code></pre>
<p>ssh 或 scp 自动输入密码可以使用 sshpass</p>
<pre><code>apt-get update
apt-get  install -y --force-yes sshpass
sshpass -p &quot;xxxx&quot; scp local remote 
</code></pre>
<hr>
<p>Postgree 查看数据库，表，索引大小</p>
<p>查看各个库的大小</p>
<pre><code>select pg_database.datname, pg_size_pretty (pg_database_size(pg_database.datname)) AS size from pg_database;
</code></pre>
<p>查看 public 库下所有表索引大小</p>
<pre><code>select indexrelname, pg_size_pretty(pg_relation_size(relid)) from pg_stat_user_indexes where schemaname='public' order by pg_relation_size(relid) desc;
</code></pre>
<p>查看 public 库下所有表大小</p>
<pre><code>select relname, pg_size_pretty(pg_relation_size(relid)) from pg_stat_user_tables where schemaname='public' order by pg_relation_size(relid) desc;
</code></pre>
<p>查看单个表大小</p>
<pre><code>select pg_size_pretty(pg_relation_size('表名'));
</code></pre>
<p>查询所有表的大小并排序（包含索引）</p>
<pre><code>SELECT table_schema || '.' || table_name AS table_full_name, pg_size_pretty(pg_total_relation_size('&quot;'
    || table_schema || '&quot;.&quot;' || table_name || '&quot;')) AS size
FROM information_schema.tables
ORDER BY
pg_total_relation_size('&quot;' || table_schema || '&quot;.&quot;' || table_name || '&quot;') DESC limit 20;
</code></pre>
<p>查询表大小按大小排序并分离data与index</p>
<pre><code>SELECT
table_name,
pg_size_pretty(table_size) AS table_size,
pg_size_pretty(indexes_size) AS indexes_size,
pg_size_pretty(total_size) AS total_size
FROM (
SELECT
table_name,
pg_table_size(table_name) AS table_size,
pg_indexes_size(table_name) AS indexes_size,
pg_total_relation_size(table_name) AS total_size
FROM (
SELECT ('&quot;' || table_schema || '&quot;.&quot;' || table_name || '&quot;') AS table_name
FROM information_schema.tables
) AS all_tables
ORDER BY total_size DESC
) AS pretty_sizes;
</code></pre>
<hr>
<p>分区，挂磁盘</p>
<pre><code># 创建挂载目录
mkdir /data_ext2/

# 查看块设备，找到新硬盘
lsblk
file -s /dev/nvme2n1
    /dev/nvme2n1: data

# 分区并查看
mkfs -t xfs /dev/nvme2n1
file -s /dev/nvme2n1
    /dev/nvme2n1: SGI XFS filesystem data (blksz 4096, inosz 512, v2 dirs)
lsblk -f | grep nvme2n1
    nvme2n1     xfs                      de17daa1-9f10-4b60-adc9-2a7ed1557c89

# 挂载并查看
mount /dev/nvme2n1 /data_ext2
df -h /data_ext2

# 查看设备 id，并设置开机启动挂载
blkid
vi /etc/fstab
    UUID=7a0a651a-0000-0000-0000-717708af1dec /data_ext2  xfs  defaults 0 0
</code></pre>
<hr>
<p>How to fix “MySQL server has gone away”, “Packets out of order” and similar MySQL connection errors<br>
<a href="https://www.ryadel.com/en/fix-mysql-server-gone-away-packets-order-similar-mysql-related-errors/" target="_blank" rel="noopener">https://www.ryadel.com/en/fix-mysql-server-gone-away-packets-order-similar-mysql-related-errors/</a></p>
<p>for these errors:</p>
<pre><code>MySQL server has gone away
Error reading result set's header
Error executing query
MySQL server has gone away for query
2006, MySQL server has gone away
Packets out of order. Expected X received Y. Packet size=Z
</code></pre>
<ul>
<li>There’s a good chance that the server is dropping an incorrect or too large packet sent by the client. To fix that, check the max_allowed_packet variable value and set it to a very high value</li>
<li>The issue might be due to the fact that the server timed out and closed the connection. Check the wait_timeout MySQL variable value and ensure it’s large enough.</li>
<li>Additionally, if you’re getting the Packets out of order error in the PHP log, there’s an high chance that the issue is due to the fact that there’s an incompatibility between the PHP and MySQL versions you’re using.</li>
</ul>
<p>我的一个不常访问的页面使用的如下的代码</p>
<pre><code>$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass, array(
    PDO::ATTR_PERSISTENT =&gt; true
));
</code></pre>
<p>但偶尔报下面的错误，不是经常</p>
<pre><code>warning: Packets out of order. Expected 1 received 0. Packet size=145
</code></pre>
<p>我怀疑是我使用了 MySQL 持久连接，但这个页面不经常使用，造成这个连接长时间保持但没有任何真实请求，然后被 MySQL 单方面杀掉了，但我过了很久之后再刷新页面，PHP 尝试复用这个连接时，被 MySQL 拒绝了。</p>
<p>如果是一个比较活跃的站点，持久连接带来的好处可能比较明显，因为节省了很多连接建立的花时间。但一个请求量比较低的页面没有必要使用持久连接，不知道理解的对不对。</p>
<p>要想真正避免这个问题，我想在执行 SQL 之前要先执行个空的 MySQL ping 命令，验证 MySQL 连接是否有效，如果无效则重新连接，有效则直接使用。这个验证连接的操作可以设置一个缓存时间，比如 1 小时内不需要再次验证，以避免频繁的做无用功。</p>
<hr>
<h2 id="sql"><a class="header-anchor" href="#sql">¶</a>sql</h2>
<p>TODO: MySQL窗口函数OVER()<br>
<a href="https://blog.csdn.net/weixin_46544385/article/details/120609601" target="_blank" rel="noopener">https://blog.csdn.net/weixin_46544385/article/details/120609601</a></p>
<p>mysql 快速查看表的数据行数</p>
<pre><code>set session information_schema_stats_expiry=0;
show table status like 'mytable'\G
</code></pre>
<p>Postgres array_to_string() and array_agg() to decouple your interface<br>
<a href="https://pemungkah.com/postgres-array_to_string-and-array_agg-to-decouple-your-interface/" target="_blank" rel="noopener">https://pemungkah.com/postgres-array_to_string-and-array_agg-to-decouple-your-interface/</a></p>
<pre><code>SELECT Array_to_string(Array_agg(number_of
                                 || ' '
                                 || status), ',  ') summary_status,
       Max(user_id) USER
FROM   (SELECT Count(*) number_of,
               status,
               user_id
        FROM   jobs
        GROUP  BY status,
                  user_id
        ORDER  BY user_id) AS foo
GROUP  BY user_id;
</code></pre>
<p>PostgreSQL:基于数组(外键)列联接2个表<br>
<a href="http://ask.sov5.cn/q/rxkaSsHjMA" target="_blank" rel="noopener">http://ask.sov5.cn/q/rxkaSsHjMA</a></p>
<p>SELECT <a href="http://u.id" target="_blank" rel="noopener">u.id</a>, <a href="http://u.name" target="_blank" rel="noopener">u.name</a>,array_agg(<a href="http://g.name" target="_blank" rel="noopener">g.name</a>) group_names FROM users u JOIN groups g ON <a href="http://g.id" target="_blank" rel="noopener">g.id</a> = ANY (u.group_ids)<br>
GROUP BY <a href="http://u.id" target="_blank" rel="noopener">u.id</a>, <a href="http://u.name" target="_blank" rel="noopener">u.name</a>;</p>
<p>postgree 里的换行</p>
<pre><code>select 'test line 1'||E'\n'||'test line 2';
</code></pre>
<p>postgree 的表 a 有一个数组列 id_arr，格式类似于 <code>[1,2,3]</code>，关联到 b 表的 id 列，我想得到 <code>[a,b,c]</code></p>
<pre><code>SELECT (select string_agg(b.name,',') from b where b.id = ANY(a.ids)) FROM a 
</code></pre>
<p>创建临时表，当你断开与数据库的连接后，临时表就会自动被销毁。 临时表只在当前连接中有效。</p>
<pre><code>CREATE TEMPORARY TABLE 临时表名 AS
(
    SELECT *  FROM 旧的表名
    LIMIT 0,10000
);
</code></pre>
<p>MySQL 全文索引<br>
<a href="https://blog.csdn.net/dreamyuzhou/article/details/120432893" target="_blank" rel="noopener">https://blog.csdn.net/dreamyuzhou/article/details/120432893</a></p>
<ul>
<li>全文索引只能用于InnoDB或MyISAM表，并且只能为CHAR、VARCHAR或TEXT列创建。</li>
<li>MySQL提供了一个内置的全文ngram解析器，支持中文，日文和韩文(CJK)，以及一个可安装的MeCab日文全文解析器插件。 “ngram全文解析器”和“MeCab全文解析器插件”</li>
<li>FULLTEXT索引定义可以在创建表时在CREATE TABLE语句中给出，也可以稍后使用ALTER TABLE或CREATE index添加。</li>
<li>对于大型数据集，将数据加载到一个没有FULLTEXT索引的表中，然后在此之后创建索引，比将数据加载到一个已有FULLTEXT索引的表中要快得多。</li>
<li>分区表不支持全文搜索</li>
</ul>
<p>mysql的全文索引只有一种方法判断相关性，就是词频，索引并不会记录匹配的词在字符串中的位置。并且，全文索引和数据量有较大的关系，全文索引只会全部在内存中时，性能才会很好，因此当全文索引过大，不能全部读入进内存，性能就会比较差。<br>
可以通过一下点，思考下全文索引的问题：</p>
<ul>
<li>修改一段文本中的100个单词时，需要索引100次。</li>
<li>全文索引的长度对性能的影响也是巨大的</li>
<li>全文索引会产生更多的碎片，需要频繁的优化（optimize table）操作</li>
<li>内存和数据容量也是常可观，所以需要规划和参数控制这部分</li>
<li>因为mysql复制机制是基于逻辑复制，产生的binlog很大，那就会出现主从延迟等问题。</li>
<li>词分割（token_size）也是一个问题，单个汉字也能表达出不同的意思。</li>
<li>查询上：如果sql中包含match against，而索引列上又正好有全文索引，那么mysql就一定会使用全文索引，如果此时还有其他索引，mysql也不会去对比那个索引性能更高。</li>
</ul>
<p>MySQL 创建全文索引</p>
<pre><code>-- 创建全文索引
CREATE FULLTEXT INDEX idx ON table_name(`columns`);

-- 创建表时自动加全文索引，临时表不支持
CREATE TABLE articles (
  id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
  title VARCHAR(200),
  body TEXT,
  FULLTEXT (title,body)
) ENGINE=InnoDB;

-- 插入测试数据
INSERT INTO articles (title,body) VALUES
('MySQL Tutorial','DBMS stands for DataBase ...'),
('How To Use MySQL Well','After you went through a ...'),
('Optimizing MySQL','In this tutorial, we show ...'),
('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
('MySQL vs. YourSQL','In the following database comparison ...'),
('MySQL Security','When configured properly, MySQL ...');

-- 简单全文搜索 
SELECT * FROM articles
WHERE MATCH (title,body)
AGAINST ('database' IN NATURAL LANGUAGE MODE);

+----+-------------------+------------------------------------------+
| id | title             | body                                     |
+----+-------------------+------------------------------------------+
|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |
|  5 | MySQL vs. YourSQL | In the following database comparison ... |
+----+-------------------+------------------------------------------+


-- 布尔搜索
SELECT * FROM articles WHERE MATCH (title,body)
AGAINST ('+MySQL -YourSQL' IN BOOLEAN MODE);

+----+-----------------------+-------------------------------------+
| id | title                 | body                                |
+----+-----------------------+-------------------------------------+
|  6 | MySQL Security        | When configured properly, MySQL ... |
|  1 | MySQL Tutorial        | DBMS stands for DataBase ...        |
|  2 | How To Use MySQL Well | After you went through a ...        |
|  3 | Optimizing MySQL      | In this tutorial, we show ...       |
|  4 | 1001 MySQL Tricks     | 1. Never run mysqld as root. 2. ... |
+----+-----------------------+-------------------------------------+

-- 查询扩展搜索是对自然语言搜索的修改。
-- 搜索字符串用于执行自然语言搜索，然后将搜索返回的最相关行的单词添加到搜索字符串中，并再次执行搜索。
-- 查询返回第二次搜索的行.
SELECT * FROM articles
WHERE MATCH (title,body)
    AGAINST ('database' WITH QUERY EXPANSION);

+----+-----------------------+------------------------------------------+
| id | title                 | body                                     |
+----+-----------------------+------------------------------------------+
|  5 | MySQL vs. YourSQL     | In the following database comparison ... |
|  1 | MySQL Tutorial        | DBMS stands for DataBase ...             |
|  3 | Optimizing MySQL      | In this tutorial, we show ...            |
|  6 | MySQL Security        | When configured properly, MySQL ...      |
|  2 | How To Use MySQL Well | After you went through a ...             |
|  4 | 1001 MySQL Tricks     | 1. Never run mysqld as root. 2. ...      |
+----+-----------------------+------------------------------------------+
</code></pre>
<hr>
<h2 id="laravel"><a class="header-anchor" href="#laravel">¶</a>laravel</h2>
<p><a href="https://zhuanlan.zhihu.com/p/95558910" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/95558910</a><br>
Laravel 一主多从配置</p>
<pre><code>'mysql' =&gt; [
    'write' =&gt; [
        'host' =&gt; '192.168.1.180',
    ],
    'read' =&gt; [
        ['host' =&gt; '192.168.1.182'],
        ['host' =&gt; '192.168.1.179'],
    ],
    'driver' =&gt; 'mysql',
    'database' =&gt; 'database',
    'username' =&gt; 'root',
    'password' =&gt; '',
    'charset' =&gt; 'utf8',
    'collation' =&gt; 'utf8_unicode_ci',
    'prefix' =&gt; '',
]
</code></pre>
<p><a href="https://lqwang.net/13.html" target="_blank" rel="noopener">https://lqwang.net/13.html</a></p>
<ul>
<li>使用 chunkById 或者 chunk 方法的时候不要添加自定义的排序，chunk和chunkById的区别就是chunk是单纯的通过偏移量来获取数据，chunkById进行了优化，不使用偏移量，使用 id 过滤，性能提升巨大。在数据量大的时候，性能可以差到几十倍的样子。</li>
<li>而且使用chunk在更新的时候，也会遇到数据会被跳过的问题。</li>
<li>同时 chunkById 在你没有传递 column 参数时，会默认添加 order by id，可能会遇到索引失效的问题。解决办法就是传递 column 参数即可。</li>
<li>本人感觉 chunkById 不光是根据 Id 分块，而是可以根据某一字段进行分块，这个字段是可以指定的。</li>
</ul>
<p><a href="https://laravel.com/docs/master/broadcasting" target="_blank" rel="noopener">https://laravel.com/docs/master/broadcasting</a><br>
<a href="https://learnku.com/docs/laravel/9.x/broadcasting/12223" target="_blank" rel="noopener">https://learnku.com/docs/laravel/9.x/broadcasting/12223</a></p>
<p>For example, imagine your application is able to export a user’s data to a CSV file and email it to them. However, creating this CSV file takes several minutes so you choose to create and mail the CSV within a queued job. When the CSV has been created and mailed to the user, we can use event broadcasting to dispatch a App\Events\UserDataExported event that is received by our application’s JavaScript. Once the event is received, we can display a message to the user that their CSV has been emailed to them without them ever needing to refresh the page.</p>
<ul>
<li>Laravel 通过 WebSocket 连接使它很容易的去「广播」您的服务端 Laravel 事件。</li>
<li>广播 Laravel 事件允许您在服务器端 Laravel 应用程序和客户端 JavaScript 应用程序之间共享相同的事件名称和数据。</li>
<li>广播背后的核心概念很简单：客户端连接到前端的命名频道，而您的 Laravel 应用程序将事件广播到后端的这些频道。</li>
<li>laravel-websockets 和 soketi 包为 Laravel 提供了与 Pusher 兼容的 WebSocket 服务器。 这些包允许您在没有商业 WebSocket 提供程序的情况下利用 Laravel 广播的全部功能。</li>
</ul>
<hr>
<h2 id="算法-5"><a class="header-anchor" href="#算法-5">¶</a>算法</h2>
<p>经典面试题：如何快速求解根号2？<br>
<a href="https://mp.weixin.qq.com/s/ONv1k27PflPZstlv99Vfzw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ONv1k27PflPZstlv99Vfzw</a></p>
<p>如何最简单、通俗地理解LSTM？<br>
<a href="https://www.zhihu.com/question/445411028/answer/2323876011" target="_blank" rel="noopener">https://www.zhihu.com/question/445411028/answer/2323876011</a></p>
<ul>
<li>LSTM 是一种 RNN 模型</li>
<li>LSTM 是对简单循环神经网络的改进</li>
<li>LSTM 可以避免梯度消失的问题，可以有更长的记忆</li>
</ul>
<p>大白话理解LSTM神经网络（附实例讲解）<br>
<a href="https://blog.csdn.net/Iceberggg/article/details/124114192" target="_blank" rel="noopener">https://blog.csdn.net/Iceberggg/article/details/124114192</a></p>
<p>长短期记忆神经网络（LSTM）是一种特殊的循环神经网络(RNN)。原始的RNN在训练中，随着训练时间的加长以及网络层数的增多，容易出现梯度爆炸或梯度消失的问题，导致无法处理较长序列数据，从而无法获取长距离数据的信息。为解决该问题，提出了它的改进方案，即LSTM神经网络。</p>
<p>设计思路</p>
<ul>
<li>RNN 神经网络：记住所有信息，无论是有用的还是无用的。</li>
<li>LSTM 神经网络:选择一个记忆细胞，对信息有选择性地记忆。</li>
</ul>
<p>前向传播</p>
<ul>
<li>t 为时刻</li>
<li>C_{t} 为记忆细胞</li>
<li>h_{t} 为状态</li>
<li>x_{t} 为输入</li>
<li>f_{t} 为遗忘门</li>
<li>i_{t} 为更新门</li>
<li>o_{t} 为输出门</li>
</ul>
<p>举例</p>
<ul>
<li>假设现在是期末考试周且你的脑容量有限，昨天你考完了高等数学，后天将考线性代数，你的线性代数老师也为你贴心地划好了考试重点。</li>
<li>RNN会记住所有的信息，无论是有用信息还是无用信息，即你复习了整本线性代数的书本，并将其内容与上一门高等数学的内容全部记忆了下来</li>
<li>对于LSTM来说，你将遗忘大部分高等数学的内容，而只保留基础数学运算等通用内容，并且只复习记忆线性代数书本中老师划出的重点。</li>
<li><code>C_{t} X f_{t}</code> 的会生成一系列 0-1 之间的数，如[0，1，0.7，0，0.3，1]，对其赋权重后，进行选择性遗忘。
<ul>
<li>遗忘大部分高等数学的知识，记忆能够用到线代考试中的基础数学运算等知识。</li>
</ul>
</li>
<li><code>i_{t}</code> 更新门
<ul>
<li>老师所划出的重点并不会全部出现在试卷上，你可以在复习的过程中根据自己的理解，判断哪些内容可能考，哪些内容肯定不考，由此再进行筛选过滤。</li>
</ul>
</li>
<li>在 LSTM 的每个时间步里，都有一个记忆 cell，给予 LSTM 选择记忆的功能。</li>
</ul>
<p>请问rnn(lstm)和hmm在处理序列问题上的区别和优缺点在于？<br>
<a href="https://www.zhihu.com/question/55007302/answer/1744376871" target="_blank" rel="noopener">https://www.zhihu.com/question/55007302/answer/1744376871</a></p>
<ul>
<li>在特定问题下，参数设置正确，相关论文已经证明HMM与LSTM能达到类似的效果。</li>
<li>但是越先进的模型，调参成本越低。</li>
<li>在时间序列预测问题上，可能 LSTM 不需要做特别多的参数调整就优于 HMM</li>
<li>自然语言处理上，BERT 不需要做特别多的参数调整就优于 LSTM</li>
</ul>
<p>深度学习做股票预测靠谱吗？<br>
<a href="https://www.zhihu.com/question/54542998/answer/2361320437" target="_blank" rel="noopener">https://www.zhihu.com/question/54542998/answer/2361320437</a></p>
<ul>
<li>我有无数的本科生从youtube上抄了一堆直接应用LSTM在股票价格上的预测，说r^2高达99%，然后我让他们用daily return做一遍，立刻不说话了。</li>
<li>究其原因，是股票价格的时间序列非常persistent，而在take first-order difference之后，return的信噪比又过低，所以LSTM肯定没办法。</li>
<li>LSTM在经济学里适合做什么呢？适合做宏观数据，一群月度季度宏观数据放在一起train，得到的结果是非常棒的。为什么呢？因为宏观本来就有lead-lag indicators，你LSTM做的是定量上的贡献。</li>
<li>在去掉seasonality之后如果还有很多信息，那么LSTM才会好（例如宏观数据）。</li>
<li>lstm 绝对是靠谱的。我就知道国内某头部量化2017 年到2019年用lstm做出了很好的收益。但具体做法绝对不是一般人想的那么简单。任务的目标、使用的数据、处理的特征，都不是一般人能想到的</li>
<li>任务的目标是个很重要的问题，很多人都没考虑清楚任务的目标就上LSTM</li>
<li>如果预测价格而不是return，线性模型都能给搞出高R^2来，把价格作为预测目标说明完全没有上道在胡做一气。不要预测价格，要预测收益率。</li>
<li>在不讨论因子有效性的前提下讨论模型work不work没有意义。没有因子，别玩模型。</li>
<li>混沌理论，尤其李天岩教授的研究，对股市预测有一定的帮助。所以金融领域，混沌理论应该是正确的突破方向。</li>
<li>幻方之前的报告明确表示，小资金量只用盘口数据+LSTM是可以赚钱的，但是他们也说特征工程有trick（估计有什么自己的因子）</li>
<li>宏观惯性大，微观在搞布朗运动</li>
<li>不是LSTM不行，而是关键方法设计和改进需要适合数据特性，做好预处理，做好需要处理的各种多模态数据的准备…毕竟直接套用LSTM，那是肯定不行…LSTM背后应该是一类方法，而不只是调用出来的tf里的一个确定的方法</li>
<li>特征挖得好加点非线性就能work，和lstm关系也不大</li>
<li>单变量序列，前后变化幅度上下0.1，不平稳，硬套lstm[飙泪笑] 老师！我有个时间复杂度O(1)的好主意，和你lstm一个水平：x(t) = x(t-1)[飙泪笑] 换daily return了？老师这题我也会！x(t) = mean(x[t-n: t-1])</li>
<li>feature不行吧，对着一堆噪声再好的模型也学不到语义，而且直接上lstm也太…</li>
<li>时序的默认假设就是有很强的关联性。单股数据内在关联实际上很弱，也就是所谓的信噪比非常低。这种情况下，越强的神经网络越容易出问题。因为噪声模式占主导，不经过特定的特征选择和滤噪，基本上只有过拟合噪声一条命。</li>
<li>对价格建模确实精确的一无是处</li>
<li>其实最大问题是时序非稳态，随着时间的变化时序的模式变了，机器学习还是按照过去训练集给出的模式来预测，结果肯定拉跨。说到底非稳态时序预测就是搞不定，arima不行，啥神经网络也不是万能药。</li>
<li>lstm 在高频预测方面还是有一定收益的</li>
<li>如果是youtube上面涉及到的first difference的方法我见过大部分是只使用股票价格去套lstm。这个问题出在数据上而不是lstm这个模型本身有没有效。</li>
<li>如果训练数据本身对结果就没有说明度模型选什么model已经不重要了……现在业内普遍的做法是训练数据用的因子是截面的基本面+量价因子（类MSCI Barra 或者Fama的做法），target用收益率或者对数收益率。</li>
<li>如果做非线性模型除了单lstm还有CNN+LSTM或者几种stacking的做法，做RF的也有，反正这个见仁见智吧跟设备还有交易速度也有关。<br>
另外宏观跟微观世界也差很多……有时候tick级动量因子就很有效反而日间的时候无效，有时候正好相反。</li>
<li>另外不同市场区别也很大，之前有段时间开盘那段趋势性很强，然后就有人做那种开盘型的momentum策略，结果最近日内波动上来了被爆锤。</li>
<li>归根结底，海量有效的因子库还是基础，模型是5%-6%的问题（这个我随便臆测的数哈不一定对，重点还是放在因子上）。</li>
<li>所以现在头部量化都是疯狂卷设备，招一堆因子民工进去挖因子，毕竟越同质化的因子注定策略收益越会被其他使用相同因子的同类策略压缩掉，总之是越来越卷</li>
<li>为什么说return信噪比低呢？这不应该比close 高？对数化遮盖了很多低频信息</li>
<li>预测return和你说的那些任务，难度和收益的差别堪比打游戏和打赢一场战争。。并且也不应该指望很高的r2，0.01就有用处了。0.1就逆天了</li>
<li>如果把预测股票视为一个分类问题，0跌 1涨呢？
<ul>
<li>方向准确率也比较难有比随机猜的50%更好的效果，而且拿方向准确率交易本身也不靠谱，就算能到75%，也有可能3天赚的钱1天直接双倍亏回来。</li>
<li>如果真的有75%，我完全可以分散成20个仓位，取预测上涨百分比最高的前20，上涨的概率越大仓位分配重，不多贪，每天能吃1个点一年都是10倍，三年一千倍</li>
<li>比特币分钟线搞过52%准确率的，期望收益率十万分之五每分钟</li>
</ul>
</li>
<li>做差分或者对return rate做预测或者是对01涨跌分类预测会不会work（比last day baseline好）
<ul>
<li>预测收益率or Diff是最最最基本的…work与否取决于因子质量，模型没有门槛，但因子库有。</li>
</ul>
</li>
<li>模型不是越高深效果越好，而是有各自适用的范围。比如，如果linear regression都过拟合，那用ML和DL就没什么意义了。</li>
<li>我个人的经验，日度的数据，用ML预测无卵用，加上盘口的高频数据ML倒是有可做的空间，但是还是无法满足DL对数据的质量要求。</li>
<li>当然，如果是对策略进行优化，而不是纯以预测股价为目的，ML应该会有更多的应用空间。但总而言之DL现在做量化的应该是几乎不用的。</li>
<li>一圈实验下来，确实觉得对策略优化是大概率的没走“邪路”。尤其是只用日频数据的alpha类策略，用ML来预测市场就像水中捞月。</li>
<li>不论回归，分类，不管统计学习，机器学习，深度学习，都是跑的概率。可以说是对你“见过的数据”做了一次拟合实验，想找到里面的规律――概率。</li>
<li>下围棋是归纳还是博弈？
<ul>
<li>下围棋是两人之间的博弈没错，但是深度学习alphago在这里面的作用起的是归纳历史棋局的作用。围棋虽然复杂，但是规则是有限的，也是明确的，所以在大量数据和高性能计算上，深度学习通过归纳下围棋的方法能打赢人类。但是市场跟围棋不一样，市场由于有很多人参与，规则是无限的，也是不明确的，很难用一个统一的模型去寻找规律。当然有可能存在短时间某种规律一直有效的情况，所以说有些因子在某些特定环境有效。</li>
</ul>
</li>
<li>如果说机构还能构建模型，对散户来说应该是通过归纳找出某周期内胜率大于50%的操作方式，合理设置盈亏比，严格执行之。并时时统计这个周期内胜率变化，一旦变化，相应策略也要调整。市场是混沌的，预测冇意义，一切都是概率变化而已</li>
<li>股市预测的问题本质上是一个online learning 的问题，因为股票市场上的规律是不断地在变的。这也是为什么传统机器学习方法和深度学习方法在金融市场上容易被当成笑话的原因。也因此，reinforcement learning 是显然不适合金融市场的，reinforcenment learning的反馈太慢了，所以需要大量的数据才能学到数据背后的规律。显然，在online learning场景下我们没有办法提供大量的数据。</li>
<li>我觉得深度学习还是可以用来做投资的，而非交易。
<ul>
<li>我觉得可以。最起码可以做交易员的辅助交易。因为有些隐规则是人自身没有发现的，但是机器可能会发现，一个好的高频预测模型是可以做出来的，因为短期内环境不会有大的变化，就可以预测。如果深度学习能够学习其中的隐规则，并且使用模型输出人能够理解的信息形式，就是一个很好的预测模型</li>
</ul>
</li>
<li>市场追求的不是博弈，而是共识。 同样2020年3月为例，绝对的利空，造成统一的救市共识，然后才挽救了股市。放在1927年、2000年，市场在救与不救之间徘徊不定无法达成共识，造成了灾难性后果。</li>
<li>深度学习肯定是可以用在股票市场的，比如针对某只股票的新闻情感分析等。但是不能用来预测市场走向！！！</li>
</ul>
<p>人工智能基础课，最优化</p>
<p>求解无约束优化问题最常用的方法是梯度下降法（gradient descent）。直观地说，梯度下降法就是沿着目标函数值下降最快的方向寻找最小值，就像爬山时要沿着坡度最陡的路径寻找山顶一样。在数学上，梯度的方向是目标函数导数（derivative）的反方向。</p>
<p>当函数的输入为向量时，目标函数的图象就变成了高维空间上的曲面，这时的梯度就是垂直于曲面等高线并指向高度增加方向的向量，也就携带了高维空间中关于方向的信息。而要让目标函数以最快的速度下降，就需要让自变量在负梯度的方向上移动。这个结论翻译成数学语言就是“多元函数沿其负梯度方向下降最快”，这也是梯度下降法的理论依据。</p>
<p>遗憾的是，梯度下降法无法获知关于导数的变化信息，也就不知道应该探索导数长期为负的方向。由于不具备观察目标函数的全局视角，在使用中梯度下降法就会走出一些弯路，导致收敛速度变慢。而二阶导数所包含的全局信息能够为梯度下降的方向提供指导，进而获得更优的收敛性。</p>
<p>如果将二阶导数引入优化过程，得到的典型方法就是牛顿法（Newton’s method）。在牛顿法中，目标函数首先被泰勒展开，写成二阶近似的形式（相比之下，梯度下降法只保留了目标函数的一阶近似）。此时再对二阶近似后的目标函数求导，并令其导数等于 0，得到的向量表示的就是下降最快的方向。相比于梯度下降法，牛顿法的收敛速度更快。</p>
<p>群蚁算法、遗传算法、模拟退火算法，禁忌搜索算法等通俗详解<br>
<a href="https://blog.51cto.com/u_13682052/2981273" target="_blank" rel="noopener">https://blog.51cto.com/u_13682052/2981273</a></p>
<p>单只蚂蚁的行为及其简单，行为数量在10种以内，但成千上万只蚂蚁组成的蚁群却能拥有巨大的智慧，这离不开它们信息传递的方式——信息素。蚂蚁在行走过程中会释放一种称为“信息素”的物质，用来标识自己的行走路径。在寻找食物的过程中，根据信息素的浓度选择行走的方向，并最终到达食物所在的地方。信息素会随着时间的推移而逐渐挥发。在一开始的时候，由于地面上没有信息素，因此蚂蚁们的行走路径是随机的。蚂蚁们在行走的过程中会不断释放信息素，标识自己的行走路径。随着时间的推移，有若干只蚂蚁找到了食物，此时便存在若干条从洞穴到食物的路径。由于蚂蚁的行为轨迹是随机分布的，因此在单位时间内，短路径上的蚂蚁数量比长路径上的蚂蚁数量要多，从而蚂蚁留下的信息素浓度也就越高。这为后面的蚂蚁们提供了强有力的方向指引，越来越多的蚂蚁聚集到最短的路径上去。</p>
<p>继续考虑寻找f(x)最大值的问题，爬山算法搜索到A点时就会停止搜索，原因是A点左右的值均小于A点的值。模拟退火算法采用的解决办法是以一定的概率选择A两边的点，尽管A两边的点并不是局部最优解，这样就有一定的概率搜索到D点，从而搜索到B点，最终获得了全局最优解。上文中的一定概率来自于固体退火原理：当固体温度较高时，物质内能较大，固体内部分子运动剧烈；当温度逐渐降低时，物体内能也随之降低，分子运动趋于平稳；当固体温度降到常温时，固体内部分子运动最终平稳。根据Metropolis准则，粒子在温度T时趋于平衡的概率为e^(-ΔE/(kT))，其中E为温度T时的内能，ΔE为其改变量，k为Boltzmann常数。</p>
<p>TODO: numpy实现朴素贝叶斯模型（高斯分布）<br>
<a href="https://www.jianshu.com/p/efa980944235" target="_blank" rel="noopener">https://www.jianshu.com/p/efa980944235</a></p>
<pre><code>import numpy as np


class GaussianNB():

    def fit(self, X, y):
        &quot;&quot;&quot;模型拟合&quot;&quot;&quot;
        self.y_prior = [round(sum(y == i) / len(y), 6) for i in sorted(set(y))]
        self.features_param = []

        for i in sorted(set(y)):
            pos = np.where(y == i)
            features_data = X[pos]
            features_mean = np.mean(features_data, axis=0)
            features_std = np.std(features_data, axis=0)

            param = [(round(avg, 6), round(std, 6)) for avg, std in zip(features_mean, features_std)]
            self.features_param.append(param)

    def predict(self, x):
        &quot;&quot;&quot;模型预测&quot;&quot;&quot;
        result = []
        for i in range(x.shape[0]):
            bayes_prob = []

            for j in range(len(self.y_prior)):
                x_param = self.features_param[j]
                y_param = self.y_prior[j]
                xi_conditional_prob = 1

                for k in range(len(x_param)):
                    xi_conditional_prob *= self.gauss_pro(x[i][k], x_param[k][0], x_param[k][1])
                bayes_prob.append(round(y_param * xi_conditional_prob, 6))
            result.append(np.where(bayes_prob == np.max(bayes_prob))[0][0])

        return np.array(result)

    def gauss_pro(self, v, miu, sigma):
        &quot;&quot;&quot;高斯分布概率密度计算&quot;&quot;&quot;
        part1 = 1 / (sigma * np.sqrt(2 * np.pi))
        part2 = np.exp(-1 * (v - miu) ** 2 / (2 * sigma ** 2))
        return round(part1 * part2, 6)


if __name__ == '__main__':
    from sklearn import datasets

    iris = datasets.load_iris()
    X = iris.data
    y = iris.target

    gnb = GaussianNB()
    gnb.fit(X, y)

    res = gnb.predict(X)
    print(res)
</code></pre>
<h2 id="Neo4j"><a class="header-anchor" href="#Neo4j">¶</a>Neo4j</h2>
<p>neo4j使用文档<br>
<a href="https://www.cnblogs.com/naimao/p/13497046.html" target="_blank" rel="noopener">https://www.cnblogs.com/naimao/p/13497046.html</a></p>
<ul>
<li>它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎，</li>
<li>它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。</li>
<li>图形数据库数据模型的主要构建块是：节点、关系、属性</li>
<li>neo4j主要存储节点和关系，其中关系必须为有向关系，描述节点和关系的数据以属性的形式存储，节点和关系上都能放键值对的属性。不同类型的节点和关系通过标签Label来区别，不同标签的节点代表不同类型节点，不同标签关系代表不同类型关系</li>
</ul>
<p>创建一个标签为Person的节点，其有属性 name 和age：</p>
<pre><code>create (:Person{name:'小红',age:21});
</code></pre>
<p>查询一个节点：</p>
<pre><code>match (m:Person{name:'小红',age:21}) return n;
</code></pre>
<p>删除一个节点：</p>
<pre><code>match (m:Person{name:'小红',age:21}) delete n;
</code></pre>
<p>创建关系：</p>
<pre><code>create (a:Person{name:&quot;a&quot;}),(b:Person{name:&quot;b&quot;}) with a,b create (a)-[r:Friend]-&gt;(b);
</code></pre>
<p>查询关系：</p>
<pre><code>match (a:Person{name:&quot;a&quot;})-[r:Friend]-&gt;(b:Person{name:&quot;b&quot;}) return r;
</code></pre>
<p>删除关系：</p>
<pre><code>match p=(a:Person{name:&quot;a&quot;})-[r:Friend]-&gt;(b:Person{name:&quot;b&quot;}) delete p;
</code></pre>
<hr>
<h2 id="linux-11"><a class="header-anchor" href="#linux-11">¶</a>linux</h2>
<p>Linux–网络通信命令(给其它用户发送广播消息)<br>
<a href="https://blog.csdn.net/qq_42119367/article/details/123427804" target="_blank" rel="noopener">https://blog.csdn.net/qq_42119367/article/details/123427804</a></p>
<pre><code>wall Happy New Year
</code></pre>
<p><a href="http://ipcmen.com/nano" target="_blank" rel="noopener">http://ipcmen.com/nano</a></p>
<p>nano 是一个字符终端的文本编辑器，有点像 DOS 下的 editor 程序。它比 vi/vim 要简单得多，比较适合Linux初学者使用。</p>
<ul>
<li>移动光标：使用用方向键移动。</li>
<li>复制一整行：Alt+6</li>
<li>剪贴一整行：Ctrl+K</li>
<li>粘贴：Ctrl+U</li>
<li>如果需要复制／剪贴多行或者一行中的一部分
<ul>
<li>先将光标移动到需要复制／剪贴的文本的开头</li>
<li>按 Ctrl+6（或者 Alt+A ）做标记</li>
<li>然后移动光标到 待复制／剪贴的文本末尾。这时选定的文本会反白</li>
<li>用 Alt+6 来复制，Ctrl+K 来剪贴。</li>
<li>若在选择文本过程中要取消，只需要再按一次 Ctrl+6。</li>
</ul>
</li>
<li>退出: Ctrl+X: 如
<ul>
<li>果你修改了文件，下面会询问你是否需要保存修改。</li>
<li>输入Y确认保存，输入N不保存，</li>
<li>按 Ctrl+C 取消返回。</li>
<li>如果输入了Y，下一步会让你输入想要保存的文件名。
<ul>
<li>如果不需要修改文件名直接回车就行；</li>
<li>若想要保存成别的名字（也就是另存为）则输入新名称然后确定。</li>
<li>这个时候也可用 Ctrl+C 来取消返回。</li>
</ul>
</li>
</ul>
</li>
<li>撤销：Alt+U</li>
<li>重做: Alt+E</li>
</ul>
<p>Linux visudo配置详解<br>
<a href="http://t.zoukankan.com/wutao1935-p-10045809.html" target="_blank" rel="noopener">http://t.zoukankan.com/wutao1935-p-10045809.html</a></p>
<p>sudo的工作过程如下：</p>
<ul>
<li>当用户执行 sudo 时，系统会主动寻找 /etc/sudoers 文件，判断该用户是否有执行 sudo 的权限</li>
<li>确认用户具有可执行 sudo 的权限后，让用户输入用户自己的密码确认</li>
<li>若密码输入成功，则开始执行 sudo 后续的命令</li>
<li>root 执行 sudo 时不需要输入密码 (sudoers 文件中有配置 root ALL=(ALL) ALL这样一条规则)</li>
<li>若欲切换的身份与执行者的身份相同，也不需要输入密码</li>
</ul>
<p>visudo 使用 vi 打开 /etc/sudoers文件，但是在保存退出时，visudo 会检查内部语法，避免用户输入错误信息</p>
<pre><code># 允许 user1 用户执行任意路径下的任意命令
user1 ALL=(ALL) ALL
# 允许 user1 用户不输入该用户的密码的情况下使用所有命令
user1 ALL=(ALL) NOPASSWD: ALL
# 允许 user1 用户执行特定命令
user1 ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom
</code></pre>
<hr>
<h2 id="量化-2"><a class="header-anchor" href="#量化-2">¶</a>量化</h2>
<p>从零入门量化交易系列(十二)Black-Litterman模型及python实现<br>
<a href="https://zhuanlan.zhihu.com/p/363540266" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/363540266</a></p>
<p>这里还要再说一个重要的假设就是共轭分布，千万别被共轭（conjugate）这个词吓到，它几乎是整个Black-Litterman模型在形式上的核心。原因在于一个正态分布乘以另一个正态分布结果还依然是正态分布。这就是为什么模型不仅要假设\mu服从正态分布，连投资者的观点也要假设为正态分布的原因。这两个正态分布都在分子上，相乘后结果仍为正态分布，而分母上的积分为常数，并不影响新的正态分布的均值和方差。也就是说先验和后验同属于正态分布，两者共轭，因此后验分布的均值方差都可以根据公式快速得到。这也就方便我们得到后验分布的均值，也就是我们想要的期望收益率。</p>
<p>【量化模型】Black-Litterman模型介绍<br>
<a href="https://zhuanlan.zhihu.com/p/25041459" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25041459</a></p>
<p>Markowitz的MPT模型：给定风险水平下的预期收益最大化，也可以是其对偶命题，给定预期收益 水平下的风险最小化。</p>
<ul>
<li>缺点：
<ul>
<li>假设不成立：MPT理论假设为投资者一致且理性（即投资者对预期收益、标准差和风险资产相关性具有一致预测；投资者行为遵循最优化原则，即投资者理性）。现实中显然不成立。</li>
<li>无仓位限制：在无卖空限制条件下，MPT模型经常导致在一些资产上有很大的空头头寸，而实际上大量投资者具有卖空约束。中国市场对卖空进行限制，模型经常导致在某些资产上权重为零，而在另一些资产上权重过大，即出现资产配置过于集中的现象。</li>
<li>参数敏感：对输入参数如预期收益率作小幅度变化，可能导致模型结果发生剧烈变化。</li>
</ul>
</li>
<li>改进：
<ul>
<li>高盛的Fisher Black和Robert Litterman在研究中发现，对组合中德国债券预期报酬率做0.1%小幅修正后，竟然该类资产的投资比例由原来的10.0%提高至55.0%。</li>
<li>做法：加入投资者自己的观点，而且有一定的置信水平。二人提出了BL模型：使用Bayes定理（条件概率），构建收益时通过一定方式对市场隐含收益率与主观预期收益的加权平均。</li>
</ul>
</li>
</ul>
<p>Black-Litterman模型是基于MPT基础上的资产配置理论。BL模型在隐含市场收益率和分析师主观预测信息的基础上，成功解决了MPT模型中假设条件不成立，参数敏感等问题。</p>
<ul>
<li>BL优化后确实战胜市场均衡配置；</li>
<li>BL模型同样也存在模型上的缺陷，需要继续改进。历史数据计算出来的协方差矩阵在长期内可能不能良好刻画出短期关系，需要动态调整；分析师主观预期（看法）信心水平的设定具有很大的主观 随意性，在方法上还存在众多分歧；</li>
<li>BL模型比较符合目前国内基金投资真实市场环境，如关注分析师主观预期，存在投资仓位上下限规定等；</li>
<li>BL模型适用于行业资产配置，而一般不配置具体的投资，倾向区分大类资产；但有的地方也说可以用在个股组合中；</li>
<li>达里奥桥水基金的全球配置更关注风险因子，而非大类。股票中的能源股和部分大宗商品息息相关，从而分配到相同的一类中。是不同于MPT和BL的资产配置理论</li>
</ul>
<p>大奖章基金<br>
<a href="https://baijiahao.baidu.com/s?id=1664399262080636944&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1664399262080636944&amp;wfr=spider&amp;for=pc</a></p>
<ul>
<li>该基金的收费比较高，管理费为 5%，业绩分成比例为 36%。</li>
<li>奖章基金的管理规模在 100 亿美金左右，折合人民币约 700 亿。</li>
<li>二十年年化收益率近 70%</li>
</ul>
<p>【矩阵分析】Condition Number<br>
<a href="https://zhuanlan.zhihu.com/p/81053589" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81053589</a></p>
<ul>
<li>我们在衡量某个函数敏感度与稳定性时，常使用的一种方法是求导。即观察导数[公式] 的大小。</li>
<li>然而对于一个矩阵而言，所谓的导数似乎就不是那么显著，在此我们就介绍一个常用的指标矩阵敏感度指标：Condition Number。</li>
</ul>
<p>TODO: 因子分析的数学基础<br>
<a href="https://zhuanlan.zhihu.com/p/348566335" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/348566335</a></p>
<ul>
<li>1.1 方差</li>
<li>1.2 标准差</li>
<li>1.3 均方误差</li>
<li>1.4 python实现</li>
<li>1.5 协方差</li>
<li>1.6 相关系数</li>
<li>1.7 特征值和特征向量</li>
<li>1.8 使用Python求解特征值和特征向量</li>
<li>1.9逆矩阵和转置矩阵</li>
<li>1.10 矩阵的迹和行列式</li>
</ul>
<p>多元函数泰勒级数展开_用Python学微积分(4)—泰勒级数<br>
<a href="https://blog.csdn.net/weixin_39906358/article/details/111639431" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39906358/article/details/111639431</a></p>
<hr>
<p>WaveFunctionCollapse<br>
<a href="https://github.com/mxgmn/WaveFunctionCollapse" target="_blank" rel="noopener">https://github.com/mxgmn/WaveFunctionCollapse</a></p>
<p>动态生成迷宫</p>
<hr>
<h2 id="shell-3"><a class="header-anchor" href="#shell-3">¶</a>shell</h2>
<p>查看 json 压缩文件里倒数第 2 行的 id， 因为有可能是个末尾损坏的压缩包，所以跳过倒数第一条数据</p>
<pre><code>zcat ./out_000000168373001.gz 2&gt;/dev/null | tail -n2 | head -n1| jq -r '.id'
</code></pre>
<hr>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-source-field.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-source-field.html</a></p>
<p>Think before disabling the _source field<br>
Users often disable the _source field without thinking about the consequences, and then live to regret it. If the _source field isn’t available then a number of features are not supported:</p>
<ul>
<li>The update, update_by_query, and reindex APIs.</li>
<li>On the fly highlighting.</li>
<li>The ability to reindex from one Elasticsearch index to another, either to change mappings or analysis, or to upgrade an index to a new major version.</li>
<li>The ability to debug queries or aggregations by viewing the original document used at index time.</li>
<li>Potentially in the future, the ability to repair index corruption automatically.</li>
</ul>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-id-field.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-id-field.html</a></p>
<ul>
<li>Each document has an _id that uniquely identifies it, which is indexed so that documents can be looked up either with the GET API or the ids query.</li>
<li>The _id can either be assigned at indexing time, or a unique _id can be generated by Elasticsearch.</li>
<li>This field is not configurable in the mappings.</li>
</ul>
<hr>
<p><a href="https://www.517712.com/gupiao/94304.html" target="_blank" rel="noopener">https://www.517712.com/gupiao/94304.html</a></p>
<p>美元加息对黄金影响的三种情况：</p>
<p>1、美元加息利好黄金：美元加息，但货币并未成功回流流回银行系统，而企业贷款利率上涨，贷款困难，就会出现流动性危机，美元会被看空，对黄金就是利好。<br>
2、美元加息利空黄金：美元加息，存款利率上涨，货币顺利回流银行系统，美元升值，对黄金就是利空。<br>
3、美国加息，美元升值，但同时出现地区性动荡、石油危机等情况影响正常经济发展，对黄金有利好作用，就是美元和黄金同时上涨。</p>
<p>国际现货黄金是以美元来定价的，因此美元和黄金价格呈现一定的负相关关系，换句话说当美元上涨时，黄金价格大概率是下跌，而当美元下跌时，黄金价格大概率是上涨。</p>
<hr>
<p>NGINX Proxy to wordpress website<br>
<a href="https://stackoverflow.com/questions/38205743/nginx-proxy-to-wordpress-website" target="_blank" rel="noopener">https://stackoverflow.com/questions/38205743/nginx-proxy-to-wordpress-website</a></p>
<pre><code>location ^~ /blog/ {
  proxy_pass http://127.0.0.1:8080/;
  proxy_set_header Host $http_host;
  proxy_set_header X-Forwarded-Host $http_host;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;
}

/** set the site URL */
define('WP_HOME','http://www.example.com/blog');
define('WP_SITEURL','http://www.example.com/blog');

/** Fix to get the dashboard working with the reverse proxy.*/
$_SERVER['REQUEST_URI'] = str_replace(&quot;/wp-admin/&quot;, &quot;/blog/wp-admin/&quot;,  $_SERVER['REQUEST_URI']);
</code></pre>
<p>Gutenberg breaks completely if site URL is not the same as wordpress URL<br>
<a href="https://github.com/WordPress/gutenberg/issues/1761" target="_blank" rel="noopener">https://github.com/WordPress/gutenberg/issues/1761</a></p>
<hr>
<p>反射放大攻击<br>
<a href="https://baijiahao.baidu.com/s?id=1730701810134759899" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1730701810134759899</a></p>
<p>所谓的反射放大攻击是非常常见的DDoS攻击手法，其基本原理非常简单：攻击者通过控制僵尸网络伪造靶机IP向特定的公网服务器发送请求，公网服务器收到请求后会向靶机发送更大的应答报文，从而实现攻击流量放大。</p>
<p>这里的公网服务器是指对外开放某些可被利用作反射放大的协议端口的服务器，比较常见的协议有DNS、NTP、SNMP、Memcached等，这些协议一般基于UDP，并且协议本身存在缺陷，没有校验来源IP的真实性，且存在应答报文远大于请求报文等特点。这种反射放大手法简单、有效，一直深受黑客喜爱，所以很长一段时间内UDP反射就是反射放大攻击的别称。</p>
<p>早在2018年就出现利用公网服务器开放的TCP端口进行反射攻击的手法，相比UDP反射放大攻击，此类利用TCP协议栈的反射攻击实际并无太明显的流量放大效果，因为请求的来源IP是伪造的，无法与TCP服务器完成TCP三次握手建立连接，所以无法得到应用层的应答报文。但是这种攻击利用了TCP的协议栈特性，使靶机看到攻击流量具备协议栈行为，而且成份复杂(synack、ack、rst等混合流量)，导致反向挑战、协议栈行为校验等传统的TCP防护算法无法防护，大大增加了防护难度，所以这种TCP反射诞生后很快成为DDoS攻击的主流攻击手法。</p>
<p>放大系数可以理解为流量的放大倍数，计算方法非常简单，就是response总长度/query总长度。传统的UDP反射攻击的放大系数与具体的协议实现相关，所以放大系数是一个相对固定的值：除了Memcached反射攻击以外，其他UDP反射放大系数不超过600，而且以200以内为主。</p>
<hr>
<h2 id="nginx-2"><a class="header-anchor" href="#nginx-2">¶</a>nginx</h2>
<p>A Guide to Caching with NGINX and NGINX Plus<br>
<a href="https://www.nginx.com/blog/nginx-caching-guide/" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-caching-guide/</a></p>
<h2 id="docker-2"><a class="header-anchor" href="#docker-2">¶</a>docker</h2>
<p>docker数据卷与数据卷容器以及备份与恢复<br>
<a href="https://blog.csdn.net/m0_60360828/article/details/122641289" target="_blank" rel="noopener">https://blog.csdn.net/m0_60360828/article/details/122641289</a></p>
<p>创建容器</p>
<pre><code>docker run -it -v /opt --name test_1 centos:7 /bin/bash

    echo &quot;123321&quot; &gt; /opt/1.txt
</code></pre>
<p>备份</p>
<pre><code>docker run -it --volumes-from test_1 -v /mnt:/mnt centos:7 tar cvf /mnt/opt.tar /opt
</code></pre>
<ul>
<li><code>--volumes-from test_1</code> ：指定数据卷容器所在</li>
<li><code>-v /mnt:/mnt</code>：共享该容器中mnt目录到主机的mnt</li>
<li><code>tar cvf /mnt/opt.tar /opt</code>：这个较为绕，mnt是该容器跟主机之间共享的一个目录。所以将备份后的数据放到这个文件中，好备份之后直接导到主机。</li>
<li>后面跟随的备份目标路径，则是该容器与数据卷容器之间的共享目录，因为要对数据卷容器进行备份，所以则是需要备份该目录</li>
</ul>
<p>查看备份</p>
<pre><code>ls /mnt/
tar xvf opt.tar
cat ./opt/1.txt
</code></pre>
<p>恢复</p>
<pre><code>#创建数据卷容器，并且共享opt目录
docker run -it -v /opt --name test_2 nginx:1.12 /bin/bash

#创建一个容器，作用是从主机中获取文件，并且将该文件传输给数据卷容器
docker run -itd --volumes-from test_2 -v /mnt:/mnt nginx:1.12 tar xvf /mnt/opt.tar -C /opt/

cd opt/ &amp;&amp; ls
cat ./opt/1.txt
</code></pre>
<h2 id="elasticsearch-3"><a class="header-anchor" href="#elasticsearch-3">¶</a>elasticsearch</h2>
<p>Field data typesedit<br>
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html</a></p>
<p>Each field has a field data type, or field type. This type indicates the kind of data the field contains, such as strings or boolean values, and its intended use. For example, you can index strings to both text and keyword fields. However, text field values are analyzed for full-text search while keyword strings are left as-is for filtering and sorting.</p>
<h2 id="pandas"><a class="header-anchor" href="#pandas">¶</a>pandas</h2>
<p>设置时间索引</p>
<pre><code>data['time_key'] = pd.to_datetime(data['time_key'])
data.set_index('time_key', inplace=True)
</code></pre>
<p>设置图表默认大小</p>
<pre><code>from matplotlib import pyplot as plt 
plt.rcParams['figure.figsize'] = (16, 8)
</code></pre>
<p>两个指标各用一个坐标轴</p>
<pre><code>data[['close','volume']].plot(secondary_y=['volume'])
</code></pre>
<p>两个指标各用一个子图</p>
<pre><code>fre[['fre','cumsum']].plot(subplots=True)
</code></pre>
<p>分成 10 段，显示每个段的数量</p>
<pre><code>data['real_vol_22'].hist(bins=10)
</code></pre>
<p>pandas数据可视化原来也这么厉害<br>
<a href="https://baijiahao.baidu.com/s?id=1684407979428084767&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1684407979428084767&amp;wfr=spider&amp;for=pc</a></p>
<p>pandas 区间间隔 pd.Interval<br>
<a href="https://www.gairuo.com/p/pandas-interval" target="_blank" rel="noopener">https://www.gairuo.com/p/pandas-interval</a></p>
<hr>
<h2 id="理财-3"><a class="header-anchor" href="#理财-3">¶</a>理财</h2>
<p>无风险数字货币套利之三角套利<br>
<a href="https://zhuanlan.zhihu.com/p/394421805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/394421805</a></p>
<p>三角套利，是指交易者利用三种不同的数字货币的价格不匹配的过程。 通过买卖这些特定货币，交易者获得了无风险的利润。 这种失配通常只会持续几秒钟，因为有大量的交易员正在积极寻找这样的机会，因此三角套利主要是通过程序化的量化交易来完成的。</p>
<p>以btc、eth和usdt三种数字货币来说，而交易所存在eth/btc、eth/eos、btc/eos三个交易对，同时三个交易对之间存在价差，那么首先可以使用价值400元的eth购买对应份额的eos，而后在使用这些的eos兑换成btc，最后可以将兑换btc兑换成eth，那么最终结果就是你净赚10元，同时又由于这些交易都是瞬时完成的，也就可以近似认为是无风险套利了，其中唯一的风险就是别人比你的交易速度更快。</p>
<p>三角套利是利用交叉汇率定价错误进行的套利。套利使得实际交叉汇率与理论交叉汇率保持一致。在国际市场上，几乎所有的货币兑美元都有一个兑换率。两个非美国国家之间的理论汇率可以从它们与美元之间的汇率中推断出来，这种套算出来的汇率称为理论交叉汇率。在现实世界中，很少会出现根据交易商对美元汇率报价计算出的理论交叉汇率不同于交易商报出的实际交叉汇率的情况。如果差异大到足以与购买及出售货币的交易成本相比，就出现了无风险套利机会。</p>
<p>平稳（非平稳）时间序列<br>
<a href="https://zhuanlan.zhihu.com/p/425684691" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/425684691</a></p>
<p>金融时间序列分析——对收益率序列平稳化处理<br>
<a href="https://blog.csdn.net/m0_37876745/article/details/108994950" target="_blank" rel="noopener">https://blog.csdn.net/m0_37876745/article/details/108994950</a></p>
<p>谈谈时间序列的平稳性<br>
<a href="https://blog.csdn.net/TimeFuture/article/details/120690021" target="_blank" rel="noopener">https://blog.csdn.net/TimeFuture/article/details/120690021</a></p>
<ul>
<li>时间序列分析中的许多预测和分析方法，如 ARMA、Granger 因果检验等，都要求输入序列是平稳的。</li>
<li>大多数时间序列都是非平稳的，比如一些股票的收盘价数据就是非平稳的。</li>
<li>如果时间序列包含明显的趋势和季节性，会影响算法准确预测时间序列的能力。</li>
<li>一般可以通过差分、取对数等方法转化成平稳时间序列。
<ul>
<li>一步的差分其实就是今天的价格和昨天的价格相减再除以昨天的价格：<code>df['Close'] - df['Close'].shift(1)</code></li>
<li>对原始数据取对数然后再差分：<code>np.log(df['Close']) - np.log(df['Close'].shift(1)</code></li>
</ul>
</li>
<li>对转换后的数据集运行 Augmented Dicker-Fuller 测试，以确保平稳性</li>
</ul>
<p>安装 ta-lib</p>
<pre><code>sudo apt install build-essential wget -y
wget https://artiya4u.keybase.pub/TA-lib/ta-lib-0.4.0-src.tar.gz
tar -xvf ta-lib-0.4.0-src.tar.gz
cd ta-lib/
./configure --prefix=/usr
make
sudo make install

pip install TA-Lib
</code></pre>
<p>backtrader绘图运行出matplotlib错的原因<br>
<a href="https://www.jianshu.com/p/2dc8a671ab7a" target="_blank" rel="noopener">https://www.jianshu.com/p/2dc8a671ab7a</a></p>
<p>backtrader与matplot 3.3不兼容，要降级到3.2，运行如下命令可降级：</p>
<pre><code>pip uninstall matplotlib
pip install matplotlib==3.2.2

pip uninstall pyfolio
pip install git+https://github.com/quantopian/pyfolio
</code></pre>
<p>Pyfolio一行代码实现专业量化回测图表<br>
<a href="https://zhuanlan.zhihu.com/p/376954470" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/376954470</a></p>
<p>pyfolio 是全球最大量化网站Quantopian开发的量化“三剑客”之一，另外两个分别是alphalens（用于多因子分析）和zipline（类似backtrader的回测框架）。pyfolio非常适合用于金融投资组合性能和风险分析，包括与Zipline和alphalens结合，输出专业的量化指标和图表分析结果。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk1MDY2MQ==&amp;mid=2247483991&amp;idx=1&amp;sn=7e2a54011706fd88ff7cef2007f840d8&amp;chksm=f9e3c4bdce944daba8cdd20fa7ca26704381779159f2aa25e66a2d1f527590e29c906df9a697&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Python量化策略风险指标</a></p>
<p>不显示 warnings<br>
import warnings<br>
warnings.filterwarnings(‘ignore’)</p>
<p>PEG指标<br>
<a href="https://baike.baidu.com/item/PEG%E6%8C%87%E6%A0%87/10904043" target="_blank" rel="noopener">https://baike.baidu.com/item/PEG指标/10904043</a></p>
<ul>
<li>背景：
<ul>
<li>投资者普遍习惯于使用市盈率来评估股票的价值，但是，当遇到一些极端情况时，市盈率的可操作性就有局限，比如市场上有许多远高于股市平均市盈率水平，甚至高达上百倍市盈率的股票，此时就无法用市盈率来评估这类股票的价值。</li>
<li>但如果将市盈率和公司业绩成长性相对比，那些超高市盈率的股票看上去就有合理性了，投资者就不会觉得风险太大了，这就是PEG估值法。</li>
</ul>
</li>
<li>定义：
<ul>
<li>PEG 指标(市盈率相对盈利增长比率)是用公司的市盈率除以公司的盈利增长速度。</li>
<li>所谓 PEG，是用公司的市盈率（PE）除以公司未来 3 或 5 年的（每股收益复合增长率*100）。</li>
<li>它由股票的未来市盈率除以每股盈余(EPS)的未来增长率预估值得出。</li>
<li>它是在 PE 估值的基础上发展起来的，它弥补了 PE 对企业动态成长性估计的不足。</li>
<li>PE 仅仅反映了某股票当前价值，PEG 则把股票当前的价值和该股未来的成长联系了起来 。</li>
</ul>
</li>
<li>特点
<ul>
<li>通常成长型股票的 PEG 都会高于 1，甚至在 2 以上，投资者愿意给予其高估值，表明这家公司未来很有可能会保持业绩的快速增长，这样的股票就容易有超出想象的市盈率估值。</li>
<li>通常价值型股票的 PEG 都会低于 1，以反映低业绩增长的预期。当 PEG 小于 1 时，要么是市场低估了这只股票的价值，要么是市场认为其业绩成长性可能比预期的要差。</li>
</ul>
</li>
<li>使用
<ul>
<li>粗略而言，PEG 值越低，股价遭低估的可能性越大。</li>
<li>选股的时候选那些市盈率较低，同时它们的增长速度又是比较高的公司，这些公司有一个典型特点就是 PEG 会非常低。</li>
<li>PEG 始终是主导股票运行的重要因素，所以寻找并持有低 PEG 的优质股票是获利的重要手段。</li>
<li>当然，也不能够机械的单以 PEG 论估值，还必须结合国际市场、宏观经济、国家的产业政策、行业景气、资本市场阶段热点、股市的不同区域、上市公司盈利增长的持续性以及上市公司的其他内部情况等等多种因素来综合评价。</li>
</ul>
</li>
<li>缺点
<ul>
<li>须注意的是，PEG值的分子与分母均涉及对未来盈利增长的预测，出错的可能较大。</li>
<li>计算 PEG 值所需的预估值，一般取市场平均预估(consensus estimates)，即追踪公司业绩的机构收集多位分析师的预测所得到的预估平均值或中值。</li>
</ul>
</li>
</ul>
<p>详解PE与PEG估值法<br>
<a href="https://zhuanlan.zhihu.com/p/353770859" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/353770859</a></p>
<p>如何评价纳西姆·塔勒布的《反脆弱》？该书都有哪些优劣之处？<br>
<a href="https://www.zhihu.com/question/24684650/answer/1174590096" target="_blank" rel="noopener">https://www.zhihu.com/question/24684650/answer/1174590096</a></p>
<p>本书的核心观点是：事物的发展从来都是非线性发展，一切事物都会从波动中获得收益或遭受损失，反脆弱就是能在波动性和不确定性中带来收益。</p>
<p>最好应对风险的方法是“以毒攻毒”，设计一个“反脆弱结构”。这里就是反脆弱概念，让自己经常暴露在风险中，提高自己生活的“波动性”，利用“波动性”平衡风险，并伺机利用风险获利。</p>
<p>通过非线性理论让我们知道，机遇某种程度比能力更重要，不能指望人生是线性发展，也并非“一分耕耘一分收获”，能力提高就能升职加薪。现实中，确定性事件和不确定性事件至少同样多。为了实现收入指数性增长而非线性增长，必须寻找新的增长点。</p>
<p><a href="https://baijiahao.baidu.com/s?id=1732327796243580868&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1732327796243580868&amp;wfr=spider&amp;for=pc</a></p>
<ul>
<li>书中提出的应对不确定性的策略是杠铃策略——极端保守+极端投机的策略。其核心思想是为了避开中间地带，首要的是降低不利因素，而不是增加有利因素。</li>
<li>对于脆弱的系统而言，其他任何“增加效率、增加成功”的行为在“实现生存”这一需求面前都是不重要的。因此极端保守的策略显得如此重要。</li>
<li>同时，为了获得收益，又需要搭配极端投机策略。在投资中就体现为“现金+投机资产”或股票投资中的“高确定性标的+高投机性标的”的组合。</li>
<li>总结一下，反脆弱的杠铃策略在投资中的实践就是：先活下来，不要亏钱，再寻求收益。</li>
<li>脆弱的系统往往在大多数时候给予人们较好的体验，但在不确定性来临时不堪一击，其核心问题是不确定性来临时无法生存。</li>
</ul>
<p><a href="https://baijiahao.baidu.com/s?id=1698275248230462135&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1698275248230462135&amp;wfr=spider&amp;for=pc</a></p>
<ul>
<li>脆弱的事物依赖稳定环境，比如一个没有任何保护的股票多头策略，一旦市场大幅下跌将很可能会损失惨重。</li>
<li>强韧的事物不太依赖环境，环境怎么变它都不太会变。但是强韧不等于反脆弱，因为它无法从不确定性中获益。</li>
<li>反脆弱不是坚强，而是越挫越勇。外界环境越波动、随机、混乱越不会受伤，反而利用波动环境茁壮成长。就像人类的免疫系统，受到的冲击越多越坚强。</li>
<li>90%的现金和10%的期权就是一个比较典型的杠铃策略。一侧是极端的风险厌恶，一侧是极端的风险偏好，不走中间道路。当然，风险端的投资也要判断尽量有很高胜算才能参与，不能把期权当成赌大小的骰子。</li>
</ul>
<p>钱：7步创造终身收入 笔记<br>
<a href="https://book.douban.com/review/10111467/" target="_blank" rel="noopener">https://book.douban.com/review/10111467/</a></p>
<p>重新认识风险</p>
<ul>
<li>传统观点是收益和风险成长比，其实未然。</li>
<li>投资大师寻找风险小收益大的投资机会。</li>
<li>高风险并不一定都带来高收益，高收益也不一定都要高风险。</li>
<li>结构化票据、市场联动大额存单、固定指数年金等都是低风险高收益的投资对象。</li>
<li>投资还有运气成分，完全相同的策略，如果开始的年份不同，可能后面结果完全不同。</li>
</ul>
<p>量化理财目标: 量化实现目标所需的财富水平，设定个人的理财目标：</p>
<ul>
<li>财务安全：解决住房、水电、吃饭、交通、保险等问题</li>
<li>财务活力：财务安全 + 着装、娱乐、美食等额外需求</li>
<li>财务独立：现有生活水平</li>
<li>财务自由：相对有品质的生活</li>
<li>财务绝对自由：非常有品质的生活</li>
</ul>
<p>采取行动</p>
<ul>
<li>开源
<ul>
<li>通过提升技能，增加收入。</li>
<li>通过创业创新，增加收入。</li>
</ul>
</li>
<li>节流
<ul>
<li>改变生活方式以减少开支。</li>
<li>压缩不必要的，或者低效的开支。</li>
<li>提前偿还部分房贷本金，从而减少利息支出。</li>
<li>为了压缩开支，减少税赋，搬家也是值得的。</li>
</ul>
</li>
<li>储蓄
<ul>
<li>建立储蓄账户、养老账户。</li>
<li>拿出收入的固定比例，自动存入账户，建立「财务自由投资基金」。</li>
</ul>
</li>
</ul>
<p>达利欧组合</p>
<ol>
<li>
<p>达利欧在哈里·马科维茨（现代投资组合理论之父）的基础上创立了全天候投资策略。</p>
</li>
<li>
<p>达利欧总结出 4 种不同的经济环境（经济季节），匹配四种不同的投资组合。</p>
</li>
<li>
<p>达利欧全天候投资策略拥有高收益、高安全、低波动的特点。</p>
</li>
<li>
<p>简化版的达利欧组合包括：</p>
<ul>
<li>长期国债：40%</li>
<li>股票：30%</li>
<li>中期国债：15%</li>
<li>黄金：7.5%</li>
<li>大宗商品：7.5%</li>
</ul>
</li>
<li>
<p>净利润: 净利润是一个企业经营的最终成果，净利润多，企业的经营效果好。</p>
<ul>
<li>第 1 步：计算销售净额，也就是营业收入，是指销售总额减销货退回与折让，以及销售税金后的余额；</li>
<li>第 2 步：计算销售毛利，即销售净额减销售成本后的余额；</li>
<li>第 3 步：计算销售利润，即销售毛利减销售费用、管理费用、财务费用等期间费用后的余额；</li>
<li>第 4 步：计算营业利润，即销售利润加上其他业务利润后的余额；</li>
<li>第 5 步：计算利润总额，即营业利润加营业外收支后的余额；</li>
<li>第 6 步：计算所得税后的净利润，即利润总额减应计所得税(支出)后的余额。</li>
</ul>
</li>
<li>
<p>归母净利润：归属于母公司所有者的净利润才是投资人真正要关心的数字，它是由净利润扣除掉 “少数股东损益”得到。</p>
<ul>
<li>假设：甲上市公司旗下只有一家子公司 A，并且持其 70% 的股份。</li>
<li>如果 2017 年，A 公司的净利润是 1 亿，且甲和 A 之间没有任何关联关系。</li>
<li>上市公司在制定合并利润表时，在净利润科目中，增加不是 7000万 而是 1 亿。</li>
<li>但真正属于上市公司股东，也就是所有股民的净利润要把另外 3000 万扣除掉。</li>
<li>持有 A 公司 30% 股份的那些股东就被称之为少数股东，而这个 3000 万就叫作“少数股东权益”。</li>
</ul>
</li>
<li>
<p>扣非归母净利润：“归母净利润” 减去“非经常性损益”，即扣掉公司正常经营损益之外的一次性或者偶发性损失</p>
<ul>
<li>处置长期股权投资、固定资产、在建工程、无形资产、其他长期资产产生的损益；</li>
<li>越权审批或无正式批准文件的税收返还、减免；</li>
<li>各种形式的政府补贴；</li>
<li>因不可抗力因素，如遭受自然灾害而计提的各项资产减值准备；</li>
</ul>
</li>
</ol>
<hr>
<p>链接：<a href="https://wenku.baidu.com/view/02399cd5cbd376eeaeaad1f34693daef5ef71365.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/02399cd5cbd376eeaeaad1f34693daef5ef71365.html</a></p>
<p>利润概念：</p>
<ul>
<li>毛利润 = 主营业务净收入-主营业务支出-主营业务税金及附加</li>
<li>利润总额 = 主营业务净收入-主营业务支出-主营业务税金及附加+其他业务利润-营业费用-管理费用-财务费用+投资收益+营业外收入-营业务支出</li>
<li>净利润 = 利润总额-所得税</li>
<li>息税前利润 = 利润总额+利息支出</li>
<li>税前利润 = 利润总额</li>
<li>税后利润 = 净利润</li>
<li>归母净利润 = 净利润 - 少数股东损益(母公司未持有子公司股权部分的收益)</li>
<li>扣非归母净利润 = 归母净利润 - 非经常性损益(公司正常经营损益之外的一次性或者偶发性损失)</li>
</ul>
<p>息税前利润通俗地说就是不扣除利息也不扣除所得税的利润, 顾名思义,是指不支付利息和所得税之前的利润.</p>
<h2 id="毛利率高：说明行业好，业务模式好，竞争不激烈，有钱赚。毛利率低：说明是夕阳行业，没钱赚，或者竞争太大，打价格战。净利率高：说明管理水平高，成本和费用控制的好。净利率低：说明运营效率低，管理水平差，公司不行。俩都高：说明行业好，公司牛。"><a class="header-anchor" href="#毛利率高：说明行业好，业务模式好，竞争不激烈，有钱赚。毛利率低：说明是夕阳行业，没钱赚，或者竞争太大，打价格战。净利率高：说明管理水平高，成本和费用控制的好。净利率低：说明运营效率低，管理水平差，公司不行。俩都高：说明行业好，公司牛。">¶</a>毛利率高：说明行业好，业务模式好，竞争不激烈，有钱赚。<br>
毛利率低：说明是夕阳行业，没钱赚，或者竞争太大，打价格战。<br>
净利率高：说明管理水平高，成本和费用控制的好。<br>
净利率低：说明运营效率低，管理水平差，公司不行。<br>
俩都高：说明行业好，公司牛。</h2>
<p>这样理解的对不？</p>
<p>12种底部形态特征<br>
<a href="https://www.zhihu.com/question/280125504/answer/2228221734" target="_blank" rel="noopener">https://www.zhihu.com/question/280125504/answer/2228221734</a></p>
<p>钱：7步创造终身收入<br>
<a href="https://book.douban.com/subject/27667390/" target="_blank" rel="noopener">https://book.douban.com/subject/27667390/</a></p>
<p>7步创造终身收入：</p>
<ol>
<li>多存钱 （花小钱，存大钱）</li>
<li>少上当（只投正路，不被骗钱）</li>
<li>做规划（这辈子目标要赚到多少钱，需要多久，算下来年化收益目标是多少）</li>
<li>做资产配置（三个水桶：一 安全安心水桶 只买固定收益，本金安全 二 风险成长水桶 做股票投资房地产投资 三 梦想水桶 追逐梦想）</li>
<li>稳收入（强烈推荐保险年金）</li>
<li>学大师（巴菲特达利欧邓普顿等）</li>
<li>大财富（前面6步都只是小财富，人最大的财富就是健康，活的更爽和更久最重要，最带来幸福感的不是得到，而是付出和给予。不是物质而是激情，不是过去而是未来。</li>
</ol>
<p>分享下《钱》的完整笔记<br>
<a href="https://book.douban.com/review/10111467/" target="_blank" rel="noopener">https://book.douban.com/review/10111467/</a></p>
<hr>
<h2 id="mysql-12"><a class="header-anchor" href="#mysql-12">¶</a>mysql</h2>
<p>部署MySQL延迟从库的几个好处<br>
<a href="https://blog.51cto.com/imysql/3170546" target="_blank" rel="noopener">https://blog.51cto.com/imysql/3170546</a><br>
<a href="https://dev.mysql.com/doc/refman/8.0/en/replication-delayed.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/replication-delayed.html</a></p>
<p>MySQL延迟从库的好处主要有几点：</p>
<ul>
<li>误删除时，能更快恢复数据。 有时候手抖了，把线上数据给误删除了，或者误删除库、表、其他对象，或不加WHERE条件的更新、删除，都可以让延迟从库在误操作前的时间点停下，然后进行恢复。</li>
<li>把延迟从库作为专用的备份节点。虽然有一定的延迟，但并不影响利用该节点作为备份角色，也不影响生产节点数据库库。</li>
<li>还可以把延迟从库当做一些问题、案例研究的对象。个别时候，可能有些binlog event在普通从库上会有问题（例如早期版本中无主键会导致从库更新非常慢的经典问题），这时就有时间在延迟从库上慢慢琢磨研究了。</li>
</ul>
<hr>
<h2 id="php-2"><a class="header-anchor" href="#php-2">¶</a>php</h2>
<p>How do I create a copy of an object in PHP?<br>
<a href="https://stackoverflow.com/questions/185934/how-do-i-create-a-copy-of-an-object-in-php" target="_blank" rel="noopener">https://stackoverflow.com/questions/185934/how-do-i-create-a-copy-of-an-object-in-php</a></p>
<p>$objectB = clone $objectA;</p>
<hr>
<h2 id="linux-12"><a class="header-anchor" href="#linux-12">¶</a>linux</h2>
<p>rc.local</p>
<pre><code>printf '%s\n' '[Install]' 'WantedBy=multi-user.target' 'Alias=rc-local.service' | sudo tee -a /usr/lib/systemd/system/rc-local.service

echo &quot;
[Install]
WantedBy=multi-user.target
Alias=rc-local.service
&quot; &gt;&gt; /usr/lib/systemd/system/rc-local.service

tail /usr/lib/systemd/system/rc-local.service
echo '#!/bin/bash' &gt; /etc/rc.local
chmod +x /etc/rc.local
systemctl enable rc-local
systemctl start rc-local
systemctl status rc-local
</code></pre>
<p>iptables</p>
<pre><code>iptables -A INPUT  -i eth0 -p tcp -s 140.143.1.1--dport 8080 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT -p tcp --dport 8080 -j DROP
iptables -L -n
iptables-save &gt;/etc/iptables-script
cat /etc/iptables-script
iptables-restore &lt;/etc/iptables-script
echo '/sbin/iptables-restore &lt;/etc/iptables-script' &gt;&gt;/etc/rc.local
</code></pre>
<p>linux命令：iptables、modprobe装载模块、网络防火墙服务<br>
<a href="https://blog.51cto.com/woyaoxuelinux/1906316" target="_blank" rel="noopener">https://blog.51cto.com/woyaoxuelinux/1906316</a></p>
<ul>
<li>iptables 的前身叫ipfirewall （内核1.x时代）,这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。但是ipfirewall工作功能极其有限(它需要将所有的规则都放进内核当中，这样规则才能够运行起来，而放进内核，这个做法一般是极其困难的)。</li>
<li>当内核发展到2.x系列的时候，软件更名为 ipchains，它可以定义多条规则，将他们串起来，共同发挥作用，</li>
<li>而现在，它叫做iptables，可以将规则组成一个列表，实现绝对详细的访问控制功能。</li>
<li>他们都是工作在用户空间中，定义规则的工具，本身并不算是防火墙。</li>
<li>而放入内核的地方必须要是特定的位置，必须是 tcp/ip 的协议栈经过的地方，叫做 netfilter.(网络过滤器)</li>
</ul>
<hr>
<h2 id="postgree-3"><a class="header-anchor" href="#postgree-3">¶</a>postgree</h2>
<p>PostgreSQL 生成随机数字、字符串、日期、验证码以及 UUID<br>
<a href="https://blog.csdn.net/horses/article/details/109215148" target="_blank" rel="noopener">https://blog.csdn.net/horses/article/details/109215148</a></p>
<p>生成 0 到 1 之间的随机数</p>
<pre><code>SELECT random();
</code></pre>
<p>任意两个数字之间的随机数</p>
<pre><code>low + RANDOM() * (high - low)
</code></pre>
<hr>
<h2 id="elasticsearch-4"><a class="header-anchor" href="#elasticsearch-4">¶</a>elasticsearch</h2>
<p>Elasticsearch性能调优之磁盘读写性能优化<br>
<a href="https://blog.csdn.net/lm324114/article/details/105029393/" target="_blank" rel="noopener">https://blog.csdn.net/lm324114/article/details/105029393/</a></p>
<ul>
<li>禁用不需要的功能
<ul>
<li>聚合：doc values</li>
<li>搜索：倒排索引，index</li>
<li>评分：norms</li>
<li>近似匹配：index_options（freqs）</li>
</ul>
</li>
<li>不要用默认的动态 string 类型映射
<ul>
<li>默认的动态 string 类型映射会将 string 类型的 field 同时映射为 text 类型以及 keyword 类型，这会浪费磁盘空间，因为我们不一定两种都需要。</li>
</ul>
</li>
<li>禁止_all field:
<ul>
<li>_all field会将document中所有field的值都合并在一起进行索引，很耗费空空间，如果不需要一次性对所有的field都进行搜索，那么最好禁用_all field。</li>
</ul>
</li>
<li>使用 best_compression
<ul>
<li>_source field 和其他 field 都很耗费磁盘空间，最好是对其使用 best_compression 进行压缩。</li>
</ul>
</li>
<li>用最小的最合适的数字类型
<ul>
<li>es 支持 4 种数字类型，byte，short，integer，long。如果最小的类型就合适，那么就用最小的类型。</li>
</ul>
</li>
</ul>
<p>如果我们有一个叫做 foo 的数字类型 field，我们要对这个字段运行 histograms aggr 聚合操作，但是可能我们并不需要对这个字段进行搜索，那么就可以禁止为这个字段生成倒排索引，只需要 doc value 正排索引即可。</p>
<pre><code>&quot;foo&quot;: {
    &quot;type&quot;: &quot;integer&quot;,
    &quot;index&quot;: false
}
</code></pre>
<p>text 类型的 field 会存储 norm 值，用来计算 doc 的相关度分数，如果我们需要对一个 text field 进行搜索，但是不关心这个 field的分数，那么可以禁用 norm 值。</p>
<pre><code>&quot;foo&quot;: {
    &quot;type&quot;: &quot;text&quot;,
    &quot;norms&quot;: false
}
</code></pre>
<p>text field 还会存储出现频率以及位置，出现频率也是用来计算相关度分数的，位置是用来进行 phrase query 这种近似匹配操作的，如果我们不需要执行 phrase query 近似匹配，那么可以禁用位置这个属性：</p>
<pre><code>&quot;foo&quot;: {
    &quot;type&quot;: &quot;text&quot;,
    &quot;index_options&quot;: &quot;freqs&quot;
}
</code></pre>
<p>如果我们不关心相关度频分，我们可以配置 es 仅仅为每个 term 索引对应的 document，我们可以对这个 field 进行搜索，但是 phrase query 这种近似匹配会报错，而且相关度评分会不准确。</p>
<pre><code>&quot;foo&quot;: {
    &quot;type&quot;: &quot;text&quot;,
    &quot;norms&quot;: false,
    &quot;index_options&quot;: &quot;freqs&quot;
}
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2024 onlytiancai
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="//cdnjs.cloudflare.com/ajax/libs/require.js/2.1.6/require.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>